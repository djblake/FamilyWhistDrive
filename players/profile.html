<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Player Profile | Ruston Family Whist Drive</title>
    <meta name="description" content="Complete career statistics and achievements for a championship Whist player">
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="/assets/js/footer-nav.js?v=4" defer></script>
    <script src="/assets/js/media.js?v=1" defer></script>
</head>
<body>
        <header class="header">
        <div class="container">
            <div data-header-nav></div>
        </div>
    </header>

    <main class="main-content">
        <section class="player-hero">
            <div class="container">
                <div class="player-profile">
                    <div class="player-avatar">
                        <div class="avatar-frame" id="player-avatar-frame" role="button" tabindex="0" aria-label="Open avatar">
                        <div class="avatar-placeholder">
                            <div class="avatar-icon" id="player-icon">üéØ</div>
                            <div class="avatar-initial" id="player-initial">--</div>
                        </div>
                        <img id="player-avatar-img" alt="" style="display:none;">
                        </div>
                        <div style="margin-top: 0.75rem; display:flex; justify-content:center;">
                            <a class="btn btn-secondary" id="upload-avatar-link" href="../upload/avatar.html" style="display:none;">Add / change avatar</a>
                        </div>
                        <div class="champion-badge" id="champion-badge" style="display: none;">Champion</div>
                        <div class="family-tree-link family-tree-link--avatar">
                            <a href="../families/" class="family-tree-btn" id="family-tree-btn">
                                <span class="tree-icon">üå≥</span>
                                Family Tree
                            </a>
                            <div class="memorial-link" id="memorial-link" style="display:none;">
                                <a class="memorial-link__a" id="memorial-link-a" href="../memorial/">
                                    <div class="memorial-wreath" aria-hidden="true">
                                        <svg viewBox="0 0 64 64" width="46" height="46" focusable="false" aria-hidden="true">
                                            <path d="M22 50c-7-6-12-15-12-24C10 16 17 9 26 9" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
                                            <path d="M42 50c7-6 12-15 12-24C54 16 47 9 38 9" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>
                                            <path d="M26 12c-4 2-7 7-7 14" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" opacity="0.55"/>
                                            <path d="M38 12c4 2 7 7 7 14" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" opacity="0.55"/>
                                            <circle cx="32" cy="50" r="3" fill="currentColor" opacity="0.8"/>
                                        </svg>
                                    </div>
                                    <div class="memorial-label">In memoriam</div>
                                    <div class="memorial-year" id="memorial-year">‚Äî</div>
                                </a>
                            </div>
                        </div>
                    </div>
                    
                    <div class="player-info">
                        <div class="player-header">
                            <h1 class="player-name" id="player-name">Loading...</h1>
                            <div class="player-nickname" id="player-nickname" style="display: none;"></div>
                            <div class="player-title" id="player-title">Tournament Player</div>
                        </div>
                        
                        <div class="player-meta" id="player-meta">
                            <div class="meta-item">
                                <span class="meta-label">First Tournament</span>
                                <span class="meta-value" id="first-tournament">-</span>
                            </div>
                            <div class="meta-item">
                                <span class="meta-label">Years Active</span>
                                <span class="meta-value" id="years-active">-</span>
                            </div>
                            <div class="meta-item">
                                <span class="meta-label">Total Tournaments</span>
                                <span class="meta-value" id="total-tournaments">-</span>
                            </div>
                            <div class="meta-item">
                                <span class="meta-label">Seed Rank</span>
                                <span class="meta-value" id="current-ranking">-</span>
                            </div>
                        </div>

                        <div class="career-highlights" id="career-highlights">
                            <div class="highlight-card primary">
                                <div class="highlight-icon">üèÜ</div>
                                <div class="highlight-content">
                                    <div class="highlight-number" id="tournament-victories">-</div>
                                    <div class="highlight-label">Tournament Victories</div>
                                </div>
                            </div>
                            <div class="highlight-card">
                                <div class="highlight-icon">üéØ</div>
                                <div class="highlight-content">
                                    <div class="highlight-number" id="total-tricks">-</div>
                                    <div class="highlight-label">Total Tricks</div>
                                </div>
                            </div>
                            <div class="highlight-card">
                                <div class="highlight-icon">üìä</div>
                                <div class="highlight-content">
                                    <div class="highlight-number" id="avg-tricks">-</div>
                                    <div class="highlight-label">Avg Tricks/Round</div>
                                </div>
                            </div>
                            <div class="highlight-card">
                                <div class="highlight-icon">ü•â</div>
                                <div class="highlight-content">
                                    <div class="highlight-number" id="top-finishes">-</div>
                                    <div class="highlight-label">Top 3 Finishes</div>
                                </div>
                            </div>
                        </div>

                        <div class="trophy-cabinet" id="trophy-cabinet">
                            <div class="trophy-cabinet-label">Trophy Cabinet</div>
                            <div class="trophy-cabinet-content" id="trophy-cabinet-content">
                                <div class="loading-message">Loading trophy cabinet...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="player-stats">
            <div class="container">
                <div class="stats-grid">
                    <div class="stats-section">
                        <h3 class="section-title">
                            <span class="title-icon">üìä</span>
                            Performance
                        </h3>
                        <div class="meta-grid" id="performance-stats">
                            <div class="loading-message">Loading performance metrics...</div>
                        </div>
                    </div>

                    <div class="stats-section">
                        <h3 class="section-title">
                            <span class="title-icon">ü§ù</span>
                            Partnerships
                        </h3>
                        <div class="meta-grid" id="partnership-stats">
                            <div class="loading-message">Loading partnership statistics...</div>
                        </div>
                        <a class="partnership-cta" id="see-all-partnerships" href="#">
                            See all partnerships
                        </a>
                    </div>

                    <div class="stats-section">
                        <h3 class="section-title">
                            <span class="title-icon">üÉè</span>
                            Trump Suit Performance
                        </h3>
                        <div class="meta-grid" id="trump-stats">
                            <div class="loading-message">Loading trump suit statistics...</div>
                        </div>
                    </div>

                    <div class="stats-section full-width">
                        <h3 class="section-title">
                            <span class="title-icon">üìâ</span>
                            Seed Rank History
                        </h3>
                        <div class="meta-grid seed-rank-meta" id="seed-rank-meta">
                            <div class="loading-message">Loading seed metrics...</div>
                        </div>
                        <div class="chart-container" id="seed-rank-chart">
                            <div class="loading-message">Loading seed rank history...</div>
                        </div>
                    </div>

                    <div class="stats-section full-width">
                        <h3 class="section-title">
                            <span class="title-icon">üèÜ</span>
                            Tournament History
                        </h3>
                        <div class="tournament-timeline" id="tournament-timeline">
                            <div class="loading-message">Loading tournament history...</div>
                        </div>
                        <div class="timeline-controls">
                            <div class="timeline-meta" id="tournament-timeline-meta"></div>
                            <button type="button" class="timeline-toggle-btn" id="toggle-tournament-history" style="display:none;"></button>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div data-footer-nav></div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2024 Ruston Family Whist Drive. Player profiles and statistics.</p>
            </div>
        </div>
    </footer>

    <!-- Avatar lightbox -->
    <div id="avatar-modal" class="avatar-modal" style="display:none;">
        <div class="avatar-modal__content" role="dialog" aria-modal="true" aria-label="Avatar">
            <button type="button" class="avatar-modal__close btn btn-secondary" id="avatar-modal-close">Close</button>
            <img id="avatar-modal-img" alt="Avatar" />
        </div>
    </div>

    <style>
        .trump-stats-list {
            background: white;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-lg);
            border: 2px solid var(--border-light);
            margin-top: var(--spacing-lg);
        }

        .trump-title {
            text-align: center;
            font-weight: 700;
            font-size: 1rem;
            color: #2d3748;
            margin-bottom: var(--spacing-md);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .trump-suit-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-md) 0;
        }

        .trump-suit-icon {
            font-size: 1.5rem;
            min-width: 1.5rem;
        }

        .trump-suit-name {
            font-weight: 600;
            color: #2d3748;
            flex: 1;
            margin-left: var(--spacing-sm);
        }

        .trump-average {
            font-weight: 700;
            color: #2d3748;
            text-align: center;
            min-width: 50px;
        }

        .trump-divider {
            height: 1px;
            background: linear-gradient(90deg, transparent 0%, var(--border-light) 20%, var(--border-light) 80%, transparent 100%);
            margin: 0 var(--spacing-sm);
        }

        .heart { color: #e53e3e; }
        .diamond { color: #e53e3e; }
        .club { color: #1a202c; }
        .spade { color: #1a202c; }

        @media (max-width: 768px) {
            .trump-stats-list {
                padding: var(--spacing-md);
            }
            
            .trump-title {
                font-size: 0.9rem;
                margin-bottom: var(--spacing-sm);
            }
            
            .trump-suit-row {
                padding: var(--spacing-sm) 0;
            }
            
            .trump-suit-icon {
                font-size: 1.25rem;
                min-width: 1.25rem;
            }
            
            .trump-suit-name {
                font-size: 0.9rem;
            }
            
            .trump-average {
                font-size: 0.9rem;
                min-width: 45px;
            }
        }
    </style>

            <script src="../assets/js/tournament-engine.js"></script>
    <script src="../assets/js/charts.js?v=24"></script>
    
    <script>
        // Get player name from URL parameter
        function getPlayerFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('player');
        }

        function hydrateAvatarUploadLink(engine, playerNameOrKey) {
            const el = document.getElementById('upload-avatar-link');
            if (!el) return;
            const key = (engine && typeof engine.getCanonicalPlayerId === 'function')
                ? engine.getCanonicalPlayerId(playerNameOrKey)
                : String(playerNameOrKey || '').trim();
            if (!key) return;
            el.href = `../upload/avatar.html?playerId=${encodeURIComponent(key)}`;
            el.style.display = 'inline-flex';
        }

        async function hydrateProfileAvatar(engine, playerNameOrKey) {
            try {
                const imgEl = document.getElementById('player-avatar-img');
                const placeholder = document.querySelector('.player-avatar .avatar-placeholder');
                if (!imgEl || !placeholder) return;
                if (!(window.WhistMedia && typeof window.WhistMedia.avatarUrl === 'function')) return;

                const key = (engine && typeof engine.getCanonicalPlayerId === 'function')
                    ? engine.getCanonicalPlayerId(playerNameOrKey)
                    : String(playerNameOrKey || '').trim();
                if (!key) return;

                const url = await window.WhistMedia.avatarUrl(key, 'large');
                if (!url) return;

                const ok = await new Promise((resolve) => {
                    const probe = new Image();
                    probe.onload = () => resolve(true);
                    probe.onerror = () => resolve(false);
                    probe.src = `${url}${url.includes('?') ? '&' : '?'}probe=${Date.now()}`;
                });
                if (!ok) return;

                imgEl.src = url;
                imgEl.style.display = 'block';
                placeholder.style.opacity = '0';
                placeholder.style.pointerEvents = 'none';
            } catch (_) {
                // ignore
            }
        }

        function wireAvatarOverlay() {
            const frame = document.getElementById('player-avatar-frame');
            const imgEl = document.getElementById('player-avatar-img');
            const modal = document.getElementById('avatar-modal');
            const modalImg = document.getElementById('avatar-modal-img');
            const modalClose = document.getElementById('avatar-modal-close');
            if (!frame || !imgEl || !modal || !modalImg || !modalClose) return;

            const open = () => {
                const src = imgEl.getAttribute('src') || '';
                if (!src) return;
                modalImg.setAttribute('src', src);
                modal.style.display = 'flex';
                document.body.style.overflow = 'hidden';
            };
            const close = () => {
                modal.style.display = 'none';
                modalImg.removeAttribute('src');
                document.body.style.overflow = '';
            };

            frame.addEventListener('click', open);
            frame.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    open();
                }
            });
            modalClose.addEventListener('click', close);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) close();
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') close();
            });
        }

        // Load player profile data
        document.addEventListener('DOMContentLoaded', async function() {
            const playerName = getPlayerFromURL();
            
            if (!playerName) {
                // Redirect to players index if no player specified
                window.location.href = './';
                return;
            }

            console.log(`üë§ Loading profile for: ${playerName}`);

            const tournamentEngine = new TournamentEngine();
            window.tournamentEngine = tournamentEngine; // Make it globally accessible
            const sheetId = '1HGfdlDOfGHOL6Q4MP_TnF8UNE6YihBW-5gQs6Ykl78k';
            
            try {
                await tournamentEngine.loadFromGoogleSheets(sheetId);
                
                const players = tournamentEngine.getAllPlayers('total_tricks');
                const tournaments = Array.from(tournamentEngine.tournaments.values());

                // Precompute global min/max avg tricks per round (for barometer scaling)
                window.__globalAvgTricksRange = computeGlobalAvgTricksRange(tournamentEngine, tournaments);
                
                // Find the player (either someone who has competed, or a roster-only player)
                let player = players.find(p => String(p?.name || '').toLowerCase() === String(playerName || '').toLowerCase());

                // If not found in tournament-derived stats, fall back to Players-sheet roster entry
                if (!player && typeof tournamentEngine.getPlayersRoster === 'function') {
                    const roster = tournamentEngine.getPlayersRoster() || [];
                    const rosterEntry = roster.find(r => String(r?.id || '').toLowerCase() === String(playerName || '').toLowerCase()) || null;
                    if (rosterEntry && rosterEntry.id) {
                        player = {
                            name: rosterEntry.id,
                            tournaments_played: 0,
                            total_tricks: 0,
                            total_rounds: 0,
                            average_tricks: '0.00',
                            tournament_wins: 0,
                            top_three_finishes: 0,
                            tournament_history: []
                        };
                    }
                }

                if (!player) {
                    console.error(`‚ùå Player "${playerName}" not found`);
                    document.getElementById('player-name').textContent = 'Player Not Found';
                    document.getElementById('player-title').textContent = 'This player could not be found in our records.';
                    return;
                }

                // Get full name for profile display
                const fullName = tournamentEngine.getPlayerFullName(player.name);
                
                // Family tree deep link (highlight/focus this player)
                const familyTreeBtn = document.getElementById('family-tree-btn');
                if (familyTreeBtn) {
                    familyTreeBtn.href = `../families/?player=${encodeURIComponent(player.name)}`;
                    familyTreeBtn.setAttribute('aria-label', `View ${fullName} in Family Tree`);
                    familyTreeBtn.title = `View ${fullName} in Family Tree`;
                }

                // Memorial link for deceased players
                const memorialWrap = document.getElementById('memorial-link');
                const memorialA = document.getElementById('memorial-link-a');
                const memorialYear = document.getElementById('memorial-year');
                if (memorialWrap && memorialA && memorialYear && typeof tournamentEngine.getPlayerDeathInfo === 'function') {
                    const death = tournamentEngine.getPlayerDeathInfo(player.name);
                    if (death && death.raw) {
                        memorialWrap.style.display = 'block';
                        memorialA.href = `../memorial/?player=${encodeURIComponent(player.name)}`;
                        const yearLabel = death && death.year ? String(death.year) : (death.isYearOnly ? death.raw : death.raw);
                        memorialYear.textContent = yearLabel;
                        memorialA.setAttribute('aria-label', `View memorial page for ${fullName}`);
                        memorialA.title = `View memorial page`;
                    }
                }
                
                // Update page title and meta
                document.title = `${fullName} - Player Profile | Ruston Family Whist Drive`;
                
                // Update player information - use full name for profile display
                document.getElementById('player-name').textContent = fullName;
                document.getElementById('player-initial').textContent = player.name.split(' ').map(n => n[0]).join('');

                // Avatar: try to load from R2 (avatars/{Key}.jpg). Fallback keeps the placeholder.
                hydrateProfileAvatar(tournamentEngine, player.name);
                hydrateAvatarUploadLink(tournamentEngine, player.name);
                wireAvatarOverlay();
                
                // Get player statistics - include tournaments where player appears individually OR in shared hands
                const playerTournaments = tournaments.filter(t => {
                    // Check if player appears individually in final standings
                    const appearsIndividually = t.final_standings.some(s => s.player === player.name);
                    
                    // Check if player appears in any shared hand partnerships
                    const appearsInSharedHands = t.final_standings.some(s => 
                        s.is_partnership && 
                        s.partnership_players && 
                        s.partnership_players.some(p => p === player.name)
                    );
                    
                    return appearsIndividually || appearsInSharedHands;
                });
                
                const championships = tournaments.filter(t => t.winner === player.name).length;
                const topThreeFinishes = tournaments.filter(t => {
                    // Check individual ranking first
                    const individualRanking = t.final_standings.findIndex(s => s.player === player.name) + 1;
                    if (individualRanking <= 3 && individualRanking > 0) {
                        return true;
                    }
                    
                    // Check if player was in a shared hand partnership that finished in top 3
                    const sharedHandRanking = t.final_standings.findIndex(s => 
                        s.is_partnership && 
                        s.partnership_players && 
                        s.partnership_players.some(p => p === player.name)
                    ) + 1;
                    
                    return sharedHandRanking <= 3 && sharedHandRanking > 0;
                }).length;
                
                const hasCompeted = playerTournaments.length > 0;

                if (!hasCompeted) {
                    // Roster-only player: render a profile shell that makes it clear they haven't competed yet.
                    document.getElementById('player-icon').textContent = 'üìù';
                    document.getElementById('player-title').textContent = 'On the roster ‚Ä¢ Yet to compete';

                    document.getElementById('first-tournament').textContent = '‚Äî';
                    document.getElementById('years-active').textContent = '‚Äî';
                    document.getElementById('total-tournaments').textContent = '0';
                    document.getElementById('current-ranking').textContent = '‚Äî';

                    document.getElementById('tournament-victories').textContent = '0';
                    document.getElementById('total-tricks').textContent = '0';
                    document.getElementById('avg-tricks').textContent = '‚Äî';
                    document.getElementById('top-finishes').textContent = '0';

                    const msg = `<div class="loading-message">This player is listed on the Players sheet, but has not yet competed in a tournament.</div>`;
                    const setHtml = (id) => {
                        const el = document.getElementById(id);
                        if (el) el.innerHTML = msg;
                    };
                    setHtml('trophy-cabinet-content');
                    setHtml('performance-stats');
                    setHtml('partnership-stats');
                    setHtml('trump-stats');
                    setHtml('seed-rank-meta');
                    setHtml('seed-rank-chart');
                    setHtml('tournament-timeline');

                    const seeAll = document.getElementById('see-all-partnerships');
                    if (seeAll) seeAll.style.display = 'none';

                    console.log('‚ÑπÔ∏è Roster-only player profile rendered (no tournament history yet).');
                    return;
                }

                const firstYear = Math.min(...playerTournaments.map(t => t.year));
                const lastYear = Math.max(...playerTournaments.map(t => t.year));
                const yearsActive = lastYear - firstYear + 1;
                
                const avgTricks = player.total_rounds > 0 ? 
                    (player.total_tricks / player.total_rounds).toFixed(2) : '0.00';
                
                // Update champion status
                if (championships > 0) {
                    document.getElementById('champion-badge').style.display = 'block';
                    document.getElementById('champion-badge').textContent = 
                        championships === 1 ? 'Champion' : `${championships}x Champion`;
                    document.getElementById('player-icon').textContent = 'üëë';
                    document.getElementById('player-title').textContent = 
                        championships === 1 ? 'Tournament Champion' : `${championships}-Time Champion`;
                } else if (topThreeFinishes > 0) {
                    document.getElementById('player-icon').textContent = 'üèÜ';
                    document.getElementById('player-title').textContent = 'Championship Contender';
                } else {
                    document.getElementById('player-icon').textContent = 'üéØ';
                    document.getElementById('player-title').textContent = 'Tournament Player';
                }
                
                // Update meta information
                document.getElementById('first-tournament').textContent = firstYear;
                document.getElementById('years-active').textContent = `${yearsActive} year${yearsActive !== 1 ? 's' : ''}`;
                document.getElementById('total-tournaments').textContent = player.tournaments_played;
                
                // Update career highlights
                const performanceStats = tournamentEngine.getPlayerPerformanceStats(player.name) || {};
                const seedRankText = performanceStats.seed_rank ? `#${performanceStats.seed_rank}` : 'Unranked';
                document.getElementById('current-ranking').textContent = seedRankText;
                
                document.getElementById('tournament-victories').textContent = championships;
                const totalTricksNum = Number.isFinite(player.total_tricks)
                    ? player.total_tricks
                    : parseFloat(player.total_tricks);
                const totalTricksText = Number.isFinite(totalTricksNum)
                    ? Math.floor(totalTricksNum).toLocaleString()
                    : '0';
                document.getElementById('total-tricks').textContent = totalTricksText;
                document.getElementById('avg-tricks').textContent = avgTricks;
                document.getElementById('top-finishes').textContent = topThreeFinishes;
                
                updatePerformanceStats(player.name, performanceStats);
                renderSeedRankMeta(player.name, performanceStats);
                renderPartnershipStats(player.name);
                generateTrumpSuitStats(player.name);
                generateTrophyCabinet(player.name, playerTournaments);
                renderSeedRankHistoryChart(player.name);
                
                // Generate tournament timeline
                generateTournamentTimeline(player, playerTournaments);
                
                // Rank progression chart removed as requested
                
                console.log('‚úÖ Player profile loaded successfully!');
                
            } catch (error) {
                console.error('‚ùå Error loading player profile:', error);
                document.getElementById('player-name').textContent = 'Error Loading Player';
                document.getElementById('player-title').textContent = 'There was an error loading this player profile.';
            }
        });

        function updatePerformanceStats(playerName, performanceStats) {
            const performanceContainer = document.getElementById('performance-stats');
            if (!performanceContainer) return;
            const engine = window.tournamentEngine;
            
            const topPercentile = typeof performanceStats.top_percentile === 'number' ? `${performanceStats.top_percentile.toFixed(1)}%` : '‚Äî';
            const topThreeRate = `${(performanceStats.top_three_rate ?? 0).toFixed(1)}%`;

            // Overall win rate: % of games with tricks >= 7 (includes shared hands).
            let wins = 0;
            let played = 0;
            const playerLower = String(playerName || '').toLowerCase();
            if (engine && engine.tournaments) {
                for (const t of engine.tournaments.values()) {
                    if (!t || !Array.isArray(t.rounds)) continue;
                    for (const r of t.rounds) {
                        if (!r || !Array.isArray(r.tables)) continue;
                        for (const table of r.tables) {
                            const partnerships = table && Array.isArray(table.partnerships) ? table.partnerships : [];
                            for (const p of partnerships) {
                                if (!p || !Array.isArray(p.position1) || !Array.isArray(p.position2)) continue;
                                const sidePlayers = Array.from(new Set([...(p.position1 || []), ...(p.position2 || [])]))
                                    .filter(Boolean);
                                const hasPlayer = sidePlayers.some(x => String(x || '').toLowerCase() === playerLower);
                                if (!hasPlayer) continue;

                                const tricks = Number.isFinite(p.tricks) ? p.tricks : parseFloat(p.tricks);
                                if (!Number.isFinite(tricks)) continue;
                                played += 1;
                                if (tricks >= 7) wins += 1;
                            }
                        }
                    }
                }
            }
            const winRateText = played > 0 ? `${Math.round((wins / played) * 100)}%` : '‚Äî';

            // Win streaks: consecutive round wins where tricks >= 7 (includes shared hands). Streak carries across tournaments.
            let longestWinStreak = '‚Äî';
            let currentWinStreak = '‚Äî';
            try {
                if (engine && typeof engine.getPlayerMajorityWinStreakStats === 'function') {
                    const stats = engine.getPlayerMajorityWinStreakStats(7, { includeZeroes: true }) || [];
                    const rec = stats.find(s => String(s?.playerId || '').toLowerCase() === playerLower) || null;
                    if (rec) {
                        longestWinStreak = Number.isFinite(rec.longest) ? String(rec.longest) : String(rec.longest ?? '‚Äî');
                        currentWinStreak = Number.isFinite(rec.current) ? String(rec.current) : String(rec.current ?? '‚Äî');
                    } else if (played > 0) {
                        // Player played rounds but has no recorded wins at the 7+ threshold.
                        longestWinStreak = '0';
                        currentWinStreak = '0';
                    }
                }
            } catch (error) {
                console.warn('Error computing win streak stats:', error);
            }

            // Booby prizes (üé≠): count last-place finishes (includes shared hands).
            let boobyCount = 0;
            if (engine && engine.tournaments) {
                for (const t of engine.tournaments.values()) {
                    if (!t || !Array.isArray(t.final_standings) || !t.final_standings.length) continue;
                    const totalPlayers = t.final_standings.length;
                    let idx = t.final_standings.findIndex(s => s && s.player === playerName);
                    if (idx === -1) {
                        idx = t.final_standings.findIndex(s =>
                            s &&
                            s.is_partnership &&
                            Array.isArray(s.partnership_players) &&
                            s.partnership_players.some(p => p === playerName)
                        );
                    }
                    if (idx !== -1 && (idx + 1) === totalPlayers) {
                        boobyCount += 1;
                    }
                }
            }
            
            performanceContainer.innerHTML = `
                <div class="meta-item">
                    <span class="meta-label">Avg Finish Position, Top:</span>
                    <span class="meta-value">${topPercentile}</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Top 3 Rate</span>
                    <span class="meta-value">${topThreeRate}</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Booby prizes (üé≠)</span>
                    <span class="meta-value">${escapeHtml(String(boobyCount))}</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Win rate</span>
                    <span class="meta-value">
                        ${winRateText}
                        <span class="meta-subvalue">${played > 0 ? `(${wins}/${played})` : ''}</span>
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Longest win streak (7+)</span>
                    <span class="meta-value">${escapeHtml(longestWinStreak)}</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Current win streak (7+)</span>
                    <span class="meta-value">${escapeHtml(currentWinStreak)}</span>
                </div>
            `;
        }

        function escapeHtml(str) {
            return String(str ?? '')
                .replaceAll('&', '&amp;')
                .replaceAll('<', '&lt;')
                .replaceAll('>', '&gt;')
                .replaceAll('"', '&quot;')
                .replaceAll("'", '&#39;');
        }

        function renderPartnershipStats(playerId) {
            const engine = window.tournamentEngine;
            const statsEl = document.getElementById('partnership-stats');
            if (!statsEl) return;

            if (!engine || !engine.tournaments) {
                statsEl.innerHTML = `<div class="muted">Partnership stats unavailable.</div>`;
                return;
            }

            const byPartner = new Map(); // partnerId -> { gamesTogether, tricksTogether, timesPaired, tricksPaired, winsPaired, pairedGames }
            const add = (partnerId, tricks, isNormalPairing, isWin, meta) => {
                if (!partnerId) return;
                if (!byPartner.has(partnerId)) {
                    byPartner.set(partnerId, {
                        partnerId,
                        gamesTogether: 0,
                        tricksTogether: 0,
                        timesPaired: 0, // non-shared only
                        tricksPaired: 0, // non-shared only
                        winsPaired: 0, // non-shared only
                        pairedGames: [] // non-shared only: {year, round, table, isWin}
                    });
                }
                const rec = byPartner.get(partnerId);
                rec.gamesTogether += 1;
                rec.tricksTogether += tricks;
                if (isNormalPairing) {
                    rec.timesPaired += 1;
                    rec.tricksPaired += tricks;
                    if (isWin) rec.winsPaired += 1;
                    if (meta && Number.isFinite(meta.year)) {
                        rec.pairedGames.push({
                            year: meta.year,
                            round: Number.isFinite(meta.round) ? meta.round : 0,
                            table: Number.isFinite(meta.table) ? meta.table : 0,
                            isWin: !!isWin
                        });
                    }
                }
            };

            for (const t of engine.tournaments.values()) {
                if (!t || !Array.isArray(t.rounds)) continue;
                const year = Number.isFinite(t.year)
                    ? t.year
                    : (Number.isFinite(t.Year) ? t.Year : parseInt(t.year || t.Year || '0'));
                for (const r of t.rounds) {
                    if (!r || !Array.isArray(r.tables)) continue;
                    const roundNum = Number.isFinite(r.round)
                        ? r.round
                        : (Number.isFinite(r.Round) ? r.Round : parseInt(r.round || r.Round || '0'));
                    for (const table of r.tables) {
                        const tableNum = Number.isFinite(table.table)
                            ? table.table
                            : parseInt(table.table || table.Table || '0');
                        const partnerships = table && Array.isArray(table.partnerships) ? table.partnerships : [];
                        for (const p of partnerships) {
                            if (!p || !Array.isArray(p.position1) || !Array.isArray(p.position2)) continue;
                            const sidePlayers = Array.from(new Set([...(p.position1 || []), ...(p.position2 || [])])).filter(Boolean);
                            if (!sidePlayers.includes(playerId)) continue;
                            const tricks = Number.isFinite(p.tricks) ? p.tricks : parseFloat(p.tricks);
                            if (!Number.isFinite(tricks)) continue;
                            const isNormalPairing = (p.position1.length === 1 && p.position2.length === 1 && sidePlayers.length === 2);
                            const isWin = tricks >= 7;
                            sidePlayers.forEach(otherId => {
                                if (otherId === playerId) return;
                                add(otherId, tricks, isNormalPairing, isWin, { year, round: roundNum, table: tableNum });
                            });
                        }
                    }
                }
            }

            const partners = Array.from(byPartner.values()).map(rec => {
                const avgTogether = rec.gamesTogether > 0 ? (rec.tricksTogether / rec.gamesTogether) : 0;
                const avgPaired = rec.timesPaired > 0 ? (rec.tricksPaired / rec.timesPaired) : null;
                const winPct = rec.timesPaired > 0 ? (rec.winsPaired / rec.timesPaired) : null;
                const sortedGames = (rec.pairedGames || []).slice().sort((a, b) =>
                    (a.year - b.year) || (a.round - b.round) || (a.table - b.table)
                );
                let streak = 0;
                let bestStreak = 0;
                let loseStreak = 0;
                let bestLoseStreak = 0;
                for (const g of sortedGames) {
                    if (g.isWin) {
                        streak += 1;
                        if (streak > bestStreak) bestStreak = streak;
                        loseStreak = 0;
                    } else {
                        streak = 0;
                        loseStreak += 1;
                        if (loseStreak > bestLoseStreak) bestLoseStreak = loseStreak;
                    }
                }

                // Current (active) streak is based on the most recent non-shared games only.
                let currentWinStreak = 0;
                let currentLoseStreak = 0;
                if (sortedGames.length) {
                    const lastIsWin = !!sortedGames[sortedGames.length - 1].isWin;
                    for (let i = sortedGames.length - 1; i >= 0; i--) {
                        const isWin = !!sortedGames[i].isWin;
                        if (isWin === lastIsWin) {
                            if (lastIsWin) currentWinStreak += 1;
                            else currentLoseStreak += 1;
                        } else {
                            break;
                        }
                    }
                }
                return {
                    partnerId: rec.partnerId,
                    gamesTogether: rec.gamesTogether,
                    avgTogether,
                    timesPaired: rec.timesPaired,
                    avgPaired,
                    winsPaired: rec.winsPaired,
                    winPct,
                    longestWinStreak: bestStreak,
                    longestLoseStreak: bestLoseStreak,
                    currentWinStreak,
                    currentLoseStreak
                };
            });

            if (!partners.length) {
                statsEl.innerHTML = `<div class="muted">No partnership data found yet.</div>`;
                return;
            }

            const MIN_FOR_RECORDS = 4;
            const distinctPartners = partners.length;

            const displayName = (id) => (engine && typeof engine.getDisplayName === 'function') ? engine.getDisplayName(id) : id;
            const partnerGamesLink = (id) => `partnership-games?player=${encodeURIComponent(playerId)}&partner=${encodeURIComponent(id)}`;

            const mostFreq = (() => {
                const paired = partners.filter(p => (p.timesPaired || 0) > 0);
                const pool = paired.length ? paired : partners.slice();
                return pool.reduce((best, cur) => {
                    const bestN = paired.length ? (best.timesPaired || 0) : (best.gamesTogether || 0);
                    const curN = paired.length ? (cur.timesPaired || 0) : (cur.gamesTogether || 0);
                    return curN > bestN ? cur : best;
                }, pool[0]);
            })();

            const bestWorstPool = (() => {
                const eligible = partners.filter(p => (p.timesPaired || 0) >= MIN_FOR_RECORDS && Number.isFinite(p.avgPaired));
                const any = partners.filter(p => (p.timesPaired || 0) > 0 && Number.isFinite(p.avgPaired));
                return eligible.length ? eligible : any;
            })();

            const bestAvg = bestWorstPool.length
                ? bestWorstPool.slice().sort((a, b) => (b.avgPaired - a.avgPaired) || (b.timesPaired - a.timesPaired))[0]
                : null;

            const worstAvg = bestWorstPool.length
                ? bestWorstPool.slice().sort((a, b) => (a.avgPaired - b.avgPaired) || (b.timesPaired - a.timesPaired))[0]
                : null;

            const winPool = partners.filter(p => (p.timesPaired || 0) >= MIN_FOR_RECORDS && Number.isFinite(p.winPct));
            const highestWin = winPool.length
                ? winPool.slice().sort((a, b) => (b.winPct - a.winPct) || (b.timesPaired - a.timesPaired))[0]
                : null;
            const lowestWin = winPool.length
                ? winPool.slice().sort((a, b) => (a.winPct - b.winPct) || (b.timesPaired - a.timesPaired))[0]
                : null;

            const winStreakPool = partners.filter(p => (p.timesPaired || 0) >= MIN_FOR_RECORDS && (p.longestWinStreak || 0) > 0);
            const bestWinStreak = winStreakPool.length
                ? winStreakPool.slice().sort((a, b) => (b.longestWinStreak - a.longestWinStreak) || (b.timesPaired - a.timesPaired))[0]
                : null;

            const loseStreakPool = partners.filter(p => (p.timesPaired || 0) >= MIN_FOR_RECORDS && (p.longestLoseStreak || 0) > 0);
            const bestLoseStreak = loseStreakPool.length
                ? loseStreakPool.slice().sort((a, b) => (b.longestLoseStreak - a.longestLoseStreak) || (b.timesPaired - a.timesPaired))[0]
                : null;

            const isDeceased = (id) => (engine && typeof engine.isPlayerDeceased === 'function') ? engine.isPlayerDeceased(id) : false;
            const selfDeceased = isDeceased(playerId);

            const currentWinPool = partners.filter(p =>
                !selfDeceased &&
                !isDeceased(p.partnerId) &&
                (p.timesPaired || 0) >= MIN_FOR_RECORDS &&
                (p.currentWinStreak || 0) > 0
            );
            const currentWinMax = currentWinPool.length ? Math.max(...currentWinPool.map(p => p.currentWinStreak || 0)) : 0;
            const currentWinLeaders = currentWinMax > 0
                ? currentWinPool.filter(p => (p.currentWinStreak || 0) === currentWinMax)
                : [];

            const currentLosePool = partners.filter(p =>
                !selfDeceased &&
                !isDeceased(p.partnerId) &&
                (p.timesPaired || 0) >= MIN_FOR_RECORDS &&
                (p.currentLoseStreak || 0) > 0
            );
            const currentLoseMax = currentLosePool.length ? Math.max(...currentLosePool.map(p => p.currentLoseStreak || 0)) : 0;
            const currentLoseLeaders = currentLoseMax > 0
                ? currentLosePool.filter(p => (p.currentLoseStreak || 0) === currentLoseMax)
                : [];

            const renderTiedPartners = (list) => {
                if (!list || !list.length) return '‚Äî';
                return list.map(p => `<a class="inline-link" href="${partnerGamesLink(p.partnerId)}">${escapeHtml(displayName(p.partnerId))}</a>`).join(', ');
            };

            statsEl.innerHTML = `
                <div class="meta-item">
                    <span class="meta-label">Distinct partners</span>
                    <span class="meta-value">${distinctPartners}</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Most frequent partner</span>
                    <span class="meta-value">
                        <a class="inline-link" href="${partnerGamesLink(mostFreq.partnerId)}">${escapeHtml(displayName(mostFreq.partnerId))}</a>
                        <span class="meta-subvalue">(${(mostFreq.timesPaired || 0) > 0 ? `${mostFreq.timesPaired} non-shared` : `${mostFreq.gamesTogether} games`})</span>
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Best partnership</span>
                    <span class="meta-value">
                        ${bestAvg ? `
                            <a class="inline-link" href="${partnerGamesLink(bestAvg.partnerId)}">${escapeHtml(displayName(bestAvg.partnerId))}</a>
                            <span class="meta-subvalue">(${bestAvg.avgPaired.toFixed(2)} avg/round ‚Ä¢ ${bestAvg.timesPaired} games)</span>
                        ` : `
                            ‚Äî
                            <span class="meta-subvalue">(need non-shared games)</span>
                        `}
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Worst partnership</span>
                    <span class="meta-value">
                        ${worstAvg ? `
                            <a class="inline-link" href="${partnerGamesLink(worstAvg.partnerId)}">${escapeHtml(displayName(worstAvg.partnerId))}</a>
                            <span class="meta-subvalue">(${worstAvg.avgPaired.toFixed(2)} avg/round ‚Ä¢ ${worstAvg.timesPaired} games)</span>
                        ` : `
                            ‚Äî
                            <span class="meta-subvalue">(need non-shared games)</span>
                        `}
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Longest win streak</span>
                    <span class="meta-value">
                        ${bestWinStreak ? `
                            <a class="inline-link" href="${partnerGamesLink(bestWinStreak.partnerId)}">${escapeHtml(displayName(bestWinStreak.partnerId))}</a>
                            <span class="meta-subvalue">(${bestWinStreak.longestWinStreak} wins)</span>
                        ` : `
                            ‚Äî
                            <span class="meta-subvalue">(need 4+ non-shared games)</span>
                        `}
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Longest losing streak</span>
                    <span class="meta-value">
                        ${bestLoseStreak ? `
                            <a class="inline-link" href="${partnerGamesLink(bestLoseStreak.partnerId)}">${escapeHtml(displayName(bestLoseStreak.partnerId))}</a>
                            <span class="meta-subvalue">(${bestLoseStreak.longestLoseStreak} losses)</span>
                        ` : `
                            ‚Äî
                            <span class="meta-subvalue">(need 4+ non-shared games)</span>
                        `}
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Highest win record</span>
                    <span class="meta-value">
                        ${highestWin ? `
                            <a class="inline-link" href="${partnerGamesLink(highestWin.partnerId)}">${escapeHtml(displayName(highestWin.partnerId))}</a>
                            <span class="meta-subvalue">(${Math.round(highestWin.winPct * 100)}% ‚Ä¢ ${highestWin.winsPaired}/${highestWin.timesPaired})</span>
                        ` : `
                            ‚Äî
                            <span class="meta-subvalue">(need 4+ non-shared games)</span>
                        `}
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Lowest win record</span>
                    <span class="meta-value">
                        ${lowestWin ? `
                            <a class="inline-link" href="${partnerGamesLink(lowestWin.partnerId)}">${escapeHtml(displayName(lowestWin.partnerId))}</a>
                            <span class="meta-subvalue">(${Math.round(lowestWin.winPct * 100)}% ‚Ä¢ ${lowestWin.winsPaired}/${lowestWin.timesPaired})</span>
                        ` : `
                            ‚Äî
                            <span class="meta-subvalue">(need 4+ non-shared games)</span>
                        `}
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Current longest win streak</span>
                    <span class="meta-value">
                        ${currentWinLeaders.length ? `
                            ${renderTiedPartners(currentWinLeaders)}
                            <span class="meta-subvalue">(${currentWinMax} wins${bestWinStreak ? ` ‚Ä¢ record ${bestWinStreak.longestWinStreak}` : ''})</span>
                        ` : `
                            ‚Äî
                            <span class="meta-subvalue">${selfDeceased ? 'N/A' : '(need 4+ non-shared games, living partners)'}</span>
                        `}
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Current longest losing streak</span>
                    <span class="meta-value">
                        ${currentLoseLeaders.length ? `
                            ${renderTiedPartners(currentLoseLeaders)}
                            <span class="meta-subvalue">(${currentLoseMax} losses${bestLoseStreak ? ` ‚Ä¢ record ${bestLoseStreak.longestLoseStreak}` : ''})</span>
                        ` : `
                            ‚Äî
                            <span class="meta-subvalue">${selfDeceased ? 'N/A' : '(need 4+ non-shared games, living partners)'}</span>
                        `}
                    </span>
                </div>
            `;

            const cta = document.getElementById('see-all-partnerships');
            if (cta) {
                cta.href = `partnerships.html?player=${encodeURIComponent(playerId)}`;
            }
        }

        function renderSeedRankMeta(playerName, performanceStats) {
            const container = document.getElementById('seed-rank-meta');
            if (!container) return;
            const engine = window.tournamentEngine;

            const seedRank = performanceStats && performanceStats.seed_rank ? `#${performanceStats.seed_rank}` : 'Unranked';
            const seedPointsNum = performanceStats && Number.isFinite(performanceStats.seed_points)
                ? performanceStats.seed_points
                : (performanceStats && performanceStats.seed_points ? parseFloat(performanceStats.seed_points) : NaN);
            const seedPointsText = Number.isFinite(seedPointsNum) ? `${seedPointsNum} pts` : null;

            let peakRank = null; // best (lowest) seed_rank
            let peakRankYear = null; // last year best rank achieved
            let peakPoints = null;
            let peakPointsYear = null;
            if (engine && typeof engine.getSeedRankHistory === 'function' && playerName) {
                const history = (engine.getSeedRankHistory(playerName, true) || [])
                    .filter(h => h && Number.isFinite(h.year));
                history.forEach(entry => {
                    const r = Number.isFinite(entry.seed_rank) ? entry.seed_rank : parseFloat(entry.seed_rank);
                    if (Number.isFinite(r)) {
                        if (peakRank === null || r < peakRank || (r === peakRank && entry.year > peakRankYear)) {
                            peakRank = r;
                            peakRankYear = entry.year;
                        }
                    }
                    const pts = Number.isFinite(entry.seed_points) ? entry.seed_points : parseFloat(entry.seed_points);
                    if (!Number.isFinite(pts)) return;
                    if (peakPoints === null || pts > peakPoints || (pts === peakPoints && entry.year > peakPointsYear)) {
                        peakPoints = pts;
                        peakPointsYear = entry.year;
                    }
                });
            }

            const currentText = seedPointsText ? `${seedRank} (${seedPointsText})` : `${seedRank}`;
            const peakRankText = peakRank === null ? '‚Äî' : `#${peakRank}`;
            const peakPointsText = peakPoints === null ? '‚Äî' : `${peakPoints} pts`;

            container.innerHTML = `
                <div class="meta-item">
                    <span class="meta-label">Current Seed Rank</span>
                    <span class="meta-value">
                        ${currentText}
                        <span class="meta-subvalue">
                            <a href="../leaderboard/?tab=overall#seed-points-explained">How are seed points calculated?</a>
                        </span>
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Peak Seed Rank</span>
                    <span class="meta-value">${peakRankText}${peakRankYear ? ` <span class="meta-subvalue">(${peakRankYear})</span>` : ''}</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Peak Seed Points</span>
                    <span class="meta-value">${peakPointsText}${peakPointsYear ? ` <span class="meta-subvalue">(${peakPointsYear})</span>` : ''}</span>
                </div>
            `;
        }

        function renderSeedRankHistoryChart(playerName) {
            const container = document.getElementById('seed-rank-chart');
            const engine = window.tournamentEngine;
            if (!container) return;
            if (!engine || typeof engine.getSeedRankHistory !== 'function') {
                container.innerHTML = '<p class="muted">Seed rank history unavailable.</p>';
                return;
            }

            const history = (engine.getSeedRankHistory(playerName, true) || [])
                .filter(h => h && typeof h.seed_rank === 'number' && Number.isFinite(h.year))
                .slice()
                .sort((a, b) => a.year - b.year);
            if (!history.length) {
                container.innerHTML = '<p class="muted">No seed rank history yet.</p>';
                return;
            }

            const years = history.map(h => h.year);
            const ranks = history.map(h => h.seed_rank);
            const minYear = Math.min(...years);
            const maxYear = Math.max(...years);
            const maxRank = Math.max(...ranks);

            const width = 980;
            const height = 320;
            const padLeft = 70;
            const padRight = 26;
            const padTop = 18;
            const padBottom = 92;

            const xForYear = (y) => {
                if (maxYear === minYear) return padLeft;
                return padLeft + ((y - minYear) / (maxYear - minYear)) * (width - padLeft - padRight);
            };
            const yForRank = (r) => {
                // Lower rank is better: rank 1 at top.
                if (maxRank <= 1) return padTop;
                return padTop + ((r - 1) / (maxRank - 1)) * (height - padTop - padBottom);
            };

            const points = history.map(h => `${xForYear(h.year).toFixed(1)},${yForRank(h.seed_rank).toFixed(1)}`).join(' ');

            const xAxisY = height - padBottom;
            const yAxisX = padLeft;
            const tickLen = 8;
            const innerW = (width - padLeft - padRight);
            const yearSpan = Math.max(1, (maxYear - minYear));
            const yearDx = innerW / yearSpan;
            const yearLabelEvery = Math.max(1, Math.ceil(12 / Math.max(1, yearDx)));
            const allYears = [];
            for (let y = minYear; y <= maxYear; y += 1) allYears.push(y);
            const yearTicks = allYears.map(y => {
                const x = xForYear(y).toFixed(1);
                return `<line x1="${x}" y1="${xAxisY}" x2="${x}" y2="${(xAxisY + tickLen).toFixed(1)}" stroke="rgba(26,26,26,0.28)" />`;
            }).join('');
            const yearGrid = allYears.map(y => {
                const x = xForYear(y).toFixed(1);
                return `<line x1="${x}" y1="${padTop}" x2="${x}" y2="${xAxisY}" stroke="rgba(26,26,26,0.03)" />`;
            }).join('');
            const yearLabels = allYears
                .filter((_, idx) => (idx % yearLabelEvery) === 0 || idx === allYears.length - 1)
                .map(y => {
                    const x = xForYear(y).toFixed(1);
                    const labelY = (xAxisY + tickLen + 6).toFixed(1);
                    return `<text transform="translate(${x},${labelY}) rotate(-90)" text-anchor="end" font-size="11" font-weight="700" fill="rgba(26,26,26,0.80)">${String(y).padStart(4, '0')}</text>`;
                })
                .join('');

            // Y axis tick labels (seed ranks)
            const innerH = (height - padTop - padBottom);
            const rankSpan = Math.max(1, (maxRank - 1));
            const rankDy = innerH / rankSpan;
            const yLabelEvery = Math.max(1, Math.ceil(16 / Math.max(1, rankDy)));
            const yTickMarks = [];
            for (let r = 1; r <= maxRank; r += 1) yTickMarks.push(r);
            const yTickLines = yTickMarks.map(r => {
                const y = yForRank(r).toFixed(1);
                return `<line x1="${yAxisX}" y1="${y}" x2="${(yAxisX - 7).toFixed(1)}" y2="${y}" stroke="rgba(26,26,26,0.30)" />`;
            }).join('');
            const yGrid = yTickMarks.map(r => {
                const y = yForRank(r).toFixed(1);
                return `<line x1="${yAxisX}" y1="${y}" x2="${(width - padRight).toFixed(1)}" y2="${y}" stroke="rgba(26,26,26,0.05)" />`;
            }).join('');
            const yTickLabels = yTickMarks
                .filter((_, idx) => (idx % yLabelEvery) === 0 || idx === yTickMarks.length - 1)
                .map(r => {
                    const y = yForRank(r).toFixed(1);
                    return `<text x="${(yAxisX - 12).toFixed(1)}" y="${(parseFloat(y) + 4).toFixed(1)}" text-anchor="end" font-size="11" font-weight="700" fill="rgba(26,26,26,0.82)">#${r}</text>`;
                })
                .join('');

            const pointDots = history.map(h => {
                const x = xForYear(h.year).toFixed(1);
                const y = yForRank(h.seed_rank).toFixed(1);
                const pts = Number.isFinite(h.seed_points) ? h.seed_points : parseFloat(h.seed_points);
                const ptsAttr = Number.isFinite(pts) ? String(pts) : '';
                return `
                    <g class="seed-dot" data-year="${h.year}" data-rank="${h.seed_rank}" data-points="${ptsAttr}" data-x="${x}" data-y="${y}">
                        <circle cx="${x}" cy="${y}" r="4.25" fill="rgba(245, 158, 11, 0.95)" stroke="rgba(26,26,26,0.10)" stroke-width="1"></circle>
                        <circle class="seed-dot-hit" cx="${x}" cy="${y}" r="12" fill="transparent"></circle>
                    </g>
                `;
            }).join('');

            container.innerHTML = `
                <svg viewBox="0 0 ${width} ${height}" width="100%" height="${height}" role="img" aria-label="Seed rank history" style="display:block;">
                    <rect x="0" y="0" width="${width}" height="${height}" fill="#ffffff" />
                    <line x1="${yAxisX}" y1="${padTop}" x2="${yAxisX}" y2="${xAxisY}" stroke="rgba(26,26,26,0.32)" stroke-width="1.3" />
                    <line x1="${yAxisX}" y1="${xAxisY}" x2="${width - padRight}" y2="${xAxisY}" stroke="rgba(26,26,26,0.32)" stroke-width="1.3" />
                    ${yearGrid}
                    ${yGrid}
                    ${yearTicks}
                    ${yTickLines}
                    ${yTickLabels}
                    ${yearLabels}
                    <polyline points="${points}" fill="none" stroke="rgba(245, 158, 11, 0.95)" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" />
                    <circle id="seed-hover-dot" cx="0" cy="0" r="7" fill="rgba(245, 158, 11, 1)" stroke="rgba(26,26,26,0.35)" stroke-width="2" style="display:none;"></circle>
                    ${pointDots}
                    <text transform="translate(14,${((padTop + xAxisY) / 2).toFixed(1)}) rotate(-90)" text-anchor="middle" font-size="12.5" font-weight="900" fill="rgba(26,26,26,0.75)">Seed rank</text>
                    <text x="${((yAxisX + (width - padRight)) / 2).toFixed(1)}" y="${(height - 10).toFixed(1)}" text-anchor="middle" font-size="12.5" font-weight="900" fill="rgba(26,26,26,0.75)">Year</text>
                </svg>
                <div class="seed-rank-tooltip" aria-hidden="true"></div>
            `;

            // Custom tooltip + active point highlight
            const tooltip = container.querySelector('.seed-rank-tooltip');
            const svg = container.querySelector('svg');
            const hoverDot = container.querySelector('#seed-hover-dot');
            const hits = Array.from(container.querySelectorAll('.seed-dot-hit'));

            const hide = () => {
                if (tooltip) tooltip.style.display = 'none';
                if (hoverDot) hoverDot.style.display = 'none';
            };

            const positionTooltip = (evt) => {
                if (!tooltip) return;
                const rect = container.getBoundingClientRect();
                let x = (evt.clientX - rect.left) + 12;
                let y = (evt.clientY - rect.top) + 12;
                // clamp within container bounds
                const maxX = rect.width - 10;
                const maxY = rect.height - 10;
                tooltip.style.display = 'block';
                // measure after display
                const tRect = tooltip.getBoundingClientRect();
                const tW = tRect.width;
                const tH = tRect.height;
                if (x + tW > maxX) x = Math.max(10, maxX - tW);
                if (y + tH > maxY) y = Math.max(10, maxY - tH);
                tooltip.style.left = `${x}px`;
                tooltip.style.top = `${y}px`;
            };

            hits.forEach(hit => {
                const g = hit.closest('.seed-dot');
                if (!g) return;
                const year = g.getAttribute('data-year');
                const rank = g.getAttribute('data-rank');
                const points = g.getAttribute('data-points');
                const x = g.getAttribute('data-x');
                const y = g.getAttribute('data-y');

                const show = (evt) => {
                    if (tooltip) {
                        const pointsText = points ? `${points} pts` : '‚Äî';
                        tooltip.innerHTML = `<div><strong>Year</strong>: ${year}</div><div><strong>Seed</strong>: #${rank}</div><div><strong>Points</strong>: ${pointsText}</div>`;
                    }
                    if (hoverDot) {
                        hoverDot.setAttribute('cx', x);
                        hoverDot.setAttribute('cy', y);
                        hoverDot.style.display = 'block';
                    }
                    positionTooltip(evt);
                };

                hit.addEventListener('mouseenter', show);
                hit.addEventListener('mousemove', show);
                hit.addEventListener('mouseleave', hide);
            });

            if (svg) {
                svg.addEventListener('mouseleave', hide);
            }
        }

        function generateTrophyCabinet(playerId, tournaments) {
            const el = document.getElementById('trophy-cabinet-content');
            if (!el) return;

            const engine = window.tournamentEngine;
            const items = { 1: [], 2: [], 3: [], booby: [] };

            const getFinish = (tournament) => {
                if (!tournament || !Array.isArray(tournament.final_standings)) return null;
                let idx = tournament.final_standings.findIndex(s => s.player === playerId);
                let isSharedHand = false;
                if (idx === -1) {
                    idx = tournament.final_standings.findIndex(s =>
                        s &&
                        s.is_partnership &&
                        Array.isArray(s.partnership_players) &&
                        s.partnership_players.some(p => p === playerId)
                    );
                    if (idx !== -1) {
                        isSharedHand = true;
                    }
                }
                if (idx === -1) return null;
                return { place: idx + 1, isSharedHand };
            };

            (tournaments || []).forEach(t => {
                const finish = getFinish(t);
                if (!finish) return;
                if (finish.place === 1 || finish.place === 2 || finish.place === 3) {
                    items[finish.place].push({ year: t.year });
                    return;
                }
                const totalPlayers = (t && Array.isArray(t.final_standings)) ? t.final_standings.length : 0;
                if (totalPlayers && finish.place === totalPlayers) {
                    items.booby.push({ year: t.year });
                }
            });

            const total = items[1].length + items[2].length + items[3].length + items.booby.length;
            if (!total) {
                el.innerHTML = `<div class="muted">Still waiting for their time to come.</div>`;
                return;
            }

            // Flatten into a single row: 1st (old->new), then 2nd, then 3rd
            const placeOrder = [
                { place: 1, emoji: 'üèÜ' },
                { place: 2, emoji: 'ü•à' },
                { place: 3, emoji: 'ü•â' },
                { place: 'booby', emoji: 'üé≠' }
            ];

            const flat = [];
            placeOrder.forEach(meta => {
                (items[meta.place] || [])
                    .slice()
                    .sort((a, b) => a.year - b.year)
                    .forEach(x => flat.push({ place: meta.place, emoji: meta.emoji, year: x.year }));
            });

            const trophies = flat.map(x => `
                <a class="trophy-link" href="/tournaments/results.html?year=${encodeURIComponent(String(x.year))}" aria-label="View ${x.year} tournament results">
                    <div class="trophy-piece trophy-piece--${x.place}" role="listitem">
                        <div class="trophy-piece-emoji">${x.emoji}</div>
                        <div class="trophy-piece-year">${x.year}</div>
                    </div>
                </a>
            `).join('');

            el.innerHTML = `
                <div class="trophy-row" role="list" aria-label="Trophy cabinet">
                    ${trophies}
                </div>
            `;
        }

        function generateTrumpSuitStats(playerName) {
            const engine = window.tournamentEngine;
            
            if (!engine || typeof engine.getPlayerTrumpSuitStats !== 'function') {
                console.error('‚ùå Tournament engine not available or missing trump suit methods');
                document.getElementById('trump-stats').innerHTML = '<p>Error loading trump suit statistics.</p>';
                return;
            }

            const trumpStats = engine.getPlayerTrumpSuitStats(playerName);

            // Compute win counts per suit (wins = 7+ tricks). Includes shared hands.
            const winsBySuit = { Hearts: 0, Clubs: 0, Diamonds: 0, Spades: 0 };
            const playedBySuit = { Hearts: 0, Clubs: 0, Diamonds: 0, Spades: 0 };
            const playerLower = String(playerName || '').toLowerCase();
            if (engine && engine.tournaments) {
                for (const t of engine.tournaments.values()) {
                    if (!t || !Array.isArray(t.rounds)) continue;
                    for (const r of t.rounds) {
                        if (!r || !Array.isArray(r.tables)) continue;
                        for (const table of r.tables) {
                            const partnerships = table && Array.isArray(table.partnerships) ? table.partnerships : [];
                            for (const p of partnerships) {
                                if (!p || !Array.isArray(p.position1) || !Array.isArray(p.position2)) continue;
                                const sidePlayers = Array.from(new Set([...(p.position1 || []), ...(p.position2 || [])]))
                                    .filter(Boolean);
                                const hasPlayer = sidePlayers.some(x => String(x || '').toLowerCase() === playerLower);
                                if (!hasPlayer) continue;

                                const tricks = Number.isFinite(p.tricks) ? p.tricks : parseFloat(p.tricks);
                                if (!Number.isFinite(tricks)) continue;

                                const suit = p.trump_suit || r.trump_suit || 'Unknown';
                                if (!(suit in playedBySuit)) continue;
                                playedBySuit[suit] += 1;
                                if (tricks >= 7) winsBySuit[suit] += 1;
                            }
                        }
                    }
                }
            }
            
            const suitIcons = {
                'Hearts': '‚ô•',
                'Diamonds': '‚ô¶',
                'Spades': '‚ô†',
                'Clubs': '‚ô£'
            };
            
            // Order: Hearts, Clubs, Diamonds, Spades
            const suitOrder = ['Hearts', 'Clubs', 'Diamonds', 'Spades'];
            
            const trumpHTML = suitOrder.map((suit, index) => {
                const stats = trumpStats[suit];
                const icon = suitIcons[suit];
                const suitClass = String(suit || '').toLowerCase();
                const average = stats.rounds_played > 0 ? stats.average.toFixed(2) : '0.00';
                const played = playedBySuit[suit] || stats.rounds_played || 0;
                const wins = winsBySuit[suit] || 0;
                const winRateText = played > 0 ? `${Math.round((wins / played) * 100)}%` : '‚Äî';
                
                return `
                    <div class="meta-item">
                        <span class="meta-label"><span class="suit-icon suit-icon--${suitClass}">${icon}</span> ${suit}</span>
                        <span class="meta-value">
                            ${average} <span class="meta-subvalue">avg/round</span><br>
                            <span class="meta-subvalue">Win rate: ${winRateText}${played > 0 ? ` (${wins}/${played})` : ''}</span>
                        </span>
                    </div>
                `;
            }).join('');

            document.getElementById('trump-stats').innerHTML = `
                ${trumpHTML}
            `;
        }

        function generateTournamentTimeline(player, tournaments) {
            // Use centralized calculation methods for caching compatibility
            const engine = window.tournamentEngine;
            const HISTORY_LIMIT = 10;
            if (typeof window.__showAllTournamentHistory !== 'boolean') {
                window.__showAllTournamentHistory = true; // default: show full history
            }
            
            if (!engine || typeof engine.getPositionEmoji !== 'function') {
                console.error('‚ùå Tournament engine not available or missing methods');
                document.getElementById('tournament-timeline').innerHTML = '<p>Error loading tournament history.</p>';
                return;
            }
            
            const sorted = (tournaments || []).slice().sort((a, b) => (b.year || 0) - (a.year || 0));
            const totalCount = sorted.length;
            const showingAll = window.__showAllTournamentHistory;
            const visible = showingAll ? sorted : sorted.slice(0, HISTORY_LIMIT);
            const range = window.__globalAvgTricksRange || { min: 0, max: 13 };
            const rangeMin = Number.isFinite(range.min) ? range.min : 0;
            const rangeMax = Number.isFinite(range.max) ? range.max : 13;
            const rangeSpan = rangeMax > rangeMin ? (rangeMax - rangeMin) : 1;

            const timelineHTML = visible
                .map(tournament => {
                    // Check for individual ranking first
                    let playerRanking = tournament.final_standings.findIndex(s => s.player === player.name) + 1;
                    let isSharedHand = false;
                    let partnershipName = null;
                    let tricksForDisplay = null; // For shared hands, use partnership total (not split)
                    let sharingWithText = null;
                    
                    // If not found individually, check shared hand partnerships
                    if (playerRanking === 0) {
                        const sharedHandEntry = tournament.final_standings.find(s => 
                            s.is_partnership && 
                            s.partnership_players && 
                            s.partnership_players.some(p => p === player.name)
                        );
                        
                        if (sharedHandEntry) {
                            playerRanking = tournament.final_standings.findIndex(s => s === sharedHandEntry) + 1;
                            isSharedHand = true;
                            partnershipName = sharedHandEntry.player;
                            const partners = Array.isArray(sharedHandEntry.partnership_players) ? sharedHandEntry.partnership_players : [];
                            const others = partners.filter(p => p && p.toLowerCase() !== player.name.toLowerCase());
                            const prettyOthers = others.map(p => (engine && typeof engine.getDisplayName === 'function') ? engine.getDisplayName(p) : p);
                            sharingWithText = prettyOthers.length ? prettyOthers.join(' & ') : null;
                            const sharedTricks = Number.isFinite(sharedHandEntry.total_tricks)
                                ? sharedHandEntry.total_tricks
                                : parseFloat(sharedHandEntry.total_tricks);
                            tricksForDisplay = Number.isFinite(sharedTricks) ? sharedTricks : null;
                        } else {
                            // Player not found in this tournament - should not happen but handle gracefully
                            playerRanking = null;
                        }
                    }
                    
                    const isWinner = tournament.winner === player.name;
                    const isTopThree = playerRanking <= 3 && playerRanking > 0;
                    const totalPlayers = tournament.final_standings.length;
                    
                    // Use centralized methods for calculations
                    const positionEmoji = engine.getPositionEmoji(playerRanking, totalPlayers);
                    const actualRounds = engine.getTournamentRoundsCount(tournament);
                    
                    // Avg tricks/round for the barometer:
                    // - Shared hand: use partnership total tricks (not split)
                    // - Solo: use engine helper
                    let avgTricksValue = null;
                    if (isSharedHand && Number.isFinite(tricksForDisplay) && actualRounds > 0) {
                        avgTricksValue = tricksForDisplay / actualRounds;
                    } else {
                        const avg = engine.getPlayerAverageTricksPerRound(player.name, tournament);
                        avgTricksValue = Number.isFinite(avg) ? avg : null;
                    }
                    const avgTricks = avgTricksValue === null ? null : avgTricksValue.toFixed(2);
                    const capped = avgTricksValue === null ? null : Math.max(rangeMin, Math.min(rangeMax, avgTricksValue));
                    const pctRaw = capped === null ? 0 : ((capped - rangeMin) / rangeSpan);
                    const pct = Math.max(0, Math.min(1, pctRaw));
                    const barPct = pct * 100;
                    const barTitle = avgTricksValue === null
                        ? 'Performance unavailable'
                        : `${avgTricks} avg tricks/round (range ${rangeMin.toFixed(2)}‚Äì${rangeMax.toFixed(2)})`;

                    return `
                        <a href="../tournaments/results.html?year=${tournament.year}" class="timeline-item timeline-item--compact ${isWinner ? 'winner' : isTopThree ? 'top-three' : ''}">
                            <span class="timeline-year">${tournament.year}</span>
                            <div class="timeline-line1">
                                <span class="timeline-tournament">${tournament.name}</span>
                                ${isSharedHand ? '<span class="shared-hand-badge">ü§ù Shared Hand</span>' : ''}
                                ${isSharedHand && sharingWithText ? `<span class="partnership-text">with: ${sharingWithText}</span>` : ''}
                            </div>
                            <div class="timeline-line2">
                                <div class="timeline-result">
                                    <span class="position-emoji">${positionEmoji}</span>
                                    <span class="result-position">${playerRanking ? `${playerRanking}${engine.getOrdinalSuffix(playerRanking)} Place` : 'Participated'}</span>
                                    ${isWinner ? '<span class="winner-badge">üèÜ Champion</span>' : ''}
                                </div>
                                <div class="timeline-performance-stack" title="${barTitle}">
                                    <div class="perf-label">${avgTricks === null ? '‚Äî' : `${avgTricks} avg/round`}</div>
                                    <div class="perf-bar" aria-hidden="true">
                                        <div class="perf-bar-mask" style="left:${barPct.toFixed(1)}%"></div>
                                        <div class="perf-bar-marker" style="left:${barPct.toFixed(1)}%"></div>
                                    </div>
                                </div>
                            </div>
                        </a>
                    `;
                })
                .join('');
            
            document.getElementById('tournament-timeline').innerHTML = timelineHTML || '<p>No tournament history available.</p>';

            const meta = document.getElementById('tournament-timeline-meta');
            const toggleBtn = document.getElementById('toggle-tournament-history');
            if (meta) {
                if (!totalCount) {
                    meta.textContent = '';
                } else if (showingAll) {
                    meta.textContent = `Showing all ${totalCount} tournaments`;
                } else {
                    meta.textContent = `Showing latest ${Math.min(HISTORY_LIMIT, totalCount)} of ${totalCount} tournaments`;
                }
            }
            if (toggleBtn) {
                if (totalCount <= HISTORY_LIMIT) {
                    toggleBtn.style.display = 'none';
                    toggleBtn.onclick = null;
                } else {
                    toggleBtn.style.display = 'inline-flex';
                    toggleBtn.textContent = showingAll ? 'Show latest 10' : `Show all (${totalCount})`;
                    toggleBtn.onclick = () => {
                        window.__showAllTournamentHistory = !window.__showAllTournamentHistory;
                        generateTournamentTimeline(player, tournaments);
                    };
                }
            }
        }

        function computeGlobalAvgTricksRange(engine, tournaments) {
            const values = [];
            const list = Array.isArray(tournaments) ? tournaments : [];
            list.forEach(t => {
                if (!t || !Array.isArray(t.final_standings) || t.final_standings.length === 0) return;
                const rounds = (engine && typeof engine.getTournamentRoundsCount === 'function')
                    ? engine.getTournamentRoundsCount(t)
                    : 13;
                const denom = Number.isFinite(rounds) && rounds > 0 ? rounds : 13;

                t.final_standings.forEach(s => {
                    const tricks = Number.isFinite(s.total_tricks) ? s.total_tricks : parseFloat(s.total_tricks);
                    if (!Number.isFinite(tricks)) return;
                    const avg = tricks / denom;
                    if (!Number.isFinite(avg)) return;
                    values.push(avg);
                });
            });

            if (!values.length) {
                return { min: 0, max: 13, mean: 0, std: 0 };
            }

            const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
            const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
            const std = Math.sqrt(variance);

            const min = mean - (2 * std);
            const max = mean + (2 * std);

            if (!Number.isFinite(min) || !Number.isFinite(max) || max <= min) {
                return { min: 0, max: 13, mean, std: Number.isFinite(std) ? std : 0 };
            }

            return { min, max, mean, std };
        }

        // getOrdinalSuffix function moved to TournamentEngine class for centralized caching
    </script>
    
    <style>
        /* Player Profile Specific Styles */
        .player-hero {
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--primary-dark) 100%);
            color: var(--text-primary);
            padding: var(--spacing-3xl) 0;
            position: relative;
            overflow: hidden;
        }

        .player-profile {
            display: flex;
            gap: var(--spacing-2xl);
            align-items: flex-start;
        }

        .player-avatar {
            position: relative;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 180px;
        }

        .avatar-frame {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto var(--spacing-md);
            border-radius: 50%;
            cursor: zoom-in;
            outline: none;
            /* Make the circle visible even when we only have initials (no photo) */
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.88), var(--shadow-card);
        }
        .avatar-frame:focus-visible {
            box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.35);
        }

        .avatar-placeholder {
            width: 120px;
            height: 120px;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent-color) 100%);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: none;
        }

        #player-avatar-img {
            position: absolute;
            top: 0;
            left: 0;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            box-shadow: none;
        }

        .avatar-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.72);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem 1rem;
            z-index: 9999;
        }
        .avatar-modal__content {
            width: min(720px, 92vw);
            max-height: 92vh;
            background: rgba(15, 23, 42, 0.92);
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 18px;
            padding: 1rem;
            box-shadow: 0 24px 70px rgba(0,0,0,0.55);
            position: relative;
        }
        .avatar-modal__close {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            z-index: 2;
        }
        #avatar-modal-img {
            display: block;
            width: 100%;
            height: auto;
            max-height: calc(92vh - 4rem);
            object-fit: contain;
            border-radius: 14px;
            background: white;
        }

        .avatar-icon {
            font-size: 2rem;
            margin-bottom: 0.25rem;
        }

        .avatar-initial {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .champion-badge {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1a1a1a;
            padding: 0.5rem 1rem;
            border-radius: var(--border-radius-full);
            font-size: 0.875rem;
            font-weight: 600;
            box-shadow: var(--shadow-sm);
        }

        .player-info {
            flex: 1;
        }

        .player-header {
            margin-bottom: var(--spacing-xl);
        }

        .player-name {
            font-size: 3rem;
            font-weight: 900;
            margin-bottom: 0.5rem;
            line-height: 1.1;
        }

        .player-nickname {
            font-size: 1.25rem;
            font-style: italic;
            color: var(--accent-color);
            margin-bottom: 0.5rem;
        }

        .player-title {
            font-size: 1.125rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .player-meta {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
        }

        .meta-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .meta-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .meta-value {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .meta-subvalue {
            font-size: 0.9em;
            font-weight: 700;
            opacity: 0.85;
        }

        .suit-icon {
            display: inline-block;
            min-width: 0.9em;
            font-weight: 900;
        }

        .suit-icon--hearts,
        .suit-icon--diamonds {
            color: #dc2626;
        }

        .family-tree-link {
            margin-bottom: var(--spacing-xl);
        }

        .family-tree-link--avatar {
            margin-top: var(--spacing-sm);
            margin-bottom: 0;
        }

        .family-tree-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: var(--bg-secondary);
            color: var(--text-primary);
            text-decoration: none;
            border-radius: var(--border-radius-md);
            font-weight: 500;
            transition: background-color 0.2s ease;
        }

        .family-tree-btn:hover {
            background: var(--bg-accent);
        }

        .family-tree-link--avatar .family-tree-btn {
            width: 100%;
            justify-content: center;
            padding: 0.65rem 1rem;
            font-weight: 700;
        }

        .memorial-link {
            margin-top: 0.55rem;
        }

        .memorial-link__a {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.15rem;
            padding: 0.45rem 0.25rem;
            color: rgba(255, 255, 255, 0.92);
            text-decoration: none;
            font-weight: 900;
            line-height: 1.1;
        }

        .memorial-link__a:hover {
            text-decoration: underline;
            opacity: 0.95;
        }

        .memorial-wreath {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.92);
            margin-bottom: 0.1rem;
        }

        .memorial-label {
            font-family: var(--font-primary);
            letter-spacing: 0.02em;
            color: rgba(255, 255, 255, 0.92);
            font-weight: 900;
            font-size: 1.05rem;
            text-align: center;
        }

        .memorial-year {
            color: rgba(255, 255, 255, 0.78);
            font-weight: 900;
            font-size: 0.95rem;
            text-align: center;
        }

        .career-highlights {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--spacing-md);
        }

        /* Trophy cabinet (in header/hero) */
        .trophy-cabinet {
            margin-top: var(--spacing-lg);
            background: rgba(10, 26, 15, 0.55);
            border: 1px solid rgba(34, 197, 94, 0.35);
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-md) var(--spacing-lg);
            position: relative;
            overflow: hidden;
        }

        .trophy-cabinet-label {
            font-size: 0.75rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            font-weight: 800;
            color: rgba(248, 250, 252, 0.9);
            margin-bottom: 0.6rem;
        }

        .trophy-cabinet-content .loading-message {
            color: rgba(248, 250, 252, 0.75);
        }

        .trophy-cabinet::after {
            content: '';
            position: absolute;
            left: var(--spacing-lg);
            right: var(--spacing-lg);
            bottom: 16px;
            height: 2px;
            background: linear-gradient(90deg, transparent 0%, rgba(34, 197, 94, 0.25) 20%, rgba(34, 197, 94, 0.25) 80%, transparent 100%);
            pointer-events: none;
        }

        .trophy-row {
            display: flex;
            gap: var(--spacing-lg);
            align-items: flex-end;
            justify-content: flex-start;
            flex-wrap: wrap;
            overflow-x: hidden;
            overflow-y: visible;
            padding-bottom: 18px; /* leaves room for shelf line */
            scrollbar-width: thin;
        }

        .trophy-piece {
            flex: 0 0 auto;
            width: 64px;
            text-align: center;
        }

        .trophy-link {
            display: inline-block;
            text-decoration: none;
            color: inherit;
            border-radius: 14px;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
        }

        .trophy-link:hover .trophy-piece-emoji {
            transform: translateY(-1px);
            filter: drop-shadow(0 10px 18px rgba(0, 0, 0, 0.18));
        }

        .trophy-link:focus-visible {
            outline: 3px solid rgba(255, 255, 255, 0.55);
            outline-offset: 4px;
        }

        .trophy-piece-emoji {
            transition: transform 0.12s ease, filter 0.12s ease;
        }

        .trophy-piece-emoji {
            font-size: 2.6rem;
            line-height: 1;
            filter: drop-shadow(0 2px 8px rgba(0,0,0,0.25));
            margin-bottom: 0.35rem;
        }

        .trophy-piece-year {
            font-weight: 700;
            font-size: 0.9rem;
            color: rgba(248, 250, 252, 0.85);
        }

        @media (max-width: 768px) {
            .trophy-piece {
                width: 56px;
            }
            .trophy-piece-emoji {
                font-size: 2.35rem;
            }
        }

        .highlight-card {
            background: var(--bg-secondary);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius-lg);
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            box-shadow: var(--shadow-sm);
        }

        .highlight-card.primary {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent-color) 100%);
            color: var(--text-primary);
        }

        .highlight-icon {
            font-size: 2rem;
        }

        .highlight-number {
            font-size: 2rem;
            font-weight: 900;
            line-height: 1;
            margin-bottom: 0.25rem;
        }

        .highlight-label {
            font-size: 0.875rem;
            opacity: 0.9;
            font-weight: 500;
        }

        .player-stats {
            padding: var(--spacing-3xl) 0;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, #f8fafc 50%, var(--bg-secondary) 100%);
            position: relative;
        }

        .player-stats::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(var(--primary-color-rgb), 0.03) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(var(--accent-color-rgb), 0.03) 0%, transparent 50%);
            pointer-events: none;
        }

        .stats-grid {
            display: grid;
            gap: var(--spacing-2xl);
            /* Override global auto-fit columns: stack panels vertically */
            grid-template-columns: 1fr;
        }

        .stats-section {
            background: white;
            padding: var(--spacing-xl);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-card);
            position: relative;
            z-index: 1;
            /* Ensure default text is readable on white panels */
            color: var(--text-primary-dark);
        }

        .stats-section .section-title {
            color: var(--text-primary-dark);
            margin-bottom: var(--spacing-lg);
            text-align: left;
            font-size: 1.28rem;
            font-weight: 800;
        }

        .stats-section .section-title::after {
            /* Disable global centered underline for panel titles */
            content: none;
            display: none;
        }

        .stats-section .title-icon {
            color: var(--primary-color);
        }

        .stats-section.full-width {
            grid-column: 1 / -1;
        }

        .meta-grid {
            display: grid;
            /* Always 4 columns; items fill left-to-right then wrap */
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: var(--spacing-lg);
        }

        .seed-rank-meta {
            margin-bottom: var(--spacing-lg);
        }

        /* Make header-style tiles readable on white panels */
        .stats-section .meta-label {
            color: var(--text-secondary-dark);
            font-weight: 700;
        }

        .stats-section .meta-value {
            color: var(--text-primary-dark);
            font-weight: 800;
            font-size: 1.15rem;
        }

        .inline-link {
            color: var(--text-primary-dark);
            text-decoration: none;
            font-weight: 900;
        }

        .inline-link:hover {
            text-decoration: underline;
        }

        .partnership-cta {
            margin-top: var(--spacing-lg);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.7rem 1rem;
            border-radius: 999px;
            border: 1px solid rgba(34, 197, 94, 0.28);
            background: rgba(34, 197, 94, 0.12);
            color: var(--text-primary-dark);
            font-weight: 900;
            text-decoration: none;
        }

        .partnership-cta:hover {
            background: rgba(34, 197, 94, 0.18);
            text-decoration: underline;
        }

        .stats-table {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md) 0;
            border-bottom: 1px solid var(--border-light);
        }

        .stats-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-weight: 500;
            color: var(--text-secondary-dark);
        }

        .stat-value {
            font-weight: 600;
            color: var(--text-primary-dark);
        }

        .chart-container {
            background: white;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-lg);
            height: 400px;
            position: relative;
        }

        .chart-container canvas {
            max-height: 100% !important;
        }

        /* Used by small chart meta lines inside white panels */
        .muted {
            color: var(--text-secondary-dark);
        }

        .seed-rank-tooltip {
            position: absolute;
            z-index: 5;
            display: none;
            max-width: 220px;
            background: rgba(17, 24, 39, 0.96);
            color: #fff;
            padding: 0.5rem 0.6rem;
            border-radius: 10px;
            font-size: 0.85rem;
            line-height: 1.2;
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.25);
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        .seed-rank-tooltip strong {
            font-weight: 800;
        }

        .tournament-timeline {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .timeline-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
        }

        .timeline-meta {
            color: var(--text-secondary-dark);
            font-size: 0.9rem;
            font-weight: 600;
        }

        .timeline-toggle-btn {
            background: rgba(34, 197, 94, 0.12);
            border: 1px solid rgba(34, 197, 94, 0.28);
            color: var(--text-primary-dark);
            padding: 0.4rem 0.8rem;
            border-radius: 999px;
            font-weight: 800;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .timeline-toggle-btn:hover {
            background: rgba(34, 197, 94, 0.18);
            transform: translateY(-1px);
        }

        .timeline-item {
            display: block;
            padding: 0.85rem 1rem;
            background: white;
            border-radius: 14px;
            border: 1px solid rgba(34, 197, 94, 0.18);
            text-decoration: none;
            color: inherit;
            transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.05);
        }

        .timeline-item--compact {
            display: grid;
            grid-template-columns: 64px 1fr;
            grid-template-rows: auto auto;
            column-gap: 14px;
            row-gap: 6px;
            align-items: start;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        .timeline-item:hover::before {
            transform: translateX(100%);
        }

        .timeline-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.12);
            text-decoration: none;
            border-color: rgba(212, 175, 55, 0.5);
        }

        .timeline-item.winner {
            border-color: rgba(212, 175, 55, 0.55);
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.10) 0%, rgba(255, 255, 255, 1) 80%);
        }

        .timeline-item.winner:hover {
            border-color: rgba(212, 175, 55, 0.75);
        }

        .timeline-item.top-three {
            border-color: rgba(34, 197, 94, 0.35);
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.10) 0%, rgba(255, 255, 255, 1) 80%);
        }

        .timeline-year {
            font-size: 1.25rem;
            font-weight: 900;
            color: var(--text-secondary-dark);
            text-align: left;
            grid-column: 1;
            grid-row: 1;
            line-height: 1.1;
            align-self: center;
        }

        .timeline-tournament {
            font-weight: 850;
            font-size: 1.18rem;
            color: #1a1a1a;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 0 1 auto;
            display: inline-block;
            max-width: clamp(220px, 48vw, 620px);
        }

        .timeline-line1 {
            display: flex;
            align-items: center;
            gap: 0.55rem;
            min-width: 0;
            grid-column: 2;
            grid-row: 1;
            align-self: center;
            justify-content: flex-start;
        }

        .timeline-line2 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            grid-column: 2;
            grid-row: 2;
        }

        .timeline-result {
            display: flex;
            align-items: center;
            gap: 0.45rem;
            margin-bottom: 0;
            min-width: 0;
        }

        .result-position {
            font-weight: 800;
            font-size: 1.12rem;
            color: #2c3e50;
            white-space: nowrap;
        }

        .timeline-item.winner .timeline-year,
        .timeline-item.winner .result-position {
            color: #8b4513;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.9);
        }

        .timeline-item.top-three .timeline-year,
        .timeline-item.top-three .result-position {
            color: #1565c0;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.9);
        }

        .position-emoji {
            font-size: 1.05rem;
            margin-right: 0;
        }

        .winner-badge {
            background: rgba(212, 175, 55, 0.22);
            color: var(--text-primary-dark);
            padding: 0.18rem 0.6rem;
            border-radius: 999px;
            font-size: 0.8rem;
            font-weight: 900;
            white-space: nowrap;
        }

        .timeline-performance-stack {
            width: 260px;
            display: flex;
            align-items: center;
            margin-left: auto; /* lock to same x position */
            position: relative;
            /* Keep a stable box height so the bar can be vertically centered */
            height: 26px;
        }

        .perf-bar {
            width: 100%;
            height: 10px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(239, 68, 68, 0.85) 0%, rgba(245, 158, 11, 0.85) 55%, rgba(34, 197, 94, 0.9) 100%);
            overflow: hidden;
            border: 1px solid rgba(26, 26, 26, 0.10);
            position: relative;
            /* Center bar within the stack regardless of label */
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
        }

        .perf-bar-mask {
            position: absolute;
            top: 0;
            bottom: 0;
            right: 0;
            /* left is set inline (same as marker percentage) */
            background: rgba(238, 238, 238, 0.92);
        }

        .perf-bar-marker {
            position: absolute;
            top: -2px;
            bottom: -2px;
            width: 2px;
            background: rgba(26, 26, 26, 0.55);
            transform: translateX(-1px);
            border-radius: 2px;
        }

        .perf-label {
            font-size: 0.85rem;
            font-weight: 800;
            color: var(--text-secondary-dark);
            white-space: nowrap;
            text-align: right;
            width: 100%;
            /* Float above the bar without affecting layout */
            position: absolute;
            right: 0;
            bottom: calc(50% + 9px);
            line-height: 1;
        }

        .loading-message {
            text-align: center;
            color: var(--text-secondary-dark);
            padding: var(--spacing-xl);
            font-style: italic;
        }

        @media (max-width: 768px) {
            .player-profile {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }

            .player-name {
                font-size: 2rem;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            /* Responsive: keep tiles readable */
            .meta-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .timeline-item {
                padding: 0.85rem 0.9rem;
            }

            .timeline-item--compact {
                grid-template-columns: 52px 1fr;
                column-gap: 10px;
            }

            .timeline-year {
                font-size: 1.1rem;
            }

            .timeline-tournament {
                font-size: 0.98rem;
            }

            .timeline-line2 {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }

            .timeline-performance-stack {
                width: 100%;
                max-width: none;
                align-self: stretch;
                margin-left: 0;
            }

            .perf-bar {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .meta-grid {
                grid-template-columns: 1fr;
            }
        }

        .shared-hand-badge {
            background: rgba(59, 130, 246, 0.10);
            color: #1d4ed8;
            padding: 0.18rem 0.55rem;
            border-radius: 999px;
            font-size: 0.8rem;
            font-weight: 900;
            border: 1px solid rgba(59, 130, 246, 0.22);
            flex: 0 0 auto;
        }

        .partnership-text {
            color: var(--text-secondary-dark);
            font-size: 0.9rem;
            font-weight: 800;
            white-space: nowrap;
            flex: 0 0 auto;
        }
    </style>
</body>
</html>
