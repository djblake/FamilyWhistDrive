<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">Player Scorecard - Ruston Family Whist Drive</title>
    <meta name="description" content="Detailed scorecard and tournament performance analysis">
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="/assets/js/footer-nav.js?v=1" defer></script>
    <script src="/assets/js/media.js?v=1" defer></script>
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo-section">
                    <div class="card-suits"><span class="heart">‚ô•</span> <span class="club">‚ô£</span> <span class="diamond">‚ô¶</span> <span class="spade">‚ô†</span></div>
                    <h1 class="site-title">Ruston Family Whist Drive</h1>
                    <p class="site-subtitle">Est. 1984 ‚Ä¢ The World's Most Elite Family Tournament</p>
                </div>
                <nav class="main-nav">
                    <a href="../" class="nav-link">Home</a>
                    <a href="../tournaments/" class="nav-link">Tournaments</a>
                    <a href="../tables/" class="nav-link">Tables</a>
                    <a href="../players/" class="nav-link">Players</a>
                    <a href="../leaderboard/" class="nav-link">Hall of Fame</a>
                    <a href="../stats/" class="nav-link">Statistics</a>
                </nav>
            </div>
        </div>
    </header>

    <div id="data-issues-banner" class="data-issues-banner" style="display: none;"></div>

    <main class="main-content">
        <!-- Loading State -->
        <section class="loading-section" id="loading-section">
            <div class="container">
                <div class="loading-content">
                    <div class="loading-spinner">üé¥</div>
                    <h2>Loading Player Scorecard...</h2>
                    <p>Retrieving tournament data from archives...</p>
                </div>
            </div>
        </section>

        <!-- Error State -->
        <section class="error-section" id="error-section" style="display: none;">
            <div class="container">
                <div class="error-content">
                    <div class="error-icon">‚ùå</div>
                    <h2>Scorecard Not Found</h2>
                    <p id="error-message">Unable to load player scorecard data.</p>
                    <a href="../tournaments/" class="btn btn-primary">‚Üê Back to Tournaments</a>
                </div>
            </div>
        </section>

        <!-- Player Scorecard Content -->
        <section class="player-scorecard" id="scorecard-content" style="display: none;">
            <div class="container">
                <!-- Player Header -->
                <div class="player-header">
                    <div class="player-info">
                        <div class="player-nav-row">
                            <div class="back-link">
                                <a href="#" id="back-to-tournament">‚Üê Back to Tournament</a>
                            </div>
                            <div class="player-actions" id="player-profile-actions" aria-label="Player actions"></div>
                        </div>
                        <h1 class="player-name" id="player-name">Loading...</h1>
                        <p class="tournament-context" id="tournament-context">Tournament Context</p>
                        <div class="player-rank">
                            <span class="rank-badge" id="player-rank">Loading...</span>
                            <span class="performance-summary" id="performance-summary">Performance Summary</span>
                        </div>
                    </div>
                    <div class="tournament-summary">
                        <div class="summary-stats">
                            <div class="stat">
                                <span class="stat-value" id="total-tricks">--</span>
                                <span class="stat-label">Total Tricks</span>
                            </div>
                            <div class="stat">
                                <span class="stat-value" id="average-tricks">--</span>
                                <span class="stat-label">Average</span>
                            </div>
                            <div class="stat">
                                <span class="stat-value" id="rounds-played">--</span>
                                <span class="stat-label">Rounds</span>
                            </div>
                            <div class="stat">
                                <span class="stat-value" id="best-round">--</span>
                                <span class="stat-label">Most Tricks</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Data Error Summary (hidden by default) -->
                <div id="data-error-summary" style="display: none;"></div>

                <!-- Complete Round-by-Round Scorecard -->
                <div class="scorecard-section">
                    <h2 class="section-title">
                        <span class="title-icon">üìã</span>
                        Complete Tournament Scorecard
                    </h2>
                    <div class="scorecard-table-container">
                        <table class="scorecard-table" id="scorecard-table">
                            <thead>
                                <tr>
                                    <th>Round</th>
                                    <th>Trump</th>
                                    <th>Table</th>
                                    <th>Scan</th>
                                    <th>Partner</th>
                                    <th>Our Tricks</th>
                                    <th>Their Tricks</th>
                                    <th>Opponents</th>
                                    <th>Result</th>
                                    <th>Total</th>
                                </tr>
                            </thead>
                            <tbody id="scorecard-body">
                                <!-- Will be populated dynamically -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Rank Progression Chart -->
                <div class="chart-section">
                    <h2 class="section-title">
                        <span class="title-icon">üìà</span>
                        Rank Progression Throughout Tournament
                    </h2>
                    <p class="chart-description">Watch how <span id="chart-player-name">this player's</span> ranking changed after each round compared to all other players.</p>
                    <div class="chart-container" style="width: 100%; height: 600px; position: relative;">
                        <canvas id="rank-progression-chart"></canvas>
                    </div>
                </div>

                <!-- Photo Upload Section -->
                <div class="photo-section">
                    <h3>Scorecard Verification</h3>
                    <div class="photo-upload-info">
                        <p>üì∏ Original scorecard photos can be uploaded to:</p>
                        <code id="photo-path">tournaments/YEAR/PLAYER/</code>
                        <p>Photos will automatically appear here for verification against the digital scorecard above.</p>
                    </div>
                    <div id="player-scorecard-scan" style="margin-top: 0.75rem;"></div>
                    <div id="scorecard-photos">
                        <!-- Photos will be loaded here if available -->
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div data-footer-nav></div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2024 Ruston Family Whist Drive.</p>
            </div>
        </div>
    </footer>

    <!-- Load Chart.js first -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
            <script src="../assets/js/tournament-engine.js?v=cache1"></script>
            <script src="../assets/js/charts.js?v=20"></script>
    <script src="../assets/js/photo-gallery.js"></script>
    <script>
        // Normalize hand sharing partnership display format
        function normalizeHandSharingDisplay(playerName) {
            if (!playerName) return playerName;
            
            // Convert any hand sharing delimiter to "/" format (no spaces)
            const delimiters = ['+', '&'];
            for (const delimiter of delimiters) {
                if (playerName.includes(delimiter)) {
                    return playerName.split(delimiter).map(name => name.trim()).join('/');
                }
            }
            
            return playerName;
        }

        function formatPossessiveName(name) {
            if (!name) return '';
            const trimmed = name.trim();
            if (trimmed.length === 0) return '';
            return trimmed.endsWith('s') ? `${trimmed}'` : `${trimmed}'s`;
        }

        // Check if a name represents a hand sharing partnership
        function isHandSharingPartnership(playerName) {
            if (!playerName) return false;
            const delimiters = ['+', '/', '&'];
            return delimiters.some(delimiter => playerName.includes(delimiter));
        }

        function splitSharedIdentifiers(identifier) {
            if (!identifier) return [];
            if (Array.isArray(identifier)) {
                return identifier.flatMap(item => splitSharedIdentifiers(item));
            }
            return identifier
                .split(/[\/+&]/)
                .map(part => part.trim())
                .filter(part => part.length > 0);
        }

        function resolvePlayerIdentity(identifier, engine) {
            const pieces = splitSharedIdentifiers(identifier);
            const canonicalIds = (pieces.length > 0 ? pieces : [identifier]).map(id =>
                engine && typeof engine.getCanonicalPlayerId === 'function'
                    ? engine.getCanonicalPlayerId(id)
                    : id
            );

            const displayIds = canonicalIds.map(id =>
                engine && typeof engine.getDisplayName === 'function'
                    ? engine.getDisplayName(id)
                    : normalizeHandSharingDisplay(id)
            );

            return {
                displayName: displayIds.join(' / '),
                canonicalIds
            };
        }

        function buildCombinedIdentity(identifiers, engine) {
            const flatIdentifiers = splitSharedIdentifiers(identifiers);
            const canonicalIds = (flatIdentifiers.length > 0 ? flatIdentifiers : [identifiers]).map(id =>
                engine && typeof engine.getCanonicalPlayerId === 'function'
                    ? engine.getCanonicalPlayerId(id)
                    : id
            );

            const displayName = canonicalIds.map(id =>
                engine && typeof engine.getDisplayName === 'function'
                    ? engine.getDisplayName(id)
                    : normalizeHandSharingDisplay(id)
            ).join(' / ');

            return {
                displayName,
                canonicalIds
            };
        }

        // Parse URL parameters with proper handling of hand sharing partnerships
        function parseURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            let player = urlParams.get('player');
            
            // Additional normalization: trim extra whitespace
            if (player) {
                player = player.trim();
            }
            
            return {
                year: urlParams.get('year'),
                player: player
            };
        }

        const TRICK_WARNING_STORAGE_KEY = 'whist_hide_trick_mismatch_warning';

        function shouldDisplayTrickWarnings() {
            if (typeof window !== 'undefined' && window.TournamentUIConfig && window.TournamentUIConfig.showTrickImbalanceWarnings === false) {
                return false;
            }
            if (typeof window === 'undefined' || typeof window.localStorage === 'undefined') {
                return true;
            }
            try {
                return localStorage.getItem(TRICK_WARNING_STORAGE_KEY) !== 'true';
            } catch (error) {
                console.warn('Unable to read trick warning preference from localStorage:', error);
                return true;
            }
        }

        function summarizeTrickMismatchIssues(issues) {
            const tableMap = new Map();
            const roundSet = new Set();

            issues.forEach(issue => {
                const tournamentLabel = issue.tournament || issue.tournamentId || (issue.year ? `Year ${issue.year}` : 'Tournament');
                const roundLabel = typeof issue.round === 'number' ? issue.round : 'Unknown';
                const tableLabel = typeof issue.table === 'number' ? issue.table : 'Unknown';
                const roundKey = `${tournamentLabel}::${roundLabel}`;
                const tableKey = `${roundKey}::${tableLabel}`;

                roundSet.add(roundKey);
                if (!tableMap.has(tableKey)) {
                    tableMap.set(tableKey, {
                        tournament: tournamentLabel,
                        round: roundLabel,
                        table: tableLabel,
                        total: Number.isFinite(issue.actual) ? issue.actual : issue.actual || 'Unknown'
                    });
                }
            });

            return {
                totalRounds: roundSet.size,
                totalTables: tableMap.size,
                samples: Array.from(tableMap.values())
            };
        }

        function attachTrickWarningDismissHandler(banner) {
            const dismissButton = banner.querySelector('[data-dismiss-trick-warning]');
            if (!dismissButton) {
                return;
            }

            dismissButton.addEventListener('click', () => {
                try {
                    localStorage.setItem(TRICK_WARNING_STORAGE_KEY, 'true');
                } catch (error) {
                    console.warn('Unable to persist trick warning preference:', error);
                }

                const warningBlock = banner.querySelector('.data-issues-banner__warning');
                if (warningBlock) {
                    warningBlock.remove();
                }

                const hasErrors = banner.querySelector('.data-issues-banner__errors');
                if (!hasErrors) {
                    banner.style.display = 'none';
                    banner.innerHTML = '';
                }
            }, { once: true });
        }

        function renderDataIssuesBanner(dataIssuesSummary) {
            const banner = document.getElementById('data-issues-banner');
            if (!banner) return;

            const issues = dataIssuesSummary && Array.isArray(dataIssuesSummary.issues)
                ? dataIssuesSummary.issues
                : null;

            if (!issues) {
                banner.style.display = 'none';
                banner.innerHTML = '';
                return;
            }

            const errorIssues = issues.filter(issue => issue.severity === 'error');
            const trickWarnings = shouldDisplayTrickWarnings()
                ? issues.filter(issue => issue.type === 'trick_count_mismatch')
                : [];

            if (errorIssues.length === 0 && trickWarnings.length === 0) {
                banner.style.display = 'none';
                banner.innerHTML = '';
                return;
            }

            let bannerSections = '';

            if (errorIssues.length > 0) {
                const issueList = errorIssues.map(issue => {
                    const location = issue.sheet ? `${issue.sheet}${issue.row ? ` (Row ${issue.row})` : ''}` : '';
                    const message = issue.message || issue.details || 'An unknown data error occurred.';
                    return `<li>${location ? `<strong>${location}:</strong> ` : ''}${message}</li>`;
                }).join('');

                bannerSections += `
                    <div class="data-issues-banner__errors">
                        <strong>Data Import Errors Detected</strong>
                        <ul>${issueList}</ul>
                    </div>
                `;
            }

            if (trickWarnings.length > 0) {
                const summary = summarizeTrickMismatchIssues(trickWarnings);
                const warningItems = summary.samples.slice(0, 3).map(entry => {
                    return `<li>${entry.tournament} ¬∑ Round ${entry.round}, Table ${entry.table} (reported total: ${entry.total})</li>`;
                }).join('');

                bannerSections += `
                    <div class="data-issues-banner__warning">
                        <div class="data-issues-banner__warning-header">
                            <strong>Trick totals look unbalanced</strong>
                            <span class="data-issues-banner__pill">${summary.totalTables} table${summary.totalTables === 1 ? '' : 's'}</span>
                            <span class="data-issues-banner__pill">${summary.totalRounds} round${summary.totalRounds === 1 ? '' : 's'}</span>
                        </div>
                        <p>Each table should total 13 tricks. Historical data currently shows ${summary.totalTables} table${summary.totalTables === 1 ? '' : 's'} across ${summary.totalRounds} round${summary.totalRounds === 1 ? '' : 's'} where the totals differ.</p>
                        ${warningItems ? `<ul class="data-issues-banner__warning-list">${warningItems}</ul>` : ''}
                        <button type="button" class="data-issues-banner__dismiss" data-dismiss-trick-warning>
                            Hide trick mismatch warning
                        </button>
                    </div>
                `;
            }

            banner.innerHTML = `<div class="data-issues-banner__content">${bannerSections}</div>`;
            banner.style.display = 'block';
            attachTrickWarningDismissHandler(banner);
        }

        // Initialize scorecard page
        document.addEventListener('DOMContentLoaded', function() {
            initializeScorecardPage();
        });

        async function initializeScorecardPage() {
            let engine;
            try {
                const params = parseURLParameters();
                
                if (!params.year || !params.player) {
                    throw new Error('Missing year or player parameter in URL');
                }

                console.log(`üé¥ Loading scorecard for ${params.player} in ${params.year}`);

                // Update page elements
                document.getElementById('page-title').textContent = `${params.player} - ${params.year} Tournament Scorecard`;
                document.getElementById('photo-path').textContent = `tournaments/${params.year}/${params.player.toLowerCase().replace(/\s+/g, '-')}/`;

                // Load tournament data
                engine = new TournamentEngine();
                const sheetId = '1HGfdlDOfGHOL6Q4MP_TnF8UNE6YihBW-5gQs6Ykl78k';
                
                await engine.loadFromGoogleSheets(sheetId);
                renderDataIssuesBanner(engine.getDataIssues());
                
                // Find tournament and player
                const tournaments = Array.from(engine.tournaments.values());
                const tournament = tournaments.find(t => t.year.toString() === params.year);
                
                if (!tournament) {
                    throw new Error(`Tournament for year ${params.year} not found`);
                }

                // Debug: log all players in final_standings
                console.log('üìã All players in final_standings:');
                tournament.final_standings.forEach((s, idx) => {
                    console.log(`  ${idx + 1}. "${s.player}" (is_partnership: ${s.is_partnership}, partnership_players: ${s.partnership_players})`);
                });
                console.log(`üîç Searching for: "${params.player}"`);

                // Resolve the requested entry. Prefer individual lookup; if not found and this is a shared-hand query, resolve the partnership standing.
                let playerStanding = engine.getIndividualPlayerData(tournament, params.player);

                if (!playerStanding && isHandSharingPartnership(params.player)) {
                    // Attempt to locate the partnership entry in final standings via canonical IDs
                    const searchIds = params.player
                        .split(/[\/+&]/)
                        .map(n => engine.getCanonicalPlayerId(n.trim()))
                        .sort();
                    
                    console.log('üîé Shared-hand search canonical IDs:', searchIds);

                    const partnershipStanding = tournament.final_standings.find(s => 
                        s.is_partnership &&
                        Array.isArray(s.partnership_players) &&
                        s.partnership_players.length === searchIds.length &&
                        s.partnership_players.slice().sort().every((id, idx) => id.toLowerCase() === searchIds[idx].toLowerCase())
                    );

                    if (partnershipStanding) {
                        // Adapt partnership standing to the structure expected by generatePlayerScorecard
                        playerStanding = {
                            player: partnershipStanding.player,
                            total_tricks: partnershipStanding.total_tricks,
                            rounds_played: partnershipStanding.rounds_played,
                            average_tricks: partnershipStanding.average_tricks,
                            individual_tricks: partnershipStanding.individual_tricks || 0,
                            shared_tricks: partnershipStanding.shared_tricks || 0,
                            individual_rounds: partnershipStanding.individual_rounds || 0,
                            shared_rounds: partnershipStanding.shared_rounds || 0,
                            position: partnershipStanding.position,
                            is_partnership_member: true,
                            partnership_name: partnershipStanding.player,
                            partnership_players: partnershipStanding.partnership_players
                        };
                        console.log('‚úÖ Partnership standing resolved for scorecard:', playerStanding);
                    } 
                }

                if (!playerStanding) {
                    throw new Error(`Player ${params.player} not found in ${params.year} tournament`);
                }

                // Generate scorecard
                await generatePlayerScorecard(tournament, playerStanding, params, engine);

                // Try to load photos
                await loadScorecardPhotos(params.year, params.player.toLowerCase().replace(/\s+/g, '-'));

                // Hide loading, show content
                document.getElementById('loading-section').style.display = 'none';
                document.getElementById('scorecard-content').style.display = 'block';

            } catch (error) {
                console.error('Error loading scorecard:', error);
                if (engine && typeof engine.getDataIssues === 'function') {
                    renderDataIssuesBanner(engine.getDataIssues());
                } else {
                    renderDataIssuesBanner(null);
                }
                showError(error.message);
            }
        }

        async function generatePlayerScorecard(tournament, playerStanding, params, engine) {
            const playerName = playerStanding.player;
            const canonicalChartIdentifier = normalizeHandSharingDisplay(
                playerStanding.is_partnership_member && playerStanding.partnership_name 
                    ? playerStanding.partnership_name 
                    : playerName
            );

            let displayIdentity;
            if (playerStanding.is_partnership_member && Array.isArray(playerStanding.partnership_players) && playerStanding.partnership_players.length > 0) {
                displayIdentity = buildCombinedIdentity(playerStanding.partnership_players, engine);
            } else {
                displayIdentity = resolvePlayerIdentity(playerName, engine);
            }

            const displayName = displayIdentity.displayName || playerName;
            const playerNameEl = document.getElementById('player-name');

            // Try to show a single ‚Äúoriginal scorecard scan‚Äù link if present in R2:
            // - Single player: YYYY_Key.jpg
            // - Shared hand: YYYY_Key1_Key2.jpg (underscore-delimited Keys)
            renderPlayerScorecardScanLink(params.year, displayIdentity.canonicalIds);

            const escapeHtmlText = (value) => String(value ?? '')
                .replaceAll('&', '&amp;')
                .replaceAll('<', '&lt;')
                .replaceAll('>', '&gt;')
                .replaceAll('"', '&quot;')
                .replaceAll("'", '&#39;');

            const renderPlayerLink = (id, label) => {
                if (!id || !label) {
                    return label || id || '';
                }
                return `<a href="../players/profile.html?player=${encodeURIComponent(id)}" class="player-name-link">${label}</a>`;
            };

            const renderPlayerLinks = (identifiers) => {
                const ids = splitSharedIdentifiers(identifiers);
                const canonicalIds = ids.map(id =>
                    engine && typeof engine.getCanonicalPlayerId === 'function'
                        ? engine.getCanonicalPlayerId(id)
                        : id
                );
                return canonicalIds
                    .map(id => renderPlayerLink(id, engine.getDisplayName(id)))
                    .join(' / ');
            };

            if (playerStanding.is_partnership_member && Array.isArray(playerStanding.partnership_players) && playerStanding.partnership_players.length > 0) {
                playerNameEl.innerHTML = renderPlayerLinks(playerStanding.partnership_players);
            } else {
                playerNameEl.innerHTML = renderPlayerLinks(playerName);
            }

            // Extra obvious CTA to the player's profile (in case the name link is missed).
            const actionsEl = document.getElementById('player-profile-actions');
            if (actionsEl) {
                const ids = Array.isArray(displayIdentity?.canonicalIds) ? displayIdentity.canonicalIds.filter(Boolean) : [];
                const uniqueIds = Array.from(new Set(ids));

                if (uniqueIds.length === 1) {
                    const id = uniqueIds[0];
                    actionsEl.innerHTML = `
                        <a class="player-action-btn" href="../players/profile.html?player=${encodeURIComponent(id)}">See player profile</a>
                    `;
                } else if (uniqueIds.length > 1) {
                    actionsEl.innerHTML = uniqueIds.map(id => {
                        const label = engine && typeof engine.getDisplayName === 'function' ? engine.getDisplayName(id) : id;
                        return `<a class="player-action-btn" href="../players/profile.html?player=${encodeURIComponent(id)}">See ${escapeHtmlText(label)} profile</a>`;
                    }).join('');
                } else {
                    actionsEl.innerHTML = '';
                }
            }

            const chartLabelEl = document.getElementById('chart-player-name');
            if (chartLabelEl) {
                chartLabelEl.textContent = formatPossessiveName(displayName);
            }
            
            // Show partnership information if applicable with friendly names
            let contextText = `${tournament.name} ‚Ä¢ ${tournament.year}`;
            let partnershipFriendlyName = null;
            if (playerStanding.is_partnership_member && Array.isArray(playerStanding.partnership_players) && playerStanding.partnership_players.length > 0) {
                partnershipFriendlyName = displayName;
            } else if (isHandSharingPartnership(params.player)) {
                const sharedIdentity = buildCombinedIdentity(
                    params.player.split(/[\/+&]/).map(name => name.trim()),
                    engine
                );
                partnershipFriendlyName = sharedIdentity.displayName;
            }
            if (partnershipFriendlyName) {
                contextText += ` ‚Ä¢ Hand sharing partnership: ${partnershipFriendlyName}`;
            }
            document.getElementById('tournament-context').textContent = contextText;
            
            // Update back link  
            document.getElementById('back-to-tournament').href = `../tournaments/results.html?year=${encodeURIComponent(params.year)}`;
            
            // Update rank and performance
            const rankText = playerStanding.position === 1 ? 'üèÜ Champion' : 
                           playerStanding.position === 2 ? 'ü•à Runner-up' :
                           playerStanding.position === 3 ? 'ü•â Third Place' :
                           `#${playerStanding.position}`;
            
            document.getElementById('player-rank').textContent = rankText;
            
            // Update performance summary with partnership info
            let performanceText = `${playerStanding.total_tricks} tricks in ${playerStanding.rounds_played} rounds`;
            if (playerStanding.is_partnership_member || isHandSharingPartnership(params.player)) {
                performanceText += ` (as hand sharing partnership)`;
            }
            document.getElementById('performance-summary').textContent = performanceText;

            // Update summary stats
            document.getElementById('total-tricks').textContent = playerStanding.total_tricks;
            document.getElementById('average-tricks').textContent = playerStanding.average_tricks;
            document.getElementById('rounds-played').textContent = playerStanding.rounds_played;

            // Get player's individual rounds - use original searched name, not partnership name
            const searchedPlayerName = params.player; // The name they searched for (e.g., "Paul")
            const playerRounds = getPlayerRounds(tournament, searchedPlayerName, engine);
            let cumulativeTotal = 0;
            playerRounds.forEach(round => {
                cumulativeTotal += round.tricks;
                round.cumulativeTotal = cumulativeTotal;
            });
            const maxTricks = Math.max(...playerRounds.map(r => r.tricks));
            
            // Count how many times they achieved the maximum
            const maxTricksCount = playerRounds.filter(r => r.tricks === maxTricks).length;
            
            // Display with count if achieved more than once
            let mostTricksText = maxTricks.toString();
            if (maxTricksCount > 1) {
                mostTricksText += ` (x${maxTricksCount})`;
            }
            
            document.getElementById('best-round').textContent = mostTricksText;

            // Generate scorecard table
            generateScorecardTable(playerRounds, params.year);
            
            // Create rank progression chart (use canonical identifier for highlighting)
            createRankProgressionChart(tournament, canonicalChartIdentifier, displayName, 0, engine);
        }

        function renderPlayerScorecardScanLink(year, canonicalIds) {
            const wrap = document.getElementById('player-scorecard-scan');
            if (!wrap) return;
            wrap.innerHTML = '';

            const ids = Array.isArray(canonicalIds) ? canonicalIds.filter(Boolean) : [];
            if (!year || ids.length === 0) return;
            if (!(window.WhistMedia && typeof window.WhistMedia.playerScorecardUrl === 'function')) return;

            const unique = Array.from(new Set(ids.map(x => String(x).trim()).filter(Boolean)));
            const candidates = [];
            if (unique.length === 1) {
                candidates.push(unique[0]);
            } else {
                const asGiven = unique.join('_');
                const sorted = unique.slice().sort((a, b) => a.localeCompare(b)).join('_');
                candidates.push(asGiven);
                if (sorted !== asGiven) candidates.push(sorted);
            }

            const note = document.createElement('div');
            note.style.color = '#475569';
            note.style.fontSize = '0.9rem';
            note.style.marginBottom = '0.4rem';
            note.textContent = 'Original scorecard scan (if uploaded):';

            const link = document.createElement('a');
            link.className = 'btn btn-secondary';
            link.style.display = 'inline-flex';
            link.style.alignItems = 'center';
            link.style.gap = '0.5rem';
            link.target = '_blank';
            link.rel = 'noopener';
            link.href = '#';
            link.textContent = 'View original scan';

            const meta = document.createElement('div');
            meta.style.color = '#64748b';
            meta.style.fontSize = '0.85rem';
            meta.style.marginTop = '0.35rem';
            meta.textContent = `Expected file: ${year}_${candidates[0]}.jpeg`;

            const muted = document.createElement('div');
            muted.style.color = '#64748b';
            muted.style.fontSize = '0.85rem';
            muted.style.fontStyle = 'italic';
            muted.textContent = 'No original scan uploaded yet.';

            wrap.appendChild(note);
            wrap.appendChild(link);
            wrap.appendChild(meta);

            const tryCandidate = async (idx) => {
                if (idx >= candidates.length) {
                    // Hide the button if none load.
                    link.style.display = 'none';
                    meta.style.display = 'none';
                    wrap.appendChild(muted);
                    return;
                }
                const key = candidates[idx];
                const url = await window.WhistMedia.playerScorecardUrl(year, key);
                if (!url) return tryCandidate(idx + 1);

                // Use image load test (avoids CORS issues vs fetch/HEAD).
                const img = new Image();
                img.onload = () => {
                    link.href = url;
                    meta.textContent = `Stored as: player-scorecards/${year}/${year}_${key}.jpg`;
                };
                img.onerror = () => tryCandidate(idx + 1);
                img.src = `${url}${url.includes('?') ? '&' : '?'}probe=${Date.now()}`;
            };

            tryCandidate(0);
        }

        function getPlayerRounds(tournament, playerName, engine) {
            const playerRounds = [];

            console.log(`üîç Looking for rounds for player: "${playerName}"`);

            // Check if searching for a shared hand (support '/', '+', '&')
            const isSharedHandSearch = /[\/+&]/.test(playerName);
            const getInconsistencyForViewer = (partnership) => {
                const mapping = partnership && (partnership.inconsistencyByPlayer || partnership.inconsistency_by_player);
                if (!mapping) {
                    // Fallback for WhistGame_* sheets where inconsistency applies to the game
                    return (partnership && (partnership.inconsistency || partnership.Inconsistency) ? (partnership.inconsistency || partnership.Inconsistency) : '').toString().trim();
                }

                const ids = isSharedHandSearch
                    ? playerName.split(/[\/+&]/).map(n => engine.getCanonicalPlayerId(n.trim())).filter(Boolean)
                    : [engine.getCanonicalPlayerId(playerName)].filter(Boolean);

                const notes = [];
                for (const id of ids) {
                    const target = id.toLowerCase();
                    for (const key of Object.keys(mapping)) {
                        if (key.toLowerCase() === target) {
                            const note = (mapping[key] || '').toString().trim();
                            if (note) {
                                notes.push(note);
                            }
                        }
                    }
                }

                return Array.from(new Set(notes)).join(' | ');
            };

            for (const round of tournament.rounds) {
                let foundInRound = false;
                for (const table of round.tables) {
                    for (const partnership of table.partnerships) {
                        // partnership now has position1 and position2 arrays
                        console.log(`  Round ${round.round}, Table ${table.table}: pos1=[${partnership.position1.join(', ')}] pos2=[${partnership.position2.join(', ')}]`);
                        
                        let playerMatch = false;
                        let partnerPosition = null; // Which position (1 or 2) this player is in
                        let matchedPosition = null; // The actual position array that matched

                        if (isSharedHandSearch) {
                            // Searching for a shared hand like "David/Jennifer" (also supports "David+Jennifer" or "David & Jennifer")
                            // Extract canonical IDs from search using the tournament engine for reliable matching
                            const searchIds = playerName
                                .split(/[\/+&]/)
                                .map(n => engine.getCanonicalPlayerId(n.trim()))
                                .sort();

                            // Check if position1 matches
                            const pos1Sorted = [...partnership.position1].sort();
                            const matchesPos1 = searchIds.length === pos1Sorted.length &&
                                              searchIds.every((id, idx) => id.toLowerCase() === pos1Sorted[idx].toLowerCase());

                            // Check if position2 matches
                            const pos2Sorted = [...partnership.position2].sort();
                            const matchesPos2 = searchIds.length === pos2Sorted.length &&
                                              searchIds.every((id, idx) => id.toLowerCase() === pos2Sorted[idx].toLowerCase());

                            if (matchesPos1) {
                                playerMatch = true;
                                playerPosition = 1;
                                matchedPosition = partnership.position1;
                            } else if (matchesPos2) {
                                playerMatch = true;
                                playerPosition = 2;
                                matchedPosition = partnership.position2;
                            }
                        } else {
                            // Searching for individual player - check if they're in either position
                            // Normalize to canonical ID for matching
                            const searchIdLower = engine.getCanonicalPlayerId(playerName).toLowerCase();

                            if (partnership.position1.some(id => id.toLowerCase() === searchIdLower)) {
                                playerMatch = true;
                                playerPosition = 1;
                                matchedPosition = partnership.position1;
                            } else if (partnership.position2.some(id => id.toLowerCase() === searchIdLower)) {
                                playerMatch = true;
                                playerPosition = 2;
                                matchedPosition = partnership.position2;
                            }
                        }

                        if (playerMatch) {
                            // Get the partner position (the OTHER position in this partnership)
                            const partnerPositionArray = playerPosition === 1 ? partnership.position2 : partnership.position1;

                            // Create display data for partner(s)
                            const partnerDetails = partnerPositionArray.flatMap(rawId => {
                                const expandedIds = splitSharedIdentifiers(rawId);
                                if (expandedIds.length === 0) {
                                    return [{
                                        id: rawId,
                                        displayName: engine.getDisplayName(rawId)
                                    }];
                                }
                                return expandedIds.map(id => {
                                    const canonicalId = engine.getCanonicalPlayerId ? engine.getCanonicalPlayerId(id) : id;
                                    return {
                                        id: canonicalId,
                                        displayName: engine.getDisplayName(canonicalId)
                                    };
                                });
                            });
                            const partnerName = partnerDetails.length > 1
                                ? partnerDetails.map(p => p.displayName).join('/')
                                : partnerDetails[0]?.displayName;

                            console.log(`    ‚úì Match found in position ${playerPosition}! Partner: ${partnerName}`);

                            // Find opponent partnership (the other partnership at this table)
                            let actualOpponentTricks = 13 - partnership.tricks; // Default fallback
                            let opponentGroups = [];

                            for (const otherPartnership of table.partnerships) {
                                if (otherPartnership !== partnership) {
                                    // This is the opponent partnership
                                    actualOpponentTricks = otherPartnership.tricks;
                                    opponentGroups = [
                                        Array.isArray(otherPartnership.position1) ? otherPartnership.position1.flatMap(rawId => {
                                            const expandedIds = splitSharedIdentifiers(rawId);
                                            if (expandedIds.length === 0) {
                                                const canonicalId = engine.getCanonicalPlayerId ? engine.getCanonicalPlayerId(rawId) : rawId;
                                                return [{
                                                    id: canonicalId,
                                                    displayName: engine.getDisplayName(canonicalId)
                                                }];
                                            }
                                            return expandedIds.map(id => {
                                                const canonicalId = engine.getCanonicalPlayerId ? engine.getCanonicalPlayerId(id) : id;
                                                return {
                                                    id: canonicalId,
                                                    displayName: engine.getDisplayName(canonicalId)
                                                };
                                            });
                                        }) : [],
                                        Array.isArray(otherPartnership.position2) ? otherPartnership.position2.flatMap(rawId => {
                                            const expandedIds = splitSharedIdentifiers(rawId);
                                            if (expandedIds.length === 0) {
                                                const canonicalId = engine.getCanonicalPlayerId ? engine.getCanonicalPlayerId(rawId) : rawId;
                                                return [{
                                                    id: canonicalId,
                                                    displayName: engine.getDisplayName(canonicalId)
                                                }];
                                            }
                                            return expandedIds.map(id => {
                                                const canonicalId = engine.getCanonicalPlayerId ? engine.getCanonicalPlayerId(id) : id;
                                                return {
                                                    id: canonicalId,
                                                    displayName: engine.getDisplayName(canonicalId)
                                                };
                                            });
                                        }) : []
                                    ].filter(group => group.length > 0);
                                    break; // Only one other partnership per table
                                }
                            }

                            // Check for data quality issues
                            const totalTricks = partnership.tricks + actualOpponentTricks;
                            const isDataError = totalTricks !== 13;

                            playerRounds.push({
                                round: round.round,
                                trump: partnership.trump_suit || round.trump_suit,
                                table: table.table,
                                partner: partnerName,
                                partnerDetails,
                                opponentGroups,
                                tricks: partnership.tricks,
                                opponentTricks: actualOpponentTricks,
                                totalTricks: totalTricks,
                                isDataError: isDataError,
                                won: partnership.tricks > 6,
                                inconsistency: getInconsistencyForViewer(partnership)
                            });
                            foundInRound = true;
                            break;
                        }
                    }
                    if (foundInRound) break;
                }
                if (!foundInRound) {
                    console.log(`  ‚ùå Player "${playerName}" not found in round ${round.round}`);
                }
            }
            
            console.log(`üéØ Found ${playerRounds.length} rounds for ${playerName}`);
            return playerRounds.sort((a, b) => a.round - b.round);
        }

        function generateScorecardTable(playerRounds, tournamentYear) {
            const tbody = document.getElementById('scorecard-body');
            const yearParam = tournamentYear || '';

            const scorecardHrefForPlayer = (id) => {
                // Link to that player's scorecard for this same tournament year.
                return `scorecard.html?year=${encodeURIComponent(yearParam)}&player=${encodeURIComponent(id)}`;
            };

            const escapeHtmlAttribute = (value) => {
                if (value === null || value === undefined) {
                    return '';
                }
                return value
                    .toString()
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            };
            
            const html = playerRounds.map(round => {
                const resultClass = round.won ? 'result-win' : 'result-loss';
                const resultText = round.won ? 'WIN' : 'LOSS';
                const trumpSymbol = getTrumpSymbol(round.trump);
                
                // Add bold class for majority wins (7+ tricks)
                const ourTricksClass = round.tricks >= 7 ? 'our-tricks tricks-majority' : 'our-tricks';
                const theirTricksClass = round.opponentTricks >= 7 ? 'their-tricks tricks-majority' : 'their-tricks';

                // Add data error highlighting
                let rowClass = round.isDataError ? 'round-row data-error' : 'round-row';
                if (round.inconsistency) {
                    rowClass += ' data-inconsistency';
                }
                const errorWarning = round.isDataError ? 
                    `<span class="data-error-icon" title="Data error: Total tricks = ${round.totalTricks} (should be 13)">‚ö†Ô∏è</span>` : '';

                // Inconsistency tooltip: Safari doesn't reliably show title tooltips on <tr>, so attach to a <span>.
                const inconsistencyTooltip = round.inconsistency ? escapeHtmlAttribute(round.inconsistency) : '';
                const inconsistencyIndicator = round.inconsistency
                    ? `<span class="inconsistency-indicator" data-tooltip="${inconsistencyTooltip}" tabindex="0" aria-label="Inconsistency comment">üí¨</span>`
                    : '';

                return `
                    <tr class="${rowClass} ${resultClass}">
                        <td class="round-number">${round.round}${errorWarning}</td>
                        <td class="trump-suit">
                            <span class="trump-symbol ${round.trump.toLowerCase()}">${trumpSymbol}</span>
                        </td>
                        <td class="table-number">${round.table}</td>
                        <td class="scan-cell">
                            <a href="#" class="scan-btn" data-year="${escapeHtmlAttribute(yearParam)}" data-round="${escapeHtmlAttribute(round.round)}" data-table="${escapeHtmlAttribute(round.table)}" aria-label="View original scan for round ${escapeHtmlAttribute(round.round)} table ${escapeHtmlAttribute(round.table)}">üì∑</a>
                        </td>
                        <td class="partner-name">
                            ${Array.isArray(round.partnerDetails) && round.partnerDetails.length > 0
                                ? round.partnerDetails.map(partner => 
                                    `<a href="${scorecardHrefForPlayer(partner.id)}" class="player-name-link">${partner.displayName}</a>`
                                  ).join(' / ')
                                : (round.partner && round.partner !== 'Unknown'
                                    ? `<a href="${scorecardHrefForPlayer(round.partner)}" class="player-name-link">${round.partner}</a>`
                                    : 'Unknown')
                            }
                        </td>
                        <td class="${ourTricksClass}">
                            <span class="tricks-cell-content">
                                ${inconsistencyIndicator}
                                <span class="tricks-value">${round.tricks}</span>
                            </span>
                        </td>
                        <td class="${theirTricksClass}">${round.opponentTricks}</td>
                        <td class="opponents-names">
                            ${Array.isArray(round.opponentGroups) && round.opponentGroups.length > 0
                                ? round.opponentGroups.map(group => 
                                    group.map(opponent => 
                                        `<a href="${scorecardHrefForPlayer(opponent.id)}" class="player-name-link">${opponent.displayName}</a>`
                                    ).join(' / ')
                                ).join(' & ')
                                : 'Unknown'}
                        </td>
                        <td class="result ${resultClass}">${resultText}</td>
                        <td class="cumulative-total">${round.cumulativeTotal}</td>
                    </tr>
                `;
            }).join('');

            tbody.innerHTML = html;

            // Round/table scan link handler (lazy probe + graceful fallback).
            if (tbody && !tbody.dataset.scanLinkInit) {
                tbody.dataset.scanLinkInit = 'true';
                tbody.addEventListener('click', async (e) => {
                    const a = e.target && e.target.closest ? e.target.closest('.scan-btn') : null;
                    if (!a) return;
                    e.preventDefault();
                    e.stopPropagation();

                    if (!(window.WhistMedia && typeof window.WhistMedia.scorecardScanUrl === 'function')) {
                        alert('Scan viewer is not available (media config not loaded).');
                        return;
                    }

                    const year = a.getAttribute('data-year') || '';
                    const round = a.getAttribute('data-round') || '';
                    const table = a.getAttribute('data-table') || '';
                    if (!year || !round || !table) return;

                    a.textContent = '‚è≥';
                    a.setAttribute('aria-busy', 'true');

                    try {
                        const url = await window.WhistMedia.scorecardScanUrl(year, round, table);
                        if (!url) throw new Error('No media base URL configured');

                        const img = new Image();
                        img.onload = () => {
                            a.textContent = 'üì∑';
                            a.removeAttribute('aria-busy');
                            window.open(url, '_blank', 'noopener');
                        };
                        img.onerror = () => {
                            a.textContent = 'üì∑';
                            a.removeAttribute('aria-busy');
                            alert(`No scan uploaded yet for ${year} round ${round}, table ${table}.`);
                        };
                        img.src = `${url}${url.includes('?') ? '&' : '?'}probe=${Date.now()}`;
                    } catch (err) {
                        a.textContent = 'üì∑';
                        a.removeAttribute('aria-busy');
                        alert(err && err.message ? err.message : 'Unable to load scan.');
                    }
                });
            }

            // Click-to-toggle tooltip (useful on touch devices / when hover tooltips are disabled).
            if (tbody && !tbody.dataset.inconsistencyTooltipInit) {
                tbody.dataset.inconsistencyTooltipInit = 'true';

                const closeAllTooltips = () => {
                    tbody.querySelectorAll('.inconsistency-indicator.tooltip-open')
                        .forEach(el => el.classList.remove('tooltip-open'));
                };

                tbody.addEventListener('click', (e) => {
                    const indicator = e.target && e.target.closest ? e.target.closest('.inconsistency-indicator') : null;
                    if (!indicator) {
                        closeAllTooltips();
                        return;
                    }
                    e.preventDefault();
                    e.stopPropagation();
                    const isOpen = indicator.classList.contains('tooltip-open');
                    closeAllTooltips();
                    if (!isOpen) {
                        indicator.classList.add('tooltip-open');
                    }
                });

                document.addEventListener('click', () => closeAllTooltips());
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        closeAllTooltips();
                    }
                });
            }
            
            // Show summary if there are data errors
            const errorCount = playerRounds.filter(round => round.isDataError).length;
            if (errorCount > 0) {
                const summaryElement = document.getElementById('data-error-summary');
                if (summaryElement) {
                    summaryElement.innerHTML = `
                        <div class="data-error-banner">
                            ‚ö†Ô∏è <strong>Data Quality Warning:</strong> ${errorCount} round${errorCount === 1 ? '' : 's'} 
                            ${errorCount === 1 ? 'has' : 'have'} trick counts that don't add up to 13. 
                            These may be data entry errors from the original scorecards.
                        </div>
                    `;
                    summaryElement.style.display = 'block';
                }
            }
        }

        function getTrumpSymbol(suit) {
            const symbols = {
                'Hearts': '‚ô•',
                'Diamonds': '‚ô¶',
                'Spades': '‚ô†',
                'Clubs': '‚ô£'
            };
            return symbols[suit] || 'üé¥';
        }

        async function loadScorecardPhotos(year, playerSlug) {
            try {
                const gallery = new PhotoGallery();
                const photosPath = `tournaments/${year}/${playerSlug}`;
                
                // Try to load photos from the player's folder
                await gallery.loadPlayerScorecardPhotos(year, playerSlug);
                gallery.createScorecardPhotosHTML(photosPath, '#scorecard-photos');
            } catch (error) {
                console.log('No scorecard photos found for this player');
                document.getElementById('scorecard-photos').innerHTML = 
                    '<p style="color: #666; font-style: italic;">No scorecard photos uploaded yet.</p>';
            }
        }

        function showError(message) {
            document.getElementById('loading-section').style.display = 'none';
            document.getElementById('error-section').style.display = 'block';
            document.getElementById('error-message').textContent = message;
        }

        function createRankProgressionChart(tournament, playerName, displayNameForUi = null, retryCount = 0, engineInstance = null) {
            console.log(`üéØ createRankProgressionChart called for player: ${playerName} (attempt ${retryCount + 1})`);
            console.log('üìã Tournament data:', tournament);
            
            if (displayNameForUi) {
                const chartLabelEl = document.getElementById('chart-player-name');
                if (chartLabelEl) {
                    chartLabelEl.textContent = formatPossessiveName(displayNameForUi);
                }
            }
            
            try {
                // Wait for libraries to load with timeout
                if (typeof Chart === 'undefined' || typeof TournamentCharts === 'undefined') {
                    if (retryCount < 10) { // Max 10 retries = 5 seconds
                        console.log(`‚è≥ Waiting for Chart.js and TournamentCharts to load... (attempt ${retryCount + 1}/10)`);
                        setTimeout(() => createRankProgressionChart(tournament, playerName, displayNameForUi, retryCount + 1, engineInstance), 500);
                        return;
                    } else {
                        console.error('‚ùå Chart.js failed to load after 5 seconds. Hiding chart section.');
                        const chartSection = document.querySelector('.chart-section');
                        if (chartSection) {
                            chartSection.style.display = 'none';
                        }
                        return;
                    }
                }
                
                console.log('‚úÖ Libraries loaded, creating chart...');
                
                // Initialize charts instance
                const charts = new TournamentCharts();
                
                // Create the rank progression chart with player highlighting
                charts.createRankProgressChart('rank-progression-chart', tournament, playerName, engineInstance);
                
                console.log(`‚úÖ Created rank progression chart for ${playerName}`);
            } catch (error) {
                console.error('‚ùå Error creating rank progression chart:', error);
                console.error(error.stack);
                // Hide the chart section if there's an error
                const chartSection = document.querySelector('.chart-section');
                if (chartSection) {
                    chartSection.style.display = 'none';
                }
            }
        }
    </script>

    <style>
        /* Loading and Error States */
        .loading-section, .error-section {
            padding: var(--spacing-3xl) 0;
            text-align: center;
        }

        .loading-spinner {
            font-size: 4rem;
            animation: spin 2s linear infinite;
            margin-bottom: var(--spacing-lg);
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .error-icon {
            font-size: 4rem;
            margin-bottom: var(--spacing-lg);
        }

        /* Player Header */
        .player-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: var(--spacing-2xl) 0;
            margin-bottom: var(--spacing-2xl);
        }

        .player-info {
            text-align: center;
        }

        .player-nav-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--spacing-md);
            flex-wrap: wrap;
            margin-bottom: var(--spacing-md);
            padding: 0 0.4rem;
        }

        .back-link {
            margin-bottom: 0;
            flex: 0 0 auto;
        }

        .back-link a {
            display: inline-flex;
            align-items: center;
            padding: 0.55rem 0.95rem;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.22);
            background: rgba(255, 255, 255, 0.10);
            color: rgba(255, 255, 255, 0.92);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 800;
            transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
        }

        .back-link a:hover {
            color: white;
            background: rgba(255, 255, 255, 0.16);
            transform: translateY(-1px);
        }

        .player-name {
            font-size: 3rem;
            font-weight: 900;
            margin-bottom: var(--spacing-sm);
        }

        .tournament-context {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: var(--spacing-lg);
        }

        .player-rank {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .rank-badge {
            background: rgba(255, 255, 255, 0.2);
            padding: var(--spacing-sm) var(--spacing-lg);
            border-radius: var(--border-radius-xl);
            font-size: 1.25rem;
            font-weight: 700;
        }

        .tournament-summary {
            margin-top: var(--spacing-xl);
        }

        .summary-stats {
            display: flex;
            justify-content: center;
            gap: var(--spacing-xl);
            flex-wrap: wrap;
        }

        .summary-stats .stat {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
            min-width: 100px;
        }

        .summary-stats .stat-value {
            display: block;
            font-size: 2rem;
            font-weight: 900;
            margin-bottom: var(--spacing-xs);
        }

        .summary-stats .stat-label {
            font-size: 0.875rem;
            opacity: 0.8;
        }

        /* Scorecard Table */
        .scorecard-section {
            background: white;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-2xl);
            box-shadow: var(--shadow-lg);
            margin-bottom: var(--spacing-2xl);
            color: #1f2937; /* Ensure dark text on white background */
        }

        /* Chart Section */
        .chart-section {
            background: white;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-2xl);
            box-shadow: var(--shadow-lg);
            margin-bottom: var(--spacing-2xl);
            color: #1f2937;
        }

        .chart-description {
            font-size: 1rem;
            color: #6b7280;
            margin-bottom: var(--spacing-xl);
            text-align: center;
        }

        .chart-container {
            position: relative;
            height: 400px;
            margin: var(--spacing-xl) 0;
        }

        .chart-container canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .scorecard-section .section-title {
            color: #1f2937; /* Dark color for section title */
        }

        .scorecard-table-container {
            overflow-x: auto;
        }

        .scorecard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: var(--spacing-lg);
        }

        .scorecard-table th {
            background: var(--primary);
            color: white;
            padding: var(--spacing-md);
            text-align: left;
            font-weight: 600;
        }

        .scorecard-table td {
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--border-light);
            color: #1f2937; /* Ensure dark text in table body */
        }

        .round-row:hover {
            background: rgba(var(--primary-rgb), 0.05);
        }

        .result-win {
            background: rgba(34, 197, 94, 0.1);
        }

        .result-loss {
            background: rgba(239, 68, 68, 0.1);
        }

        .result.result-win {
            color: #059669;
            font-weight: 600;
        }

        .result.result-loss {
            color: #dc2626;
            font-weight: 600;
        }

        .trump-symbol {
            margin-right: var(--spacing-xs);
        }

        .trump-symbol.hearts { color: #dc2626; }
        .trump-symbol.diamonds { color: #dc2626; }
        .trump-symbol.spades { color: #000; }
        .trump-symbol.clubs { color: #000; }

        /* Right-align numerical columns */
        .our-tricks {
            text-align: right;
        }

        /* Right-align the header for Our Tricks column too */
        .scorecard-table th:nth-child(5) {
            text-align: right;
        }

        /* Bold numbers 7 or greater (majority wins) */
        .tricks-majority {
            font-weight: bold;
        }

        /* Photo Section */
        .photo-section {
            background: white;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-2xl);
            box-shadow: var(--shadow-lg);
            color: #1f2937; /* Ensure dark text on white background */
        }

        .photo-section h3 {
            color: #1f2937; /* Dark color for "Scorecard Verification" heading */
            margin-bottom: var(--spacing-lg);
        }

        /* Global section title styling for readability */
        .section-title {
            color: #1f2937 !important; /* Ensure all section titles are dark */
        }

        .photo-upload-info {
            background: #f8f9fa; /* Light gray background */
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            margin-bottom: var(--spacing-xl);
            color: #1f2937; /* Dark text for readability */
        }

        .photo-upload-info p {
            color: #1f2937; /* Ensure paragraph text is dark */
            margin-bottom: var(--spacing-sm);
        }

        .photo-upload-info code {
            background: #2d3748; /* Dark background */
            color: #fbbf24; /* Gold/yellow text for good contrast */
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            font-family: monospace;
            font-weight: 600;
        }

        /* Scorecard Photo Gallery Styles */
        .scorecard-photo-gallery {
            margin-top: var(--spacing-lg);
        }

        .scorecard-photo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--spacing-lg);
            margin-top: var(--spacing-lg);
        }

        .scorecard-photo-card {
            background: white;
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-md);
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .scorecard-photo-card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-xl);
        }

        .scorecard-placeholder {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px dashed #dee2e6;
            position: relative;
        }

        .verification-badge {
            position: absolute;
            top: var(--spacing-sm);
            right: var(--spacing-sm);
            background: var(--accent);
            color: white;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--border-radius-sm);
            font-size: 0.75rem;
            font-weight: 600;
        }

        .scorecard-photo-card .photo-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .scorecard-photo-card:hover .photo-overlay {
            opacity: 1;
        }

        .scorecard-photo-card .photo-view-btn {
            background: white;
            border: none;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-md) var(--spacing-lg);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .scorecard-photo-card .photo-view-btn:hover {
            background: var(--accent);
            color: white;
            transform: scale(1.05);
        }

        /* Lightbox enhancement for scorecard mode */
        .lightbox-overlay.scorecard-mode .lightbox-container {
            max-width: 90vw;
            max-height: 90vh;
        }

        .lightbox-overlay.scorecard-mode .lightbox-info {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: var(--spacing-lg);
        }

        .lightbox-overlay.scorecard-mode .lightbox-title {
            color: var(--accent);
            font-size: 1.5rem;
            margin-bottom: var(--spacing-sm);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .player-name {
                font-size: 2rem;
            }

            .summary-stats {
                gap: var(--spacing-md);
            }

            .summary-stats .stat {
                min-width: 80px;
                padding: var(--spacing-sm);
            }

            .scorecard-table {
                font-size: 0.875rem;
            }

            .scorecard-table th,
            .scorecard-table td {
                padding: var(--spacing-sm);
            }

            .scorecard-photo-grid {
                grid-template-columns: 1fr;
                gap: var(--spacing-md);
            }

            .scorecard-placeholder {
                height: 150px;
            }
        }

        /* Data Error Styling */
        .data-error-banner {
            background: linear-gradient(135deg, #fef3c7 0%, #fbbf24 100%);
            border: 1px solid #f59e0b;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
            color: #92400e;
            font-weight: 500;
            box-shadow: 0 4px 6px -1px rgba(245, 158, 11, 0.1);
        }

        .data-error {
            background-color: #fef3c7 !important;
        }

        .data-error-icon {
            color: #f59e0b;
            margin-left: var(--spacing-xs);
            font-size: 0.875rem;
            cursor: help;
        }

        .round-row.data-error:hover {
            background-color: #fde68a !important;
        }

        .round-row.data-inconsistency {
            border-left: 4px solid #f97316;
            position: relative;
            cursor: help;
        }

        .round-row.data-inconsistency:hover {
            background-color: rgba(249, 115, 22, 0.08);
        }

        .tricks-cell-content {
            display: inline-flex;
            align-items: center;
            justify-content: flex-end;
            gap: 6px;
            width: 100%;
        }

        .tricks-value {
            display: inline-block;
        }

        .inconsistency-indicator {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            line-height: 1;
            color: #f97316;
            cursor: help;
            vertical-align: middle;
            position: relative;
            outline: none;
        }

        /* Tooltip bubble */
        .inconsistency-indicator::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 50%;
            bottom: calc(100% + 10px);
            transform: translateX(-50%);
            background: rgba(17, 24, 39, 0.96);
            color: #fff;
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 0.8rem;
            line-height: 1.25;
            text-align: left;
            white-space: pre-wrap;
            max-width: 360px;
            min-width: 180px;
            width: max-content;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            z-index: 50;
        }

        .inconsistency-indicator::before {
            content: '';
            position: absolute;
            left: 50%;
            bottom: calc(100% + 4px);
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(17, 24, 39, 0.96);
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            z-index: 51;
        }

        .inconsistency-indicator:hover::after,
        .inconsistency-indicator:hover::before,
        .inconsistency-indicator:focus::after,
        .inconsistency-indicator:focus::before,
        .inconsistency-indicator.tooltip-open::after,
        .inconsistency-indicator.tooltip-open::before {
            opacity: 1;
            visibility: visible;
        }

        /* Player name link styles for scorecard */
        .player-name-link {
            color: inherit;
            text-decoration: none;
            transition: all 0.2s ease;
            border-radius: 4px;
            padding: 2px 4px;
            margin: -2px -4px;
        }

        .player-name-link:hover {
            color: var(--primary-color);
            background-color: rgba(79, 70, 229, 0.1);
            text-decoration: none;
        }

        /* Partner and opponent name styling */
        .partner-name .player-name-link,
        .opponents-names .player-name-link {
            color: var(--text-primary-dark);
        }

        .partner-name .player-name-link:hover,
        .opponents-names .player-name-link:hover {
            color: var(--primary-color);
            background-color: rgba(79, 70, 229, 0.1);
        }

        .scan-cell {
            text-align: center;
        }

        .scan-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 999px;
            border: 1px solid rgba(15, 23, 42, 0.14);
            background: rgba(255, 255, 255, 0.85);
            text-decoration: none;
            cursor: pointer;
            transition: transform 0.15s ease, background 0.15s ease, border-color 0.15s ease;
        }

        .scan-btn:hover {
            border-color: rgba(15, 23, 42, 0.22);
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
        }

        /* Header: "See player profile" CTA */
        .player-actions {
            display: flex;
            justify-content: flex-end;
            flex-wrap: wrap;
            gap: 0.6rem;
            margin: 0;
            flex: 1 1 auto;
            padding-right: 0.25rem;
        }

        .player-action-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.55rem 0.95rem;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.24);
            background: rgba(255, 255, 255, 0.16);
            color: rgba(255, 255, 255, 0.96);
            font-weight: 900;
            text-decoration: none;
            white-space: nowrap;
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.18);
        }

        .player-action-btn:hover {
            text-decoration: underline;
            background: rgba(255, 255, 255, 0.22);
        }

        .data-issues-banner {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            border-bottom: 2px solid #ef4444;
            padding: var(--spacing-md) 0;
            box-shadow: 0 4px 20px rgba(239, 68, 68, 0.25);
        }

        .data-issues-banner__content {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 var(--spacing-md);
            color: #991b1b;
        }

        .data-issues-banner__content strong {
            display: inline-block;
            margin-bottom: var(--spacing-sm);
        }

        .data-issues-banner__content ul {
            margin: 0;
            padding-left: 1.25rem;
        }

        .data-issues-banner__content li {
            margin-bottom: 0.35rem;
        }

        .data-issues-banner__errors + .data-issues-banner__warning {
            margin-top: var(--spacing-md);
            padding-top: var(--spacing-md);
            border-top: 1px solid rgba(153, 27, 27, 0.25);
        }

        .data-issues-banner__warning {
            color: #7f1d1d;
        }

        .data-issues-banner__warning-header {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.35rem;
        }

        .data-issues-banner__pill {
            background: rgba(153, 27, 27, 0.1);
            border: 1px solid rgba(153, 27, 27, 0.3);
            border-radius: 999px;
            padding: 0.1rem 0.75rem;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .data-issues-banner__warning-list {
            margin: 0.35rem 0 0.35rem 1.25rem;
            padding-left: 0;
        }

        .data-issues-banner__warning-list li {
            margin-bottom: 0.25rem;
        }

        .data-issues-banner__dismiss {
            background: rgba(185, 28, 28, 0.1);
            border: 1px solid rgba(185, 28, 28, 0.4);
            border-radius: 999px;
            color: inherit;
            padding: 0.35rem 0.9rem;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        .data-issues-banner__dismiss:hover {
            background: rgba(185, 28, 28, 0.2);
            transform: translateY(-1px);
        }
    </style>

</body>
</html>
