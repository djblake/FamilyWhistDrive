<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ruston Family Whist Drive - The Most Prestigious Tournament in the World</title>
    <meta name="description" content="40 Years of Family Whist Excellence - Tournament Results, Player Statistics, and Championship Glory">
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="stylesheet" href="assets/css/main.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=Inter:wght@400;500;600&family=Courgette&display=swap" rel="stylesheet">
    <script src="/assets/js/footer-nav.js?v=4" defer></script>
    <script src="/assets/js/media.js?v=2" defer></script>
    <script src="/assets/js/lightbox.js?v=11" defer></script>
</head>
<body>
    <header class="header">
        <div class="container">
            <div data-header-nav></div>
                </div>
    </header>

    <section class="upcoming-banner" id="upcoming-banner" style="display:none;">
        <div class="container">
            <div class="upcoming-banner__inner">
                <div class="upcoming-banner__kicker">Upcoming tournament</div>
                <div class="upcoming-banner__title" id="upcoming-banner-title">‚Äî</div>
                <div class="upcoming-banner__meta" id="upcoming-banner-meta">‚Äî</div>
            </div>
        </div>
    </section>

    <main class="main-content">
        <section class="hero-section">
            <div class="container">
                <div class="hero-content">
                    <h2 class="hero-title">40 Years of Championship Excellence</h2>
                    <p class="hero-description">
                        Welcome to the most prestigious Partners Whist tournament known to mankind. 
                        Four decades of strategic brilliance, family rivalry, and legendary moments 
                        that have shaped the very fabric of competitive card gaming.
                    </p>
                    <div class="hero-stats">
                        <div class="stat-card">
                            <div class="stat-number" id="tournaments-count">1</div>
                            <div class="stat-label">Tournaments</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="rounds-count">16</div>
                            <div class="stat-label">Rounds Played</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="tricks-count">832</div>
                            <div class="stat-label">Tricks Taken</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="players-count">16</div>
                            <div class="stat-label">Family Players</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="home-winner-section">
            <div class="container">
                <h2 class="champion-section-title">Current Champion</h2>

                <div class="winner-card" aria-live="polite">
                    <div class="winner-kicker" aria-label="Latest tournament">
                        <div class="winner-year" id="latest-tournament-year">‚Äî</div>
                        <div class="winner-tournament-name" id="latest-tournament-name">Loading latest tournament‚Ä¶</div>
                    </div>

                    <div class="winner-trophy" aria-hidden="true">üèÜ</div>
                    <div class="winner-name" id="winner-name">‚Äî</div>
                    <div class="winner-badge" id="winner-badge">Winner ‚Äî</div>

                    <div class="winner-tricks-line" id="winner-tricks-line">‚Äî</div>
                    <div class="winner-avg-line" id="winner-avg-line">‚Äî</div>

                    <div class="winner-stats-row">
                        <div class="winner-stat">
                            <div class="winner-stat-number" id="winner-seed-rank">‚Äî</div>
                            <div class="winner-stat-label">Current seed rank</div>
                        </div>
                        <div class="winner-stat">
                            <div class="winner-stat-number" id="winner-career-played">‚Äî</div>
                            <div class="winner-stat-label">Tournaments played</div>
                        </div>
                        <div class="winner-stat">
                            <div class="winner-stat-number" id="winner-career-wins">‚Äî</div>
                            <div class="winner-stat-label">Tournament wins</div>
                        </div>
                    </div>
                </div>

                <div class="latest-highlights">
                    <div class="latest-highlights-header">
                        <h3 class="latest-highlights-heading" id="latest-highlights-title">Tournament Highlights</h3>
                        <div class="latest-highlights-tournament" aria-label="Latest tournament">
                            <div class="latest-highlights-year" id="latest-highlights-year">‚Äî</div>
                            <div class="latest-highlights-name" id="latest-highlights-name">‚Äî</div>
                        </div>
                    </div>

                    <div class="latest-top-grid">
                        <div class="latest-story">
                            <div class="latest-story-title">The story</div>
                            <ul class="latest-story-list" id="latest-tournament-story">
                                <li>Loading‚Ä¶</li>
                            </ul>
                        </div>
                        <div class="latest-podium-side" aria-label="Podium">
                            <div class="latest-podium-meta" id="latest-podium-meta">‚Äî</div>
                            <div class="mini-card mini-card--silver" aria-label="Second place">
                                <div class="mini-kicker">ü•à Second</div>
                                <div class="mini-value" id="latest-mini-second-name">‚Äî</div>
                                <div class="mini-subvalue" id="latest-mini-second-stats">‚Äî</div>
                            </div>
                            <div class="mini-card mini-card--bronze" aria-label="Third place">
                                <div class="mini-kicker">ü•â Third</div>
                                <div class="mini-value" id="latest-mini-third-name">‚Äî</div>
                                <div class="mini-subvalue" id="latest-mini-third-stats">‚Äî</div>
                            </div>
                        </div>
                    </div>

                    <div class="latest-extra-card" id="latest-day-notes-card" style="display:none;">
                        <div class="latest-extra-title">From the day</div>
                        <div class="latest-day-notes" id="latest-day-notes"></div>
                        <div class="latest-cover-strip" id="latest-cover-strip" aria-label="Cover photos" style="display:none;"></div>
                    </div>

                    <div class="latest-cta">
                        <a href="tournaments/" class="btn btn-primary" id="winner-results-cta">See full results for this tournament</a>
                    </div>
                </div>
            </div>
        </section>

        <section class="home-history-section">
            <div class="container">
                <h2 class="section-title">A Brief History</h2>
                <div class="history-card">
                    <div class="history-text" id="home-history-description">Loading history‚Ä¶</div>
                    <div class="history-actions">
                        <a class="btn btn-primary" href="/history/">Learn more</a>
                    </div>
                </div>
            </div>
        </section>

        <section class="home-seedwatch-section" id="home-seedwatch-section" style="display:none;">
            <div class="container">
                <div class="feature-grid seedwatch-grid">
                    <div class="feature-copy seedwatch-copy">
                        <h2 class="section-title">Seed watch</h2>
                        <p class="section-subtitle" id="home-seedwatch-summary">Loading seed watch‚Ä¶</p>
                    </div>
                    <div class="seedwatch-card">
                        <div class="seed-mini-table" role="table" aria-label="Current seed table">
                            <div class="seed-mini-row" role="row">
                                <div class="seed-mini-rank" id="home-seed-row-1-rank">#1</div>
                                <div class="seed-mini-name" id="home-seed-row-1-name">‚Äî</div>
                                <div class="seed-mini-points" id="home-seed-row-1-points">‚Äî</div>
                                <div class="seed-mini-trend" id="home-seed-row-1-trend" aria-label="Movement">‚Äî</div>
                            </div>
                            <div class="seed-mini-row" role="row">
                                <div class="seed-mini-rank" id="home-seed-row-2-rank">#2</div>
                                <div class="seed-mini-name" id="home-seed-row-2-name">‚Äî</div>
                                <div class="seed-mini-points" id="home-seed-row-2-points">‚Äî</div>
                                <div class="seed-mini-trend" id="home-seed-row-2-trend" aria-label="Movement">‚Äî</div>
                            </div>
                            <div class="seed-mini-row" role="row">
                                <div class="seed-mini-rank" id="home-seed-row-3-rank">#3</div>
                                <div class="seed-mini-name" id="home-seed-row-3-name">‚Äî</div>
                                <div class="seed-mini-points" id="home-seed-row-3-points">‚Äî</div>
                                <div class="seed-mini-trend" id="home-seed-row-3-trend" aria-label="Movement">‚Äî</div>
                            </div>
                            <div class="seed-mini-row seed-mini-row--highlight" role="row" id="home-seed-row-winner" style="display:none;">
                                <div class="seed-mini-rank" id="home-seed-row-winner-rank">‚Äî</div>
                                <div class="seed-mini-name" id="home-seed-row-winner-name">‚Äî</div>
                                <div class="seed-mini-points" id="home-seed-row-winner-points">‚Äî</div>
                                <div class="seed-mini-trend" id="home-seed-row-winner-trend" aria-label="Movement">‚Äî</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="home-feature-section home-feature-section--tables">
            <div class="container">
                <h2 class="section-title">Era &amp; Decade Standings</h2>
                <p class="section-subtitle">A snapshot of who‚Äôs dominated different eras of the drive. Here‚Äôs the 2020s so far.</p>
                <div class="feature-panel" style="margin-top: 1rem;">
                    <div class="feature-panel-title">2020s decade standings</div>
                    <div class="home-decade-table-wrap">
                        <table class="home-decade-table" aria-label="2020s decade standings">
                            <thead>
                                <tr>
                                    <th class="col-rank">Rank</th>
                                    <th class="col-name">Player</th>
                                    <th class="col-n">1sts</th>
                                    <th class="col-n">2nds</th>
                                    <th class="col-n">3rds</th>
                                    <th class="col-tricks">Total tricks</th>
                                    <th class="col-points home-decade-table__points">Points</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="col-rank" id="home-2020s-row-1-rank">#1</td>
                                    <td class="col-name" id="home-2020s-row-1-name">‚Äî</td>
                                    <td class="col-n" id="home-2020s-row-1-wins">‚Äî</td>
                                    <td class="col-n" id="home-2020s-row-1-seconds">‚Äî</td>
                                    <td class="col-n" id="home-2020s-row-1-thirds">‚Äî</td>
                                    <td class="col-tricks" id="home-2020s-row-1-tricks">‚Äî</td>
                                    <td class="col-points home-decade-table__points" id="home-2020s-row-1-points">‚Äî</td>
                                </tr>
                                <tr>
                                    <td class="col-rank" id="home-2020s-row-2-rank">#2</td>
                                    <td class="col-name" id="home-2020s-row-2-name">‚Äî</td>
                                    <td class="col-n" id="home-2020s-row-2-wins">‚Äî</td>
                                    <td class="col-n" id="home-2020s-row-2-seconds">‚Äî</td>
                                    <td class="col-n" id="home-2020s-row-2-thirds">‚Äî</td>
                                    <td class="col-tricks" id="home-2020s-row-2-tricks">‚Äî</td>
                                    <td class="col-points home-decade-table__points" id="home-2020s-row-2-points">‚Äî</td>
                                </tr>
                                <tr>
                                    <td class="col-rank" id="home-2020s-row-3-rank">#3</td>
                                    <td class="col-name" id="home-2020s-row-3-name">‚Äî</td>
                                    <td class="col-n" id="home-2020s-row-3-wins">‚Äî</td>
                                    <td class="col-n" id="home-2020s-row-3-seconds">‚Äî</td>
                                    <td class="col-n" id="home-2020s-row-3-thirds">‚Äî</td>
                                    <td class="col-tricks" id="home-2020s-row-3-tricks">‚Äî</td>
                                    <td class="col-points home-decade-table__points" id="home-2020s-row-3-points">‚Äî</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="small" style="margin-top:0.5rem;">Points: 1st=5, 2nd=3, 3rd=1 (per tournament). Tie-break: total tricks. Shared hands split tricks evenly.</div>
                </div>

                <div class="feature-actions" style="margin-top: 0.9rem;">
                    <a class="btn btn-primary" href="tables/">See all Eras and Decades</a>
                </div>
            </div>
        </section>

        <section class="home-feature-section home-feature-section--tournaments">
            <div class="container">
                <div class="feature-grid">
                    <div class="feature-copy">
                        <h2 class="section-title">Tournament Archive</h2>
                        <p class="section-subtitle">Every year, every result, every scorecard ‚Äî the full history of the drive.</p>
                        <div class="feature-actions">
                            <a class="btn btn-primary" href="tournaments/">Browse all tournaments</a>
                        </div>
                    </div>
                    <div class="feature-panel">
                        <div class="feature-panel-title">Recent tournaments</div>
                        <ul class="feature-list" id="recent-tournaments-list">
                            <li>Loading‚Ä¶</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <section class="home-feature-section home-feature-section--players">
            <div class="container">
                <div class="feature-grid">
                    <div class="feature-copy">
                        <h2 class="section-title">Players</h2>
                        <p class="section-subtitle">Profiles, partnerships, seed ranking history, and career highlights for every player.</p>
                        <div class="feature-actions">
                            <a class="btn btn-primary" href="players/">Explore players</a>
                        </div>
                    </div>
                    <div class="feature-panel">
                        <div class="feature-panel-title">At a glance</div>
                        <div class="feature-metrics feature-metrics--stack">
                            <div class="feature-metric">
                                <div class="feature-metric-number" id="home-metric-players">‚Äî</div>
                                <div class="feature-metric-label">Players tracked</div>
                            </div>
                            <div class="feature-metric">
                                <div class="feature-metric-number" id="home-metric-tournaments">‚Äî</div>
                                <div class="feature-metric-label">Tournaments</div>
                            </div>
                            <div class="feature-metric">
                                <div class="feature-metric-number" id="home-metric-rounds">‚Äî</div>
                                <div class="feature-metric-label">Rounds</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="home-feature-section home-feature-section--hof">
            <div class="container">
                <div class="feature-grid">
                    <div class="feature-copy">
                        <h2 class="section-title">Hall of Fame</h2>
                        <p class="section-subtitle">Champions, podiums, legacy ‚Äî the leaderboard of all-time greats.</p>
                        <div class="feature-actions">
                            <a class="btn btn-primary" href="leaderboard/">Open Hall of Fame</a>
                        </div>
                    </div>
                    <div class="feature-panel">
                        <div class="feature-panel-title">Standout stats</div>
                        <div class="feature-panel-metrics">
                            <div class="feature-panel-metric">
                                <div class="feature-panel-kicker">Current #1 seed</div>
                                <div class="feature-panel-value" id="hof-current-seed-1">‚Äî</div>
                                <div class="feature-panel-subvalue" id="hof-current-seed-1-sub">‚Äî</div>
                            </div>
                            <div class="feature-panel-metric">
                                <div class="feature-panel-kicker">All-time champion</div>
                                <div class="feature-panel-value" id="hof-alltime-champ">‚Äî</div>
                                <div class="feature-panel-subvalue" id="hof-alltime-champ-sub">‚Äî</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="home-feature-section home-feature-section--stats">
            <div class="container">
                <div class="feature-grid">
                    <div class="feature-copy">
                        <h2 class="section-title">Statistics</h2>
                        <p class="section-subtitle">Partnership rankings, streaks, family stats ‚Äî the deeper layer behind the trophies.</p>
                        <div class="feature-actions">
                            <a class="btn btn-primary" href="stats/">Open statistics</a>
                        </div>
                    </div>
                    <div class="feature-panel">
                        <div class="feature-panel-title">Standout stats</div>
                        <div class="feature-panel-metrics">
                            <div class="feature-panel-metric">
                                <div class="feature-panel-kicker">Best partnership</div>
                                <div class="feature-panel-value" id="stats-best-partnership">‚Äî</div>
                                <div class="feature-panel-subvalue" id="stats-best-partnership-sub">‚Äî</div>
                            </div>
                            <div class="feature-panel-metric">
                                <div class="feature-panel-kicker">Longest win streak</div>
                                <div class="feature-panel-value" id="stats-longest-win-streak">‚Äî</div>
                                <div class="feature-panel-subvalue" id="stats-longest-win-streak-sub">‚Äî</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div data-footer-nav></div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2024 Ruston Family Whist Drive. All rights reserved. | The most prestigious family tournament in existence.</p>
            </div>
        </div>
    </footer>

    <script src="assets/js/tournament-engine.js"></script>
    <script>
        // Load real tournament data from Google Sheets
        document.addEventListener('DOMContentLoaded', async function() {
            const tournamentEngine = new TournamentEngine();
            const sheetId = '1HGfdlDOfGHOL6Q4MP_TnF8UNE6YihBW-5gQs6Ykl78k';
            
            try {
                console.log('üè† Loading home page data...');
                await tournamentEngine.loadFromGoogleSheets(sheetId);

                function parseTournamentDateLoose(raw) {
                    const s = String(raw || '').trim();
                    if (!s) return null;
                    // dd/mm/yyyy or d/m/yyyy
                    const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                    if (m) {
                        const d = Number(m[1]);
                        const mo = Number(m[2]);
                        const y = Number(m[3]);
                        if (Number.isFinite(d) && Number.isFinite(mo) && Number.isFinite(y)) {
                            // Use noon to avoid DST edge cases.
                            return new Date(y, mo - 1, d, 12, 0, 0, 0);
                        }
                    }
                    // ISO-ish (yyyy-mm-dd)
                    const iso = s.match(/^(\d{4})-(\d{2})-(\d{2})/);
                    if (iso) {
                        const y = Number(iso[1]);
                        const mo = Number(iso[2]);
                        const d = Number(iso[3]);
                        return new Date(y, mo - 1, d, 12, 0, 0, 0);
                    }
                    const parsed = new Date(s);
                    if (!Number.isNaN(parsed)) return parsed;
                    return null;
                }

                function formatDateShort(d) {
                    if (!(d instanceof Date) || Number.isNaN(d)) return '';
                    return d.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' });
                }

                async function renderUpcomingTournamentBanner(engine, sid) {
                    const banner = document.getElementById('upcoming-banner');
                    const titleEl = document.getElementById('upcoming-banner-title');
                    const metaEl = document.getElementById('upcoming-banner-meta');
                    if (!banner || !titleEl || !metaEl) return;

                    banner.style.display = 'block';
                    titleEl.textContent = 'Checking upcoming tournament‚Ä¶';
                    metaEl.textContent = '';

                    let allMeta = (engine && typeof engine.getAllTournamentMetadata === 'function')
                        ? engine.getAllTournamentMetadata()
                        : (engine && engine.tournamentMetadata && typeof engine.tournamentMetadata.values === 'function')
                            ? Array.from(engine.tournamentMetadata.values())
                            : [];

                    async function fetchTournamentsMetaDirect(sheetId) {
                        const id = String(sheetId || '').trim();
                        if (!id) return [];
                        try {
                            const url = `https://docs.google.com/spreadsheets/d/${encodeURIComponent(id)}/gviz/tq?tqx=out:csv&sheet=Tournaments`;
                            const response = await fetch(url, { cache: 'no-store' });
                            if (!response.ok) return [];
                            const csv = await response.text();
                            const rows = (engine && typeof engine.parseCSVRows === 'function')
                                ? engine.parseCSVRows(String(csv || '').trim())
                                : [];
                            if (!Array.isArray(rows) || rows.length < 2) return [];
                            const headers = rows[0].map(h => String(h || '').trim());
                            const idxOf = (name) => headers.findIndex(h => String(h).trim().toLowerCase() === String(name).trim().toLowerCase());
                            const idIdx = idxOf('Id');
                            const dateIdx = idxOf('Date');
                            const yearIdx = idxOf('Year');
                            const titleIdx = idxOf('Title');
                            const venueIdx = idxOf('Venue');
                            const commentsIdx = idxOf('Comments');
                            const out = [];
                            for (let i = 1; i < rows.length; i++) {
                                const r = rows[i];
                                if (!Array.isArray(r) || r.length === 0) continue;
                                const rawId = String(r[idIdx] ?? '').trim();
                                if (!rawId) continue;
                                const year = Number.isFinite(Number(r[yearIdx])) ? parseInt(String(r[yearIdx]).trim(), 10) : null;
                                out.push({
                                    id: rawId,
                                    key: rawId,
                                    title: String(r[titleIdx] ?? '').trim(),
                                    year,
                                    date: String(r[dateIdx] ?? '').trim(),
                                    venue: String(r[venueIdx] ?? '').trim(),
                                    comments: String(r[commentsIdx] ?? '').trim()
                                });
                            }
                            return out;
                        } catch (e) {
                            return [];
                        }
                    }

                    if (!Array.isArray(allMeta) || allMeta.length === 0) {
                        allMeta = await fetchTournamentsMetaDirect(sid);
                    }

                    const now = new Date();
                    const upcoming = [];
                    for (const m of allMeta) {
                        const dt = parseTournamentDateLoose(m?.date);
                        if (!dt) continue;
                        if (dt.getTime() <= now.getTime()) continue;
                        upcoming.push({ meta: m, dt });
                    }
                    if (!upcoming.length) {
                        banner.style.display = 'none';
                        return;
                    }

                    upcoming.sort((a, b) => a.dt.getTime() - b.dt.getTime());
                    const next = upcoming[0];
                    const meta = next.meta || {};
                    const year = meta.year ? String(meta.year) : '';
                    const venue = String(meta.venue || '').trim();
                    const title = String(meta.title || '').trim() || (year ? `Tournament ${year}` : 'Upcoming tournament');
                    const dateText = formatDateShort(next.dt) || String(meta.date || '').trim();

                    titleEl.textContent = title;
                    metaEl.textContent = venue ? `${dateText} ‚Ä¢ ${venue}` : dateText;
                    banner.style.display = 'block';
                }

                await renderUpcomingTournamentBanner(tournamentEngine, sheetId);

                async function loadHistoryDescription(engine, sid) {
                    try {
                        const url = `https://docs.google.com/spreadsheets/d/${encodeURIComponent(sid)}/gviz/tq?tqx=out:csv&sheet=History`;
                        const response = await fetch(url, { cache: 'no-store' });
                        if (!response.ok) return '';
                        const csv = await response.text();
                        const rows = (engine && typeof engine.parseCSVRows === 'function')
                            ? engine.parseCSVRows(String(csv || '').trim())
                            : [];
                        if (!Array.isArray(rows) || rows.length === 0) return '';

                        const norm = (v) => String(v || '').trim();
                        const normLower = (v) => norm(v).toLowerCase();

                        const readHistoryTableByHeader = () => {
                            // Expected new format: header row with "Description" and "Preview"
                            const headerRow = Array.isArray(rows[0]) ? rows[0] : [];
                            const headers = headerRow.map(h => normLower(h));
                            if (!headers.length) return null;
                            const descIdx = headers.indexOf('description');
                            const prevIdx = headers.indexOf('preview');
                            if (descIdx === -1 && prevIdx === -1) return null;

                            // Find first non-empty data row
                            for (let i = 1; i < rows.length; i++) {
                                const r = rows[i];
                                if (!Array.isArray(r) || r.length === 0) continue;
                                const desc = descIdx >= 0 ? norm(r[descIdx]) : '';
                                const preview = prevIdx >= 0 ? norm(r[prevIdx]) : '';
                                if (desc || preview) {
                                    return { description: desc, preview };
                                }
                            }
                            return { description: '', preview: '' };
                        };

                        const findRowIndex = (needle) => {
                            const n = normLower(needle);
                            for (let i = 0; i < rows.length; i++) {
                                const r = rows[i];
                                const a = Array.isArray(r) ? normLower(r[0]) : '';
                                if (a === n) return i;
                            }
                            return -1;
                        };

                        const asTable = readHistoryTableByHeader();
                        if (asTable) {
                            // Prefer preview on home page; caller can still fallback to description.
                            return asTable.preview || asTable.description || '';
                        }

                        const idx = findRowIndex('Description');
                        if (idx >= 0) {
                            const row = rows[idx] || [];
                            const inline = Array.isArray(row) ? norm(row.slice(1).join(',')) : '';
                            if (inline) return inline;

                            // Common History format: Row0 = "Description", Row1+ = text (single column)
                            const lines = [];
                            for (let j = idx + 1; j < rows.length; j++) {
                                const r = rows[j];
                                if (!Array.isArray(r) || r.length === 0) continue;
                                const v = String(r[0] ?? '');
                                lines.push(v);
                            }
                            return lines.join('\n').trim();
                        }

                        // Fallback: treat first non-empty cell as description
                        for (const r of rows) {
                            if (!Array.isArray(r) || r.length === 0) continue;
                            const v = norm(r[0]);
                            if (v) return v;
                        }
                        return '';
                    } catch (_) {
                        return '';
                    }
                }
                
                // Update hero stats - get tournaments sorted by year (most recent first)
                const tournaments = (tournamentEngine.getAllTournaments && typeof tournamentEngine.getAllTournaments === 'function')
                    ? tournamentEngine.getAllTournaments().slice()
                    : Array.from((tournamentEngine.tournaments || new Map()).values());
                tournaments.sort((a, b) => (Number(b.year) || 0) - (Number(a.year) || 0));
                const totalRounds = tournaments.reduce((sum, t) => sum + t.total_rounds, 0);
                
                // Tricks Taken: prefer summing parsed tournament tables (more robust across cache/schema differences),
                // and fall back to raw scorecards if needed.
                let totalTricks = 0;
                try {
                    if (tournamentEngine && tournamentEngine.tournaments) {
                        for (const t of tournamentEngine.tournaments.values()) {
                            if (!t || !Array.isArray(t.rounds)) continue;
                            for (const r of t.rounds) {
                                if (!r || !Array.isArray(r.tables)) continue;
                                for (const table of r.tables) {
                                    const partnerships = table && Array.isArray(table.partnerships) ? table.partnerships : [];
                                    for (const p of partnerships) {
                                        const tricks = Number.isFinite(p?.tricks) ? p.tricks : parseFloat(p?.tricks);
                                        if (!Number.isFinite(tricks)) continue;
                                        totalTricks += tricks;
                                    }
                                }
                            }
                        }
                    }
                } catch (_) {
                    totalTricks = 0;
                }

                if (!totalTricks && tournamentEngine && Array.isArray(tournamentEngine.rawScorecards)) {
                    // Avoid double counting by only counting unique hands from scorecards.
                    // Note: TournamentEngine keeps raw sheet header names (e.g. "Tricks Won"),
                    // so prefer that over legacy "Tricks_Won".
                const uniqueHands = new Set();
                    totalTricks = tournamentEngine.rawScorecards.reduce((sum, sc) => {
                    const handKey = `${sc.Tournament}-${sc.Year}-${sc.Round}-${sc.Player1}-${sc.Player2}`;
                    if (!uniqueHands.has(handKey)) {
                        uniqueHands.add(handKey);
                            const rawTricks =
                                (sc && (sc['Tricks Won'] ?? sc.Tricks_Won ?? sc['Tricks_Won'] ?? sc.TricksWon ?? sc['TricksWon'])) ?? '';
                            const tricks = parseInt(rawTricks, 10) || 0;
                        return sum + tricks;
                    }
                    return sum;
                }, 0);
                }
                
                // Player counts:
                // - rosterCount: rows on the Players sheet (may include people who've never played)
                // - competedCount: distinct individuals who've actually appeared in tournaments (splits shared hands)
                const rosterCount = (tournamentEngine.getPlayersRoster && typeof tournamentEngine.getPlayersRoster === 'function')
                    ? (tournamentEngine.getPlayersRoster().length || 0)
                    : 0;
                const competedPlayers = (tournamentEngine.getAllIndividualPlayers && typeof tournamentEngine.getAllIndividualPlayers === 'function')
                    ? (tournamentEngine.getAllIndividualPlayers('total_tricks') || [])
                    : [];
                const competedCount = Array.isArray(competedPlayers) ? competedPlayers.length : 0;
                
                document.getElementById('tournaments-count').textContent = tournaments.length;
                document.getElementById('rounds-count').textContent = totalRounds;
                document.getElementById('tricks-count').textContent = Number(totalTricks || 0).toLocaleString();
                // Home should match the Players page: count individuals who have competed (not shared-hand combos).
                document.getElementById('players-count').textContent = competedCount || rosterCount || 0;
                
                // Winner spotlight + tournament highlights
                const uniqueDesc = (tournamentEngine.getAllTournamentsUnique && typeof tournamentEngine.getAllTournamentsUnique === 'function')
                    ? tournamentEngine.getAllTournamentsUnique('desc')
                    : tournaments.slice();

                const safeName = (id) => (tournamentEngine && typeof tournamentEngine.getDisplayName === 'function')
                    ? tournamentEngine.getDisplayName(id)
                    : (id || '‚Äî');

                const toTitleCase = (s) => {
                    const raw = String(s || '').trim();
                    if (!raw) return '';
                    return raw.split(/\s+/g).map(w => {
                        if (!w) return w;
                        // keep acronyms / already-cased words
                        const hasUpperInside = /[A-Z]/.test(w.slice(1));
                        if (hasUpperInside) return w;
                        return w.charAt(0).toUpperCase() + w.slice(1);
                    }).join(' ');
                };

                const appendHighlight = (ul, text) => {
                    if (!ul || !text) return;
                    const li = document.createElement('li');
                    li.textContent = text;
                    ul.appendChild(li);
                };

                async function renderLatestDayNotesAndCovers({ year, metaLatest }) {
                    const card = document.getElementById('latest-day-notes-card');
                    const notesEl = document.getElementById('latest-day-notes');
                    const strip = document.getElementById('latest-cover-strip');
                    if (!card || !notesEl || !strip) return;
                    if (!year || !/^\d{4}$/.test(String(year))) return;

                    // Day notes (stories + quotes)
                    let notes = null;
                    try {
                        const res = await fetch(`/api/day-notes?year=${encodeURIComponent(String(year))}`, { cache: 'no-store' });
                        notes = res.ok ? await res.json().catch(() => null) : null;
                    } catch (_) {
                        notes = null;
                    }

                    const stories = Array.isArray(notes?.stories) ? notes.stories : [];
                    const quotes = Array.isArray(notes?.quotes) ? notes.quotes : [];
                    const items = []
                        .concat(stories.map(x => ({ type: 'story', author: x?.author, text: x?.text })))
                        .concat(quotes.map(x => ({ type: 'quote', author: x?.author, saidBy: x?.saidBy, text: x?.text })));

                    const escapeHtml = (value) => String(value ?? '')
                        .replaceAll('&', '&amp;')
                        .replaceAll('<', '&lt;')
                        .replaceAll('>', '&gt;')
                        .replaceAll('"', '&quot;')
                        .replaceAll("'", '&#39;');

                    if (items.length) {
                        notesEl.innerHTML = items.map(it => {
                            const kind = it.type === 'quote' ? 'üí¨ Quote' : '‚ú® Story';
                            const author = String(it.author || '').trim(); // submitter
                            const saidBy = String(it.saidBy || '').trim(); // quoter / speaker (quotes only)
                            const text = String(it.text || '').trim();
                            if (!text) return '';

                            if (it.type === 'quote') {
                                const speaker = saidBy || author;
                                const body = speaker ? `${escapeHtml(speaker)}: ${escapeHtml(text)}` : escapeHtml(text);
                                return `
                                    <div class="latest-note">
                                        <div class="latest-note__kicker">${kind}</div>
                                        <div class="latest-note__body">${body}</div>
                                        ${speaker ? `<div class="latest-note__meta">‚Äî ${escapeHtml(speaker)}</div>` : ``}
                                    </div>
                                `;
                            }
                            return `
                                <div class="latest-note">
                                    <div class="latest-note__kicker">${kind}</div>
                                    <div class="latest-note__body">${escapeHtml(text)}</div>
                                    ${author ? `<div class="latest-note__meta">‚Äî ${escapeHtml(author)}</div>` : ``}
                                </div>
                            `;
                        }).join('');
                        card.style.display = 'block';
                    } else {
                        notesEl.innerHTML = '';
                        // Keep card hidden unless we have photos to show.
                    }

                    // Cover thumbnails row (6)
                    if (!(window.WhistMedia && typeof window.WhistMedia.getTournamentMeta === 'function')) return;
                    if (!(window.WhistMedia && typeof window.WhistMedia.publicUrlForKey === 'function')) return;

                    let meta = metaLatest;
                    if (!meta) {
                        try { meta = await window.WhistMedia.getTournamentMeta(String(year)); } catch (_) { meta = null; }
                    }
                    const photos = Array.isArray(meta?.photos) ? meta.photos : [];
                    const coverPicks = Array.isArray(meta?.coverPicks) ? meta.coverPicks.slice(0, 6) : [];
                    const picks = coverPicks.length
                        ? coverPicks
                        : photos.slice().sort((a, b) => String(b?.uploadedAt || '').localeCompare(String(a?.uploadedAt || ''))).map(p => String(p?.key || '')).filter(Boolean).slice(0, 6);

                    if (!picks.length) {
                        if (!items.length) card.style.display = 'none';
                        strip.style.display = 'none';
                        strip.innerHTML = '';
                        return;
                    }

                    // Build lightbox sequence: cover picks first, then rest (oldest-first), skipping duplicates.
                    const byKey = new Map(photos.map(p => [String(p?.key || ''), p]));
                    const highlightSet = new Set(picks.map(k => String(k || '')).filter(Boolean));
                    const oldestFirst = photos.slice().sort((a, b) => String(a?.uploadedAt || '').localeCompare(String(b?.uploadedAt || '')));
                    const rest = [];
                    for (const p of oldestFirst) {
                        const k = String(p?.key || '');
                        if (!k || highlightSet.has(k)) continue;
                        rest.push(k);
                    }
                    const sequenceKeys = picks.concat(rest);

                    const lightboxItems = [];
                    for (const k of sequenceKeys) {
                        const fullUrl = await window.WhistMedia.publicUrlForKey(k);
                        if (!fullUrl) continue;
                        const entry = byKey.get(k);
                        const thumbKey = String(entry?.thumbKey || '').trim();
                        const thumbUrl = thumbKey ? await window.WhistMedia.publicUrlForKey(thumbKey) : '';
                        const uploader = String(entry?.uploaderName || entry?.uploaderSlug || '').trim();
                        const captionParts = [];
                        if (uploader) captionParts.push(`Uploader: ${uploader}`);
                        if (k) captionParts.push(`Key: ${k}`);
                        lightboxItems.push({ url: fullUrl, thumbUrl: thumbUrl || '', caption: captionParts.join(' ‚Ä¢ ') });
                    }

                    const thumbs = [];
                    for (let i = 0; i < picks.length; i++) {
                        const k = String(picks[i] || '');
                        if (!k) continue;
                        const fullUrl = await window.WhistMedia.publicUrlForKey(k);
                        if (!fullUrl) continue;
                        const entry = byKey.get(k);
                        const thumbKey = String(entry?.thumbKey || '').trim();
                        const thumbUrl = thumbKey ? await window.WhistMedia.publicUrlForKey(thumbKey) : '';
                        const imgUrl = thumbUrl || fullUrl;
                        thumbs.push(`<a href="${fullUrl.replaceAll('"', '&quot;')}" data-index="${i}" rel="noopener"><img alt="Cover photo" loading="lazy" src="${imgUrl.replaceAll('"', '&quot;')}"></a>`);
                    }
                    strip.innerHTML = thumbs.join('');
                    strip.style.display = 'grid';
                    card.style.display = 'block';

                    if (window.WhistLightbox && typeof window.WhistLightbox.open === 'function') {
                        const goToHref = `tournaments/photos.html?year=${encodeURIComponent(String(year))}`;
                        const goToLabel = `Go to ${year} gallery`;
                        strip.querySelectorAll('a[data-index]').forEach(a => {
                            a.addEventListener('click', (e) => {
                                if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;
                                e.preventDefault();
                                const start = Number(a.getAttribute('data-index') || '0') || 0;
                                window.WhistLightbox.open(lightboxItems, start, { goToHref, goToLabel });
                            });
                        });
                    }
                }

                const extractParticipantIds = (tournamentObj) => {
                    const ids = [];
                    const standings = Array.isArray(tournamentObj?.final_standings) ? tournamentObj.final_standings : [];
                    for (const s of standings) {
                        if (Array.isArray(s?.partnership_players) && s.partnership_players.length) {
                            ids.push(...s.partnership_players.filter(Boolean));
                            continue;
                        }
                        const p = String(s?.player || '').trim();
                        if (!p) continue;
                        if (p.includes('/') || p.includes('&') || p.includes('+')) {
                            p.split(/[\/&+]/g).map(x => x.trim()).filter(Boolean).forEach(x => ids.push(x));
                        } else {
                            ids.push(p);
                        }
                    }
                    return Array.from(new Set(ids));
                };

                if (uniqueDesc.length > 0) {
                    const latest = uniqueDesc[0];
                    const year = latest && Number.isFinite(Number(latest.year)) ? latest.year : '';
                    const resultsHref = `tournaments/results.html?year=${encodeURIComponent(year)}`;

                    const yearEl = document.getElementById('latest-tournament-year');
                    if (yearEl) yearEl.textContent = `${latest.year || '‚Äî'}`;
                    const nameEl = document.getElementById('latest-tournament-name');
                    if (nameEl) nameEl.textContent = `${toTitleCase(latest.name || latest.title || 'Tournament')}`;

                    // Tournament label in the highlights header (above entrants/rounds)
                    const highlightsYearEl = document.getElementById('latest-highlights-year');
                    if (highlightsYearEl) highlightsYearEl.textContent = `${latest.year || '‚Äî'}`;
                    const highlightsNameEl = document.getElementById('latest-highlights-name');
                    if (highlightsNameEl) highlightsNameEl.textContent = `${toTitleCase(latest.name || latest.title || 'Tournament')}`;

                    // Title is fixed: "Tournament Highlights"

                    const standings = Array.isArray(latest.final_standings) ? latest.final_standings.slice() : [];
                    const champ = standings.find(s => s && s.position === 1) || standings[0] || null;
                    const second = standings.find(s => s && s.position === 2) || standings[1] || null;
                    const third = standings.find(s => s && s.position === 3) || standings[2] || null;
                    const booby = standings.length ? standings[standings.length - 1] : null;

                    const champName = champ?.player ? safeName(champ.player) : '‚Äî';
                    const winnerNameEl = document.getElementById('winner-name');
                    if (winnerNameEl) winnerNameEl.textContent = champName;
                    const badgeEl = document.getElementById('winner-badge');
                    if (badgeEl) badgeEl.textContent = `Winner ${latest.year || ''}`.trim();

                    const champTricks = champ && Number.isFinite(Number(champ.total_tricks)) ? Number(champ.total_tricks) : null;
                    const champAvg = champ && Number.isFinite(Number(champ.average_tricks)) ? Number(champ.average_tricks) : null;
                    const tricksLineEl = document.getElementById('winner-tricks-line');
                    if (tricksLineEl) tricksLineEl.textContent = (champTricks !== null) ? `${champTricks.toLocaleString()} tricks` : '‚Äî';
                    const avgLineEl = document.getElementById('winner-avg-line');
                    if (avgLineEl) avgLineEl.textContent = (champAvg !== null) ? `${champAvg.toFixed(2)} avg/round` : '‚Äî';

                    const cta = document.getElementById('winner-results-cta');
                    if (cta) cta.href = resultsHref;

                    // Seed ranks: current vs previous (excluding latest)
                    const tournamentsAsc = (tournamentEngine.getAllTournamentsUnique && typeof tournamentEngine.getAllTournamentsUnique === 'function')
                        ? tournamentEngine.getAllTournamentsUnique('asc')
                        : uniqueDesc.slice().reverse();
                    const allForSeed = tournamentsAsc.filter(t => t && t.id);
                    const beforeForSeed = allForSeed.filter(t => t.id !== latest.id);
                    const seedCurrent = (typeof tournamentEngine.computeOfficialSeedRankingsForTournaments === 'function')
                        ? tournamentEngine.computeOfficialSeedRankingsForTournaments(allForSeed, true)
                        : [];
                    const seedBefore = (typeof tournamentEngine.computeOfficialSeedRankingsForTournaments === 'function')
                        ? tournamentEngine.computeOfficialSeedRankingsForTournaments(beforeForSeed, true)
                        : [];

                    const champSeed = champ?.player ? seedCurrent.find(r => r && r.name === champ.player) : null;
                    const champSeedText = champSeed ? `#${champSeed.seed_rank} (${champSeed.seed_points} pts)` : '‚Äî';
                    const winnerSeedEl = document.getElementById('winner-seed-rank');
                    if (winnerSeedEl) winnerSeedEl.textContent = champSeedText;

                    // Hall of Fame: seed watch mini table (top seed + latest champion)
                    const seedChangeLabel = (curRank, prevRank) => {
                        const c = Number(curRank);
                        if (!Number.isFinite(c)) return '‚Äî';
                        if (prevRank === null || prevRank === undefined) return 'new';
                        const p = Number(prevRank);
                        if (!Number.isFinite(p)) return '‚Äî';
                        const delta = p - c;
                        if (delta === 0) return '‚Äî';
                        if (delta > 0) return `‚Üë${delta}`;
                        return `‚Üì${Math.abs(delta)}`;
                    };

                    const findPrevRank = (playerId) => {
                        const id = String(playerId || '').trim();
                        if (!id) return null;
                        const rec = seedBefore.find(r => r && r.name === id);
                        return rec && Number.isFinite(Number(rec.seed_rank)) ? Number(rec.seed_rank) : null;
                    };

                    const fillSeedRowSimple = (prefix, entry) => {
                        const rankEl = document.getElementById(`${prefix}-rank`);
                        const nameEl = document.getElementById(`${prefix}-name`);
                        const ptsEl = document.getElementById(`${prefix}-points`);
                        const trendEl = document.getElementById(`${prefix}-trend`);
                        if (!entry) {
                            if (rankEl) rankEl.textContent = '‚Äî';
                            if (nameEl) nameEl.textContent = '‚Äî';
                            if (ptsEl) ptsEl.textContent = '‚Äî';
                            if (trendEl) trendEl.textContent = '‚Äî';
                            return;
                        }
                        const prevRank = findPrevRank(entry.name);
                        if (rankEl) rankEl.textContent = entry.seed_rank ? `#${entry.seed_rank}` : '‚Äî';
                        if (nameEl) nameEl.textContent = entry.name ? safeName(entry.name) : '‚Äî';
                        if (ptsEl) ptsEl.textContent = Number.isFinite(Number(entry.seed_points)) ? `${entry.seed_points} pts` : '‚Äî';
                        if (trendEl) trendEl.textContent = seedChangeLabel(entry.seed_rank, prevRank);
                    };

                    // Seed watch section (moved below Brief history)
                    const seedSection = document.getElementById('home-seedwatch-section');
                    const seedSummaryEl = document.getElementById('home-seedwatch-summary');
                    if (seedSection) seedSection.style.display = 'block';

                    const topNow = seedCurrent && seedCurrent.length ? seedCurrent[0] : null;
                    const topPrev = seedBefore && seedBefore.length ? seedBefore[0] : null;
                    let summaryBits = [];
                    if (topNow && topNow.name) {
                        if (topPrev && topPrev.name === topNow.name) {
                            summaryBits.push(`${safeName(topNow.name)} retains #1 from last year.`);
                        } else {
                            const was = findPrevRank(topNow.name);
                            summaryBits.push(`${safeName(topNow.name)} takes #1${Number.isFinite(Number(was)) ? ` (from #${was})` : ''}.`);
                        }
                    }
                    if (champ && champ.player) {
                        const now = champSeed && champSeed.seed_rank ? Number(champSeed.seed_rank) : null;
                        const was = findPrevRank(champ.player);
                        if (Number.isFinite(now) && Number.isFinite(was)) {
                            if (now !== was) summaryBits.push(`${safeName(champ.player)} moves from #${was} to #${now} after winning.`);
                            else summaryBits.push(`${safeName(champ.player)} stays at #${now} after winning.`);
                        } else if (Number.isFinite(now)) {
                            summaryBits.push(`${safeName(champ.player)} enters at #${now} after winning.`);
                        }
                    }
                    if (seedSummaryEl) {
                        seedSummaryEl.textContent = summaryBits.length
                            ? `${summaryBits.join(' ')} Showing top 3 plus the champion.`
                            : 'Current seed table (top 3 plus the champion).';
                    }

                    fillSeedRowSimple('home-seed-row-1', seedCurrent[0] || null);
                    fillSeedRowSimple('home-seed-row-2', seedCurrent[1] || null);
                    fillSeedRowSimple('home-seed-row-3', seedCurrent[2] || null);

                    const winnerRow = document.getElementById('home-seed-row-winner');
                    const champInTop3 = Boolean(champ?.player && seedCurrent.slice(0, 3).some(r => r && r.name === champ.player));
                    if (winnerRow) winnerRow.style.display = (!champInTop3 && champSeed) ? 'grid' : 'none';
                    if (!champInTop3 && champSeed) {
                        // Map champSeed to the expected entry shape for fillSeedRowSimple
                        fillSeedRowSimple('home-seed-row-winner', champSeed);
                    }

                    // 2020s decade snapshot (match `tournaments/period.html` logic, but top 3 only)
                    const computePeriodRows = (startYear, endYear) => {
                        const start = Number(startYear);
                        const end = Number(endYear);
                        if (!Number.isFinite(start) || !Number.isFinite(end)) return [];

                        const pointsByPos = { 1: 5, 2: 3, 3: 1 };
                        const stats = new Map(); // id -> {id, points, tricks, wins, seconds, thirds}

                        const ensure = (id) => {
                            const key = String(id || '').trim();
                            if (!key) return null;
                            if (!stats.has(key)) stats.set(key, { id: key, points: 0, tricks: 0, wins: 0, seconds: 0, thirds: 0 });
                            return stats.get(key);
                        };

                        const idsForStanding = (standing) => {
                            if (!standing) return [];
                            if (standing.is_partnership && Array.isArray(standing.partnership_players) && standing.partnership_players.length) {
                                return standing.partnership_players.map(x => String(x || '').trim()).filter(Boolean);
                            }
                            const p = String(standing.player || '').trim();
                            return p ? [p] : [];
                        };

                        const tours = Array.isArray(tournamentsAsc) ? tournamentsAsc : [];
                        const inRange = tours.filter(t => Number.isFinite(Number(t?.year)) && Number(t.year) >= start && Number(t.year) <= end);
                        for (const t of inRange) {
                            const standings = Array.isArray(t?.final_standings) ? t.final_standings : [];
                            for (const s of standings) {
                                const pos = Number.isFinite(Number(s?.position)) ? Number(s.position) : null;
                                const ids = idsForStanding(s);
                                if (!ids.length) continue;

                                const rawTr = Number(s?.total_tricks);
                                const tr = Number.isFinite(rawTr) ? rawTr : 0;
                                const isShared = !!(s?.is_partnership && Array.isArray(s?.partnership_players) && s.partnership_players.length > 1);
                                const splitTr = isShared ? (tr / Math.max(1, ids.length)) : tr;

                                const pts = (pos && pointsByPos[pos]) ? pointsByPos[pos] : 0;
                                for (const id of ids) {
                                    const rec = ensure(id);
                                    if (!rec) continue;
                                    rec.points += pts;
                                    rec.tricks += splitTr;
                                    if (pos === 1) rec.wins += 1;
                                    if (pos === 2) rec.seconds += 1;
                                    if (pos === 3) rec.thirds += 1;
                                }
                            }
                        }

                        const rows = Array.from(stats.values()).map(r => ({
                            ...r,
                            name: (tournamentEngine && typeof tournamentEngine.getDisplayName === 'function')
                                ? tournamentEngine.getDisplayName(r.id)
                                : safeName(r.id)
                        }));
                        rows.sort((a, b) =>
                            (b.points - a.points) ||
                            (b.tricks - a.tricks) ||
                            (b.wins - a.wins) ||
                            (b.seconds - a.seconds) ||
                            (b.thirds - a.thirds) ||
                            String(a.name).localeCompare(String(b.name))
                        );

                        // Rank with ties on (points, tricks)
                        let currentRank = 0;
                        let prevKey = null;
                        rows.forEach((r, idx) => {
                            const key = `${r.points}|${Number(r.tricks).toFixed(4)}`;
                            if (key !== prevKey) {
                                currentRank = idx + 1;
                                prevKey = key;
                            }
                            r.rank = currentRank;
                        });
                        return rows;
                    };

                    const fillHome2020sRow = (i, row) => {
                        const rankEl = document.getElementById(`home-2020s-row-${i}-rank`);
                        const nameEl = document.getElementById(`home-2020s-row-${i}-name`);
                        const winsEl = document.getElementById(`home-2020s-row-${i}-wins`);
                        const secondsEl = document.getElementById(`home-2020s-row-${i}-seconds`);
                        const thirdsEl = document.getElementById(`home-2020s-row-${i}-thirds`);
                        const tricksEl = document.getElementById(`home-2020s-row-${i}-tricks`);
                        const ptsEl = document.getElementById(`home-2020s-row-${i}-points`);

                        if (!row) {
                            if (rankEl) rankEl.textContent = `#${i}`;
                            if (nameEl) nameEl.textContent = '‚Äî';
                            if (winsEl) winsEl.textContent = '‚Äî';
                            if (secondsEl) secondsEl.textContent = '‚Äî';
                            if (thirdsEl) thirdsEl.textContent = '‚Äî';
                            if (tricksEl) tricksEl.textContent = '‚Äî';
                            if (ptsEl) ptsEl.textContent = '‚Äî';
                            return;
                        }

                        if (rankEl) rankEl.textContent = `#${row.rank || i}`;
                        if (nameEl) nameEl.textContent = row.name || '‚Äî';
                        if (winsEl) winsEl.textContent = Number.isFinite(Number(row.wins)) ? String(row.wins) : '0';
                        if (secondsEl) secondsEl.textContent = Number.isFinite(Number(row.seconds)) ? String(row.seconds) : '0';
                        if (thirdsEl) thirdsEl.textContent = Number.isFinite(Number(row.thirds)) ? String(row.thirds) : '0';
                        if (tricksEl) {
                            const tricks = Number.isFinite(Number(row.tricks)) ? Math.round(Number(row.tricks)) : null;
                            tricksEl.textContent = (tricks !== null) ? tricks.toLocaleString() : '‚Äî';
                        }
                        if (ptsEl) ptsEl.textContent = Number.isFinite(Number(row.points)) ? String(row.points) : '‚Äî';
                    };

                    const rows2020s = computePeriodRows(2020, 2029);
                    fillHome2020sRow(1, rows2020s[0] || null);
                    fillHome2020sRow(2, rows2020s[1] || null);
                    fillHome2020sRow(3, rows2020s[2] || null);

                    // Hall of Fame panel: current #1 seed (simple standout stats)
                    const hofSeedEl = document.getElementById('hof-current-seed-1');
                    const hofSeedSubEl = document.getElementById('hof-current-seed-1-sub');
                    if (hofSeedEl && seedCurrent && seedCurrent.length > 0) {
                        const top = seedCurrent[0];
                        hofSeedEl.textContent = safeName(top.name);
                        if (hofSeedSubEl) hofSeedSubEl.textContent = `Seed #1 ‚Ä¢ ${top.seed_points} pts`;
                    } else {
                        if (hofSeedEl) hofSeedEl.textContent = '‚Äî';
                        if (hofSeedSubEl) hofSeedSubEl.textContent = '';
                    }

                    // Podium mini panels (2nd / 3rd)
                    const playedOn = latest?.date ? `${latest.date}` : null;
                    const entrantsNum = standings.length ? standings.length : (latest?.total_players ? Number(latest.total_players) : null);
                    const roundsNum = latest?.total_rounds ? Number(latest.total_rounds) : null;

                    const setPodiumMini = (which, row) => {
                        const nameEl = document.getElementById(`latest-mini-${which}-name`);
                        const statsEl = document.getElementById(`latest-mini-${which}-stats`);
                        if (!row) {
                            if (nameEl) nameEl.textContent = '‚Äî';
                            if (statsEl) statsEl.textContent = '';
                            return;
                        }
                        const nm = safeName(row.player);
                        const tr = Number.isFinite(Number(row.total_tricks)) ? Number(row.total_tricks) : null;
                        const av = Number.isFinite(Number(row.average_tricks)) ? Number(row.average_tricks) : null;
                        if (nameEl) nameEl.textContent = nm;
                        if (statsEl) statsEl.textContent = `${tr !== null ? tr : '‚Äî'} tricks ‚Ä¢ ${av !== null ? av.toFixed(2) : '‚Äî'} avg/round`;
                    };
                    setPodiumMini('second', second);
                    setPodiumMini('third', third);

                    // Latest: show day notes (stories/quotes) + cover thumbs row
                    await renderLatestDayNotesAndCovers({ year, metaLatest: null });

                    // Podium meta (date/entrants/rounds) above the 2nd/3rd cards (not in the story)
                    const podiumMetaEl = document.getElementById('latest-podium-meta');
                    if (podiumMetaEl) {
                        const bits = [];
                        if (entrantsNum) bits.push(`${entrantsNum} entrants`);
                        if (roundsNum) bits.push(`${roundsNum} rounds`);
                        podiumMetaEl.textContent = bits.length ? bits.join(' ‚Ä¢ ') : '';
                    }

                    // Returnees (gap >= 3 years)
                    const participantsLatest = extractParticipantIds(latest);
                    const lastPlayedYear = new Map();
                    for (const t of allForSeed) {
                        if (!t || !Number.isFinite(Number(t.year)) || t.id === latest.id) continue;
                        const ids = extractParticipantIds(t);
                        for (const pid of ids) {
                            if (!lastPlayedYear.has(pid) || Number(t.year) > Number(lastPlayedYear.get(pid))) {
                                lastPlayedYear.set(pid, Number(t.year));
                            }
                        }
                    }
                    const returnees = [];
                    for (const pid of participantsLatest) {
                        const prev = lastPlayedYear.get(pid);
                        if (!prev) continue;
                        const gap = Number(latest.year) - Number(prev);
                        if (gap >= 3) {
                            returnees.push({ pid, prev });
                        }
                    }

                    // 12 / 13 trick hands (raw scorecards)
                    const yearNum = Number(latest.year);
                    const scorecards = Array.isArray(tournamentEngine.rawScorecards) ? tournamentEngine.rawScorecards : [];
                    const inLatestYear = scorecards.filter(sc => Number(sc?.Year) === yearNum);
                    const tricks12 = [];
                    const tricks13 = [];
                    for (const sc of inLatestYear) {
                        const tw = Number(sc?.Tricks_Won);
                        if (!Number.isFinite(tw)) continue;
                        if (tw === 12) tricks12.push(sc);
                        if (tw === 13) tricks13.push(sc);
                    }
                    const summarizeBigHands = (rows) => {
                        const byPlayer = new Map();
                        for (const r of rows) {
                            const p = String(r?.Player || '').trim();
                            if (!p) continue;
                            byPlayer.set(p, (byPlayer.get(p) || 0) + 1);
                        }
                        const top = Array.from(byPlayer.entries())
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 4)
                            .map(([p, c]) => `${safeName(p)} √ó${c}`);
                        return { total: rows.length, top };
                    };
                    if (tricks13.length) {
                        const s = summarizeBigHands(tricks13);
                        // queued to extra highlights below
                    }
                    if (tricks12.length) {
                        const s = summarizeBigHands(tricks12);
                        // queued to extra highlights below
                    }

                    // Seed narrative: new #1 + winner rank + movement
                    const currentOne = seedCurrent && seedCurrent[0] ? seedCurrent[0] : null;
                    const prevOne = seedBefore && seedBefore[0] ? seedBefore[0] : null;
                    const seedLeadText = (() => {
                        if (!(currentOne && currentOne.name)) return '';
                        if (prevOne && prevOne.name && currentOne.name !== prevOne.name) {
                            return `A new #1 seed emerges: ${safeName(currentOne.name)} (overtaking ${safeName(prevOne.name)}).`;
                        }
                        return `The current #1 seed remains ${safeName(currentOne.name)}.`;
                    })();

                    // Winner career context
                    let careerSentence = '';
                    if (champ?.player && typeof tournamentEngine.getPlayerStats === 'function') {
                        const stats = tournamentEngine.getPlayerStats(champ.player, true);
                        if (stats) {
                            const wins = Number(stats.tournament_wins) || 0;
                            const played = Number(stats.tournaments_played) || 0;
                            const playedEl = document.getElementById('winner-career-played');
                            if (playedEl) playedEl.textContent = `${played}`;
                            const winsEl = document.getElementById('winner-career-wins');
                            if (winsEl) winsEl.textContent = `${wins}`;
                            careerSentence = `${champName} now has ${wins} tournament win${wins === 1 ? '' : 's'} across ${played} tournament${played === 1 ? '' : 's'}.`;
                        }
                    }

                    // Late comeback heuristic (winner not leading after round N-3 but wins overall)
                    let comebackSentence = '';
                    if (champ?.player && latest?.rounds && Array.isArray(latest.rounds) && inLatestYear.length) {
                        const perRound = new Map(); // round -> Map<player, tricks>
                        for (const sc of inLatestYear) {
                            const r = Number(sc?.Round);
                            const p = String(sc?.Player || '').trim();
                            const tw = Number(sc?.Tricks_Won);
                            if (!Number.isFinite(r) || !p || !Number.isFinite(tw)) continue;
                            if (!perRound.has(r)) perRound.set(r, new Map());
                            const m = perRound.get(r);
                            m.set(p, (m.get(p) || 0) + tw);
                        }
                        const roundsSorted = Array.from(perRound.keys()).sort((a, b) => a - b);
                        const cutoffRound = roundsSorted.length >= 4 ? roundsSorted[roundsSorted.length - 3] : null;
                        if (cutoffRound !== null) {
                            const cumulative = new Map();
                            let winnerWasLeading = false;
                            let winnerPosAtCutoff = null;
                            for (const r of roundsSorted) {
                                const m = perRound.get(r);
                                for (const [p, tw] of m.entries()) {
                                    cumulative.set(p, (cumulative.get(p) || 0) + tw);
                                }
                                if (r === cutoffRound) {
                                    const sorted = Array.from(cumulative.entries()).sort((a, b) => (b[1] - a[1]));
                                    winnerWasLeading = sorted.length && sorted[0][0] === champ.player;
                                    winnerPosAtCutoff = sorted.findIndex(x => x[0] === champ.player) + 1;
                                }
                            }
                            if (!winnerWasLeading) {
                                const pos = Number.isFinite(Number(winnerPosAtCutoff)) && winnerPosAtCutoff > 0 ? winnerPosAtCutoff : null;
                                const ord = (pos && typeof tournamentEngine.getOrdinalSuffix === 'function')
                                    ? `${pos}${tournamentEngine.getOrdinalSuffix(pos)}`
                                    : (pos ? `${pos}th` : 'outside 1st');
                                comebackSentence = `A late surge sealed it: after round ${cutoffRound}, ${champName} was ${ord} ‚Äî then surged to win.`;
                            }
                        }
                    }

                    // Tournament story (bulleted)
                    const storyEl = document.getElementById('latest-tournament-story');
                    if (storyEl) {
                        storyEl.innerHTML = '';
                        const add = (txt) => {
                            if (!txt) return;
                            const li = document.createElement('li');
                            li.textContent = txt;
                            storyEl.appendChild(li);
                        };

                        if (champTricks !== null && champAvg !== null) {
                            add(`${champName} won ${latest.year} with ${champTricks} tricks (${champAvg.toFixed(2)} avg/round).`);
                        } else if (champTricks !== null) {
                            add(`${champName} won ${latest.year} with ${champTricks} tricks.`);
                        } else {
                            add(`${champName} took the title in ${latest.year}.`);
                        }

                        if (champSeed) {
                            add(`${champName} is now Seed #${champSeed.seed_rank} with ${champSeed.seed_points} points.`);
                        }
                        if (seedLeadText) add(seedLeadText);
                        if (careerSentence) add(careerSentence);
                        if (comebackSentence) add(comebackSentence);
                        if (booby && booby.player) {
                            add(`Booby prize: ${safeName(booby.player)}.`);
                        }

                        // Fold "More highlights" into the story list
                        if (returnees.length) {
                            const top = returnees
                                .sort((a, b) => (b.prev - a.prev))
                                .slice(0, 6)
                                .map(r => `${safeName(r.pid)} (last played ${r.prev})`);
                            add(`Returnees: ${top.join(', ')}`);
                        }
                        if (tricks13.length) {
                            const s = summarizeBigHands(tricks13);
                            add(`13-trick hands: ${s.total}${s.top.length ? ` (${s.top.join(', ')})` : ''}`);
                        }
                        if (tricks12.length) {
                            const s = summarizeBigHands(tricks12);
                            add(`12-trick hands: ${s.total}${s.top.length ? ` (${s.top.join(', ')})` : ''}`);
                        }

                        if (!storyEl.children.length) {
                            add('Story coming soon.');
                        }
                    }
                }

                // Hall of Fame: all-time champion (most tournament wins)
                const hofChampEl = document.getElementById('hof-alltime-champ');
                const hofChampSubEl = document.getElementById('hof-alltime-champ-sub');
                try {
                    const individuals = (typeof tournamentEngine.getAllIndividualPlayers === 'function')
                        ? tournamentEngine.getAllIndividualPlayers('tournament_wins')
                        : [];
                    if (individuals && individuals.length) {
                        const topWins = Number(individuals[0].tournament_wins) || 0;
                        const tied = individuals.filter(p => (Number(p.tournament_wins) || 0) === topWins);
                        const names = tied.slice(0, 3).map(p => safeName(p.name));
                        if (hofChampEl) hofChampEl.textContent = names.join(', ');
                        if (hofChampSubEl) {
                            hofChampSubEl.textContent = `${topWins} win${topWins === 1 ? '' : 's'}${tied.length > 3 ? ` ‚Ä¢ +${tied.length - 3} tied` : ''}`;
                        }
                    } else {
                        if (hofChampEl) hofChampEl.textContent = '‚Äî';
                        if (hofChampSubEl) hofChampSubEl.textContent = '';
                    }
                } catch (_) {
                    if (hofChampEl) hofChampEl.textContent = '‚Äî';
                    if (hofChampSubEl) hofChampSubEl.textContent = '';
                }

                // Stats: best partnership (by avg tricks/round) + longest win streak
                const statsBestEl = document.getElementById('stats-best-partnership');
                const statsBestSubEl = document.getElementById('stats-best-partnership-sub');
                const statsStreakEl = document.getElementById('stats-longest-win-streak');
                const statsStreakSubEl = document.getElementById('stats-longest-win-streak-sub');

                try {
                    const pr = (typeof tournamentEngine.getPartnershipPerformanceRankings === 'function')
                        ? tournamentEngine.getPartnershipPerformanceRankings()
                        : [];
                    const MIN_PAIRINGS = 4;
                    const best = (pr || []).find(p => (Number(p.partnerships_count) || 0) >= MIN_PAIRINGS) || (pr && pr[0]) || null;
                    if (best && Array.isArray(best.players) && best.players.length === 2) {
                        const a = best.players[0];
                        const b = best.players[1];
                        if (statsBestEl) statsBestEl.textContent = `${best.average_tricks.toFixed(2)} avg/round`;
                        if (statsBestSubEl) statsBestSubEl.textContent = `${safeName(a)} & ${safeName(b)} ‚Ä¢ ${Number(best.partnerships_count || best.total_rounds || 0)} games`;
                    } else {
                        if (statsBestEl) statsBestEl.textContent = '‚Äî';
                        if (statsBestSubEl) statsBestSubEl.textContent = '';
                    }

                    // Longest win streak across partnerships (shared hands excluded; min 4 games) ‚Äî match the Stats page logic.
                    const eligible = (pr || []).filter(p => (Number(p.partnerships_count) || 0) >= MIN_PAIRINGS);
                    const allowedKeys = new Set(eligible.map(p => p.partnership));
                    const rankingByKey = new Map(eligible.map(p => [p.partnership, p]));

                    const winAggByKey = new Map(); // key -> {played, games:[{year,round,table,isWin}]}
                    for (const t of (tournamentEngine.tournaments ? tournamentEngine.tournaments.values() : [])) {
                        if (!t || !Array.isArray(t.rounds)) continue;
                        const year = Number.isFinite(t.year) ? t.year : (Number.isFinite(t.Year) ? t.Year : parseInt(t.year || t.Year || '0'));
                        for (const r of t.rounds) {
                            if (!r || !Array.isArray(r.tables)) continue;
                            const roundNum = Number.isFinite(r.round) ? r.round : (Number.isFinite(r.Round) ? r.Round : parseInt(r.round || r.Round || '0'));
                            for (const table of r.tables) {
                                if (!table || !Array.isArray(table.partnerships)) continue;
                                const tableNum = Number.isFinite(table.table) ? table.table : parseInt(table.table || table.Table || '0');
                                for (const p of table.partnerships) {
                                    const pos1IsShared = p.position1 && p.position1.length > 1;
                                    const pos2IsShared = p.position2 && p.position2.length > 1;
                                    if (pos1IsShared || pos2IsShared) continue;
                                    const a = p.position1 && p.position1[0];
                                    const b = p.position2 && p.position2[0];
                                    if (!a || !b) continue;
                                    const key = [a, b].sort().join(' & ');
                                    if (!allowedKeys.has(key)) continue;
                                    const tricks = Number.isFinite(p.tricks) ? p.tricks : parseFloat(p.tricks);
                                    if (!Number.isFinite(tricks)) continue;

                                    if (!winAggByKey.has(key)) winAggByKey.set(key, { played: 0, games: [] });
                                    const rec = winAggByKey.get(key);
                                    rec.played += 1;
                                    rec.games.push({
                                        year: Number.isFinite(year) ? year : 0,
                                        round: Number.isFinite(roundNum) ? roundNum : 0,
                                        table: Number.isFinite(tableNum) ? tableNum : 0,
                                        isWin: tricks >= 7
                                    });
                                }
                            }
                        }
                    }

                    const longestByKey = new Map(); // key -> {played, longestWinStreak}
                    for (const key of allowedKeys.values()) {
                        const rec = winAggByKey.get(key) || { played: 0, games: [] };
                        const played = Number.isFinite(rec.played) ? rec.played : 0;
                        const games = Array.isArray(rec.games) ? rec.games.slice() : [];
                        games.sort((a, b) => (a.year - b.year) || (a.round - b.round) || (a.table - b.table));
                        let longestWinStreak = 0;
                        let w = 0;
                        for (const g of games) {
                            if (g && g.isWin) {
                                w += 1;
                                if (w > longestWinStreak) longestWinStreak = w;
                            } else {
                                w = 0;
                            }
                        }
                        longestByKey.set(key, { played, longestWinStreak });
                    }

                    const bestLongestWin = Math.max(0, ...Array.from(longestByKey.values()).map(m => ((m.played >= MIN_PAIRINGS) ? (m.longestWinStreak || 0) : 0)));
                    const tieKeys = bestLongestWin > 0
                        ? Array.from(longestByKey.entries())
                            .filter(([k, m]) => (m.played >= MIN_PAIRINGS) && ((m.longestWinStreak || 0) === bestLongestWin))
                            .sort((a, b) => (b[1].played - a[1].played) || String(a[0]).localeCompare(String(b[0])))
                            .map(([k]) => k)
                        : [];

                    if (bestLongestWin > 0 && tieKeys.length) {
                        const pick = rankingByKey.get(tieKeys[0]);
                        const a = pick?.players?.[0];
                        const b = pick?.players?.[1];
                        if (statsStreakEl) statsStreakEl.textContent = `${bestLongestWin}`;
                        if (statsStreakSubEl) {
                            const label = (a && b) ? `${safeName(a)} & ${safeName(b)}` : tieKeys[0];
                            statsStreakSubEl.textContent = `${label}${tieKeys.length > 1 ? ` ‚Ä¢ ${tieKeys.length} tied` : ''}`;
                        }
                    } else {
                        if (statsStreakEl) statsStreakEl.textContent = '‚Äî';
                        if (statsStreakSubEl) statsStreakSubEl.textContent = '';
                    }
                } catch (_) {
                    if (statsBestEl) statsBestEl.textContent = '‚Äî';
                    if (statsBestSubEl) statsBestSubEl.textContent = '';
                    if (statsStreakEl) statsStreakEl.textContent = '‚Äî';
                    if (statsStreakSubEl) statsStreakSubEl.textContent = '';
                }

                // Home history
                const historyEl = document.getElementById('home-history-description');
                if (historyEl) {
                    let desc = (tournamentEngine && typeof tournamentEngine.getHistoryValue === 'function')
                        ? String(tournamentEngine.getHistoryValue('Preview') || tournamentEngine.getHistoryValue('Description') || '')
                        : '';
                    if (!desc.trim()) {
                        desc = await loadHistoryDescription(tournamentEngine, sheetId);
                    }
                    historyEl.textContent = (desc && desc.trim()) ? desc.trim() : 'History coming soon.';
                }

                // Recent tournaments list in archive section
                const recentList = document.getElementById('recent-tournaments-list');
                if (recentList) {
                    recentList.innerHTML = '';
                    const last = uniqueDesc.slice(0, 5);
                    last.forEach(t => {
                        const li = document.createElement('li');
                        const year = (t && Number.isFinite(Number(t.year))) ? t.year : '';
                        const winner = t && t.winner ? safeName(t.winner) : '‚Äî';
                        const a = document.createElement('a');
                        a.href = `tournaments/results.html?year=${encodeURIComponent(year)}`;
                        a.textContent = `${year} ‚Ä¢ ${t.name} ‚Ä¢ Winner: ${winner}`;
                        a.style.color = 'inherit';
                        a.style.textDecoration = 'none';
                        a.addEventListener('mouseenter', () => { a.style.textDecoration = 'underline'; });
                        a.addEventListener('mouseleave', () => { a.style.textDecoration = 'none'; });
                        li.appendChild(a);
                        recentList.appendChild(li);
                    });
                    if (!last.length) {
                        const li = document.createElement('li');
                        li.textContent = 'No tournaments found.';
                        recentList.appendChild(li);
                    }
                }

                // Metrics in players section
                const setMetric = (id, value) => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = value;
                };
                setMetric('home-metric-players', `${competedCount || rosterCount || 0}`);
                setMetric('home-metric-tournaments', `${tournaments.length}`);
                setMetric('home-metric-rounds', `${totalRounds}`);

                console.log('‚úÖ Home page data loaded successfully!');
                
            } catch (error) {
                const detail = (error && error.stack) ? error.stack : String(error);
                console.error('‚ùå Error loading tournament data:', detail);
                // Keep fallback content if data loading fails
            }
        });
    </script>

    <style>
        /* Home: winner spotlight + history + feature sections */
        .home-winner-section {
            padding: var(--spacing-3xl) 0;
            background: var(--bg-secondary);
        }

        .champion-section-title {
            color: rgba(255, 255, 255, 0.92);
            font-family: var(--font-primary);
            font-weight: 900;
            font-size: 2.2rem;
            text-align: center;
            margin-bottom: 1.25rem;
        }

        .winner-card {
            max-width: 920px;
            margin: 0 auto;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(255, 247, 224, 0.92) 100%);
            border-radius: var(--border-radius-xl);
            padding: var(--spacing-2xl);
            box-shadow: var(--shadow-lg);
            border: 1px solid rgba(212, 175, 55, 0.24);
            text-align: center;
        }

        .winner-kicker {
            font-weight: 900;
            letter-spacing: 0.06em;
            color: var(--text-secondary-dark);
            margin-bottom: 0.9rem;
        }

        .winner-year {
            font-family: var(--font-primary);
            font-weight: 900;
            font-size: 2.6rem;
            letter-spacing: 0.02em;
            color: var(--text-primary-dark);
            line-height: 1.05;
        }

        .winner-tournament-name {
            margin-top: 0.25rem;
            font-weight: 900;
            font-size: 1.05rem;
            letter-spacing: 0.08em;
            color: var(--text-secondary-dark);
        }

        .winner-trophy {
            font-size: 3.6rem;
            line-height: 1;
            margin: 0.25rem 0 0.35rem;
        }

        .winner-name {
            font-family: var(--font-primary);
            font-weight: 900;
            font-size: 3rem;
            line-height: 1.02;
            color: var(--text-primary-dark);
        }

        .winner-badge {
            margin-top: 0.25rem;
            font-weight: 900;
            letter-spacing: 0.10em;
            text-transform: uppercase;
            color: var(--text-secondary-dark);
        }

        .winner-tricks-line {
            margin-top: 1.05rem;
            font-weight: 950;
            font-size: 2.25rem;
            color: var(--gold);
            text-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);
        }

        .winner-avg-line {
            margin-top: 0.35rem;
            font-weight: 800;
            font-size: 1.1rem;
            color: var(--text-secondary-dark);
            margin-bottom: 1.35rem;
        }

        .winner-stats-row {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: var(--spacing-lg);
            margin-bottom: 0;
        }

        .winner-stat {
            background: rgba(15, 23, 42, 0.04);
            border-radius: var(--border-radius-lg);
            padding: 1rem 1.1rem;
            border: 1px solid rgba(15, 23, 42, 0.06);
        }

        .winner-stat-number {
            font-weight: 900;
            font-size: 1.6rem;
            color: var(--text-primary-dark);
        }

        .winner-stat-label {
            margin-top: 0.2rem;
            color: var(--text-secondary-dark);
            font-weight: 700;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .latest-highlights {
            max-width: 980px;
            margin: var(--spacing-2xl) auto 0;
        }

        .latest-highlights-header {
            display: flex;
            align-items: flex-end;
            justify-content: space-between;
            gap: var(--spacing-lg);
            margin-bottom: 1rem;
        }

        .latest-highlights-heading {
            color: rgba(255, 255, 255, 0.92);
            font-family: var(--font-primary);
            font-weight: 900;
            text-align: left;
            font-size: 1.8rem;
            margin-bottom: 0;
        }

        .latest-highlights-tournament {
            text-align: right;
            color: rgba(255, 255, 255, 0.92);
        }

        .latest-highlights-year {
            font-weight: 950;
            font-size: 1.1rem;
            letter-spacing: 0.02em;
            line-height: 1.1;
        }

        .latest-highlights-name {
            font-weight: 850;
            font-size: 0.95rem;
            opacity: 0.9;
            line-height: 1.15;
        }

        .latest-top-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
            align-items: start;
        }

        .latest-story {
            color: rgba(255, 255, 255, 0.92);
            text-align: left;
            padding-right: var(--spacing-md);
        }

        .latest-story-title {
            font-weight: 900;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.75);
            font-size: 0.85rem;
            margin-bottom: 0.55rem;
        }

        .latest-story-text {
            color: rgba(255, 255, 255, 0.92);
            line-height: 1.7;
            font-weight: 600;
        }

        .latest-story-list {
            margin: 0.35rem 0 0;
            padding-left: 1.1rem;
            color: rgba(255, 255, 255, 0.92);
            line-height: 1.65;
            font-weight: 650;
        }

        .latest-story-list li {
            margin: 0.45rem 0;
        }

        .latest-podium-side {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
        }

        .latest-podium-meta {
            color: rgba(255, 255, 255, 0.88);
            font-weight: 800;
            letter-spacing: 0.02em;
            font-size: 0.92rem;
            text-align: right;
            margin-top: 0.15rem;
        }

        .mini-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: var(--border-radius-lg);
            padding: 1rem 1.05rem;
            border: 1px solid rgba(15, 23, 42, 0.10);
            box-shadow: var(--shadow-card);
            text-align: left;
        }

        .mini-kicker {
            font-weight: 900;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: rgba(15, 23, 42, 0.65);
            font-size: 0.78rem;
            margin-bottom: 0.35rem;
        }

        .mini-value {
            font-weight: 950;
            color: var(--text-primary-dark);
            font-size: 1.25rem;
            line-height: 1.1;
        }

        .mini-subvalue {
            margin-top: 0.35rem;
            color: rgba(15, 23, 42, 0.70);
            font-weight: 800;
            font-size: 0.95rem;
        }

        .mini-card--silver {
            background: linear-gradient(135deg, rgba(241, 245, 249, 0.98) 0%, rgba(226, 232, 240, 0.98) 100%);
        }

        .mini-card--bronze {
            background: linear-gradient(135deg, rgba(255, 247, 237, 0.98) 0%, rgba(254, 215, 170, 0.55) 100%);
        }

        .latest-extra-card {
            background: rgba(255, 255, 255, 0.96);
            border-radius: var(--border-radius-xl);
            padding: var(--spacing-xl);
            border: 1px solid rgba(15, 23, 42, 0.10);
            box-shadow: var(--shadow-card);
            margin-bottom: var(--spacing-xl);
            text-align: left;
        }

        .latest-extra-title {
            font-weight: 950;
            color: var(--text-primary-dark);
            font-size: 1.15rem;
            margin-bottom: 0.45rem;
        }

        .latest-extra-list {
            margin: 0;
            padding-left: 1.25rem;
            color: var(--text-primary-dark);
            line-height: 1.6;
            font-weight: 600;
        }

        .latest-extra-list li {
            margin: 0.35rem 0;
        }

        .latest-cta {
            display: flex;
            justify-content: center;
            margin-top: var(--spacing-xl);
        }

        .latest-cta .btn {
            padding: 0.9rem 1.25rem;
        }

        .home-history-section {
            padding: var(--spacing-3xl) 0;
            background: white;
        }
        .home-history-section .section-title {
            color: var(--text-primary-dark);
        }

        .history-card {
            background: transparent;
            border-radius: 0;
            padding: 0;
            border: 0;
            box-shadow: none;
        }

        .history-text {
            color: var(--text-primary-dark);
            font-size: 1.08rem;
            line-height: 1.8;
            white-space: pre-line;
            font-style: normal;
            font-weight: 400;
            font-family: "Courgette", "Playfair Display", Georgia, serif;
            max-width: 70ch;
            margin: 0 auto;
        }

        .history-actions {
            display: flex;
            justify-content: center;
            margin-top: var(--spacing-md);
        }

        .history-actions .btn {
            padding: 0.75rem 1.1rem;
        }

        .home-feature-section {
            padding: var(--spacing-3xl) 0;
            background: var(--bg-secondary);
        }

        .home-feature-section--players,
        .home-feature-section--stats {
            background: white;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: 1.2fr 0.8fr;
            gap: var(--spacing-xl);
            align-items: stretch;
        }

        .feature-copy {
            text-align: center;
        }

        .feature-copy .section-title,
        .feature-copy .section-subtitle {
            text-align: inherit;
        }

        .feature-copy .section-subtitle {
            margin-top: 0.35rem;
        }

        .feature-actions {
            margin-top: var(--spacing-lg);
            display: flex;
            justify-content: center;
        }

        .feature-panel {
            background: rgba(255, 255, 255, 0.96);
            border: 1px solid rgba(15, 23, 42, 0.08);
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-card);
        }

        .feature-panel-title {
            font-weight: 900;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: var(--text-secondary-dark);
            margin-bottom: 0.65rem;
        }

        .feature-panel-text {
            margin: 0;
            color: var(--text-primary-dark);
            line-height: 1.55;
        }

        .feature-list {
            margin: 0;
            padding-left: 1.25rem;
            color: var(--text-primary-dark);
            line-height: 1.55;
        }

        .feature-list li {
            margin: 0.35rem 0;
        }

        .feature-metrics {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: var(--spacing-md);
        }

        .feature-metrics--stack {
            display: flex;
            flex-direction: column;
            gap: 0.65rem;
        }

        .feature-metrics--stack .feature-metric {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: var(--spacing-lg);
            background: transparent;
            border: none;
            padding: 0;
        }

        .feature-metrics--stack .feature-metric:not(:last-child) {
            padding-bottom: 0.65rem;
            border-bottom: 1px solid rgba(15, 23, 42, 0.08);
        }

        .feature-metrics--stack .feature-metric-number {
            font-size: 1.55rem;
        }

        .feature-metrics--stack .feature-metric-label {
            margin-top: 0;
            text-align: right;
        }

        .feature-metric {
            background: white;
            border-radius: var(--border-radius-md);
            padding: 0.8rem 0.9rem;
            border: 1px solid rgba(15, 23, 42, 0.08);
        }

        .feature-metric-number {
            font-weight: 900;
            font-size: 1.4rem;
            color: var(--text-primary-dark);
        }

        .feature-metric-label {
            margin-top: 0.2rem;
            color: var(--text-secondary-dark);
            font-weight: 700;
            font-size: 0.85rem;
            letter-spacing: 0.04em;
            text-transform: uppercase;
        }

        .feature-panel-metrics {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: var(--spacing-md);
        }

        .feature-panel-metric {
            background: rgba(15, 23, 42, 0.04);
            border: 1px solid rgba(15, 23, 42, 0.08);
            border-radius: var(--border-radius-md);
            padding: 0.85rem 0.9rem;
        }

        .feature-panel-kicker {
            font-weight: 900;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: var(--text-secondary-dark);
            font-size: 0.78rem;
            margin-bottom: 0.35rem;
        }

        .feature-panel-value {
            font-weight: 950;
            color: var(--text-primary-dark);
            font-size: 1.25rem;
            line-height: 1.15;
        }

        .feature-panel-subvalue {
            margin-top: 0.35rem;
            color: var(--text-secondary-dark);
            font-weight: 700;
            font-size: 0.95rem;
        }

        .seed-mini-table {
            display: flex;
            flex-direction: column;
            gap: 0.55rem;
            margin-top: 0.15rem;
        }

        .seed-mini-row {
            display: grid;
            grid-template-columns: 3.5ch 1fr 6.5ch 96px;
            align-items: center;
            gap: 0.65rem;
            background: rgba(15, 23, 42, 0.04);
            border: 1px solid rgba(15, 23, 42, 0.08);
            border-radius: var(--border-radius-md);
            padding: 0.75rem 0.8rem;
        }

        .seed-mini-row--highlight {
            background: rgba(217, 175, 61, 0.12);
            border-color: rgba(217, 175, 61, 0.28);
        }

        .seed-mini-rank {
            font-weight: 950;
            color: var(--text-primary-dark);
            font-size: 0.95rem;
        }

        .seed-mini-name {
            font-weight: 900;
            color: var(--text-primary-dark);
            font-size: 1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .seed-mini-points {
            font-weight: 900;
            color: var(--text-primary-dark);
            font-size: 0.95rem;
            text-align: right;
        }

        .seed-mini-trend {
            display: flex;
            justify-content: flex-end;
            align-items: center;
        }

        .seed-mini-footer {
            margin-top: 0.8rem;
            padding-top: 0.75rem;
            border-top: 1px solid rgba(15, 23, 42, 0.10);
            color: var(--text-secondary-dark);
            font-weight: 750;
            font-size: 0.95rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
        }

        .seed-mini-footer-label {
            font-weight: 900;
            color: var(--text-primary-dark);
        }

        .seed-mini-footer-value {
            font-weight: 950;
            color: var(--text-primary-dark);
        }

        .seed-mini-footer-sub {
            color: var(--text-secondary-dark);
            font-weight: 750;
        }

        .home-seedwatch-section {
            /* Match the site's poker-green section styling (same as Tournament Archive background) */
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-accent) 100%);
            padding: var(--spacing-3xl) 0;
        }
        .home-seedwatch-section .section-title,
        .home-seedwatch-section .section-subtitle {
            color: #ffffff;
        }
        .seedwatch-card {
            margin-top: 0.75rem;
            background: rgba(255, 255, 255, 0.96);
            border-radius: var(--border-radius-lg);
            border: 1px solid rgba(15, 23, 42, 0.10);
            box-shadow: var(--shadow-card);
            padding: var(--spacing-lg);
            backdrop-filter: none;
        }

        /* Keep the section header white, but make the table readable on the white card */
        .home-seedwatch-section .seedwatch-card .seed-mini-row {
            background: rgba(15, 23, 42, 0.04);
            border: 1px solid rgba(15, 23, 42, 0.08);
        }
        .home-seedwatch-section .seedwatch-card .seed-mini-row--highlight {
            background: rgba(217, 175, 61, 0.12);
            border-color: rgba(217, 175, 61, 0.28);
        }
        .home-seedwatch-section .seedwatch-card .seed-mini-rank,
        .home-seedwatch-section .seedwatch-card .seed-mini-name,
        .home-seedwatch-section .seedwatch-card .seed-mini-points {
            color: var(--text-primary-dark);
        }
        .home-seedwatch-section .seedwatch-card .seed-mini-trend {
            color: var(--text-secondary-dark);
            font-weight: 900;
        }

        /* Center-align the descriptions for Seed watch and Era/Decade sections */
        .home-seedwatch-section .section-title,
        .home-seedwatch-section .section-subtitle,
        .home-feature-section--tables .section-title,
        .home-feature-section--tables .section-subtitle {
            text-align: center;
        }

        .home-decade-table-wrap {
            overflow: auto;
            margin-top: 0.35rem;
            border-radius: var(--border-radius-md);
            border: 1px solid rgba(15, 23, 42, 0.10);
        }
        .home-decade-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 640px;
            background: rgba(255, 255, 255, 0.96);
        }
        .home-decade-table th,
        .home-decade-table td {
            padding: 0.65rem 0.75rem;
            border-bottom: 1px solid rgba(15, 23, 42, 0.08);
            color: var(--text-primary-dark);
            font-weight: 700;
            font-size: 0.92rem;
            white-space: nowrap;
        }
        .home-decade-table thead th {
            background: rgba(15, 23, 42, 0.03);
            font-weight: 900;
            color: rgba(15, 23, 42, 0.70);
            text-transform: uppercase;
            letter-spacing: 0.06em;
            font-size: 0.78rem;
        }
        .home-decade-table thead th.col-name,
        .home-decade-table td.col-name {
            text-align: left;
        }
        .home-decade-table .col-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 220px;
        }
        .home-decade-table .col-n,
        .home-decade-table .col-rank,
        .home-decade-table .col-tricks,
        .home-decade-table .col-points {
            text-align: right;
        }
        .home-decade-table__points {
            font-weight: 950 !important;
            color: var(--gold) !important;
        }

        .seedwatch-grid {
            grid-template-columns: 1.05fr 0.95fr;
        }

        /* Tables feature section should be white (alternate background) */
        .home-feature-section--tables {
            background: #ffffff;
            color: var(--text-primary-dark);
        }
        .home-feature-section--tables .section-title,
        .home-feature-section--tables .section-subtitle {
            color: var(--text-primary-dark);
        }

        .latest-day-notes {
            display: grid;
            gap: 0.6rem;
            margin-top: 0.6rem;
        }
        .latest-note {
            padding: 0.65rem 0.75rem;
            border-radius: 14px;
            border: 1px solid rgba(15, 23, 42, 0.10);
            background: rgba(15, 23, 42, 0.03);
        }
        .latest-note__kicker {
            font-weight: 950;
            color: var(--text-primary-dark);
            font-size: 0.85rem;
            margin-bottom: 0.2rem;
        }
        .latest-note__body {
            color: var(--text-secondary-dark);
            font-weight: 600;
            font-size: 0.92rem;
            line-height: 1.35;
            white-space: pre-wrap;
        }
        .latest-note__meta {
            margin-top: 0.35rem;
            font-size: 0.85rem;
            color: rgba(15, 23, 42, 0.65);
            font-weight: 700;
        }
        .latest-cover-strip {
            margin-top: 0.75rem;
            display: grid;
            grid-template-columns: repeat(6, minmax(0, 1fr));
            gap: 0.6rem;
        }
        .latest-cover-strip a {
            display: block;
            border-radius: 14px;
            overflow: hidden;
            border: 1px solid rgba(15, 23, 42, 0.10);
            background: rgba(15, 23, 42, 0.04);
            aspect-ratio: 16 / 10;
        }
        .latest-cover-strip a img { width: 100%; height: 100%; object-fit: cover; display:block; }
        @media (max-width: 980px) { .latest-cover-strip { grid-template-columns: repeat(3, minmax(0, 1fr)); } }
        @media (max-width: 520px) { .latest-cover-strip { grid-template-columns: repeat(2, minmax(0, 1fr)); } }

        /* Feature sections: default is dark background (white text). Only force dark text on the white sections. */
        .home-feature-section--players,
        .home-feature-section--stats {
            color: var(--text-primary-dark);
        }
        .home-feature-section--players .section-title,
        .home-feature-section--players .section-subtitle,
        .home-feature-section--stats .section-title,
        .home-feature-section--stats .section-subtitle {
            color: var(--text-primary-dark);
        }
        .home-feature-section--players .section-subtitle,
        .home-feature-section--stats .section-subtitle {
            color: var(--text-secondary-dark);
        }

        @media (max-width: 960px) {
            .winner-name { font-size: 2.45rem; }
            .winner-stats-row { grid-template-columns: 1fr; }
            .feature-grid { grid-template-columns: 1fr; }
            .latest-highlights-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.45rem;
            }
            .latest-highlights-tournament { text-align: left; }
            .latest-top-grid { grid-template-columns: 1fr; }
            .feature-panel-metrics { grid-template-columns: 1fr; }
            .latest-podium-meta { text-align: left; }
            .seed-mini-row { grid-template-columns: 3.5ch 1fr 6.5ch 1fr; }
        }

        @media (max-width: 560px) {
            .winner-card { padding: var(--spacing-xl); }
            .winner-year { font-size: 2.25rem; }
            .winner-trophy { font-size: 3rem; }
            .champion-section-title { font-size: 1.85rem; }
            .feature-metrics { grid-template-columns: 1fr; }
        }
    </style>
</body>
</html>