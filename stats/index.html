<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Statistics & Analytics | Ruston Family Whist Drive</title>
    <meta name="description" content="Deep statistical analysis and visualizations from 40 years of championship data">
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=Inter:wght@400;500;600&display=block" rel="stylesheet">
    <script src="/assets/js/footer-nav.js?v=2" defer></script>
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo-section">
                    <div class="card-suits"><span class="heart">‚ô•</span> <span class="club">‚ô£</span> <span class="diamond">‚ô¶</span> <span class="spade">‚ô†</span></div>
                    <h1 class="site-title">Ruston Family Whist Drive</h1>
                    <p class="site-subtitle">Est. 1984 ‚Ä¢ The World's Most Elite Family Tournament</p>
                </div>
                <nav class="main-nav">
                    <a href="../" class="nav-link">Home</a>
                    <a href="../tournaments/" class="nav-link">Tournaments</a>
                    <a href="../tables/" class="nav-link">Tables</a>
                    <a href="../players/" class="nav-link">Players</a>
                    <a href="../leaderboard/" class="nav-link">Hall of Fame</a>
                    <a href="#" class="nav-link active">Statistics</a>
                </nav>
            </div>
        </div>
    </header>

    <main class="main-content">
        <section class="stats-hero">
            <div class="container">
                <div class="hero-content">
                    <div class="analytics-badge">üìä ADVANCED ANALYTICS</div>
                    <h1 class="hero-title">Tournament Statistics & Analysis</h1>
                    <p class="hero-subtitle">Deep insights from decades of championship data, performance trends, and strategic analysis</p>
                </div>
            </div>
        </section>

        <section class="partnership-performance-section">
            <div class="container">
                <h2 class="section-title">
                    <span class="title-icon">ü§ù</span>
                    Partnership Performance Rankings
                </h2>

                <p class="section-subtitle">Strongest two-player partnerships across all rounds (shared hands excluded). Minimum 4 times paired.</p>

                <div class="insight-grid" id="partnership-insights">
                    <div class="loading-message">Loading partnership insights...</div>
                </div>
                
                <div class="partnership-rankings" id="partnership-rankings">
                    <!-- Partnership rankings will be loaded dynamically -->
                </div>
            </div>
        </section>

        <section class="family-statistics-section">
            <div class="container">
                <h2 class="section-title">
                    <span class="title-icon">üë®‚Äçüë©‚Äçüëß‚Äçüë¶</span>
                    Family Statistics
                </h2>

                <p class="section-subtitle">Families are discovered from George &amp; Doris‚Äô descendant line (surname-based). Partners / co-parents count as members; LinkedTo connections count as honorary members (honorary members are not included in the stats).</p>

                <div class="insight-grid" id="family-insights">
                    <div class="loading-message">Loading family insights...</div>
                </div>
                
                <div class="family-stats" id="family-stats">
                    <!-- Family statistics will be loaded dynamically -->
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div data-footer-nav></div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2024 Ruston Family Whist Drive. Advanced analytics from real tournament data.</p>
            </div>
        </div>
    </footer>

            <script src="../assets/js/tournament-engine.js?v=cache3"></script>
    
    <script>
        // Load real statistical data
        document.addEventListener('DOMContentLoaded', async function() {
            const tournamentEngine = new TournamentEngine();
            const sheetId = '1HGfdlDOfGHOL6Q4MP_TnF8UNE6YihBW-5gQs6Ykl78k';
            window.tournamentEngine = tournamentEngine;
            
            try {
                console.log('üìä Loading focused statistics...');
                await tournamentEngine.loadFromGoogleSheets(sheetId);

                // Focused: Partnerships + Families only
                loadPartnershipRankings();
                loadFamilyStatistics();

                // Footer: keep it simple and useful
                const tournamentsList = (typeof tournamentEngine.getAllTournamentsUnique === 'function')
                    ? tournamentEngine.getAllTournamentsUnique('desc')
                    : Array.from(tournamentEngine.tournaments.values());
                const totalRoundsCount = tournamentsList.reduce((sum, t) => sum + (Number.isFinite(t.total_rounds) ? t.total_rounds : 0), 0);
                const yearsList = tournamentsList.map(t => t.year).filter(y => Number.isFinite(y)).sort((a, b) => a - b);
                const firstYearValue = yearsList.length ? yearsList[0] : null;
                const lastYearValue = yearsList.length ? yearsList[yearsList.length - 1] : null;
                const totalEl = document.getElementById('total-scorecards');
                if (totalEl) totalEl.textContent = `${totalRoundsCount.toLocaleString()} Rounds Analyzed`;
                const spanEl = document.getElementById('data-timespan');
                if (spanEl) spanEl.textContent = (firstYearValue && lastYearValue) ? `${firstYearValue}‚Äì${lastYearValue}` : '‚Äî';

                console.log('‚úÖ Focused statistics loaded successfully!');
                return;
                
                const players = tournamentEngine.getAllPlayers('total_tricks');
                const tournaments = Array.from(tournamentEngine.tournaments.values());
                
                // Calculate comprehensive statistics
                const totalPlayers = players.length;
                const totalTournaments = tournaments.length;
                const totalRounds = tournaments.reduce((sum, t) => sum + t.total_rounds, 0);
                const totalTricks = players.reduce((sum, p) => sum + p.total_tricks, 0);
                
                const uniqueChampions = new Set(tournaments.map(t => t.winner)).size;
                const averagePlayersPerTournament = totalPlayers / totalTournaments;
                
                // Find top performers
                const topPlayer = players[0];
                const championships = tournaments.filter(t => t.winner === topPlayer.name).length;
                
                // Tournament timespan
                const years = tournaments.map(t => t.year).sort((a, b) => a - b);
                const firstYear = years[0];
                const lastYear = years[years.length - 1];
                
                // Generate overview statistics
                const overviewHTML = `
                    <div class="overview-stat-card">
                        <div class="stat-icon">üë•</div>
                        <div class="stat-number">${totalPlayers}</div>
                        <div class="stat-label">Total Players</div>
                        <div class="stat-detail">Across ${totalTournaments} tournaments</div>
                    </div>
                    <div class="overview-stat-card">
                        <div class="stat-icon">üèÜ</div>
                        <div class="stat-number">${totalTournaments}</div>
                        <div class="stat-label">Tournaments</div>
                        <div class="stat-detail">${firstYear} - ${lastYear}</div>
                    </div>
                    <div class="overview-stat-card">
                        <div class="stat-icon">üéØ</div>
                        <div class="stat-number">${totalTricks.toLocaleString()}</div>
                        <div class="stat-label">Total Tricks</div>
                        <div class="stat-detail">${totalRounds} rounds played</div>
                    </div>
                    <div class="overview-stat-card">
                        <div class="stat-icon">üëë</div>
                        <div class="stat-number">${uniqueChampions}</div>
                        <div class="stat-label">Different Champions</div>
                        <div class="stat-detail">Competitive balance</div>
                    </div>
                `;
                
                document.getElementById('overview-stats-grid').innerHTML = overviewHTML;
                
                // Generate analytics cards
                const topPerformers = players.slice(0, 5);
                const averageTricks = totalTricks / (totalPlayers * totalRounds / totalPlayers);
                
                const analyticsHTML = `
                    <div class="analytics-card">
                        <h3 class="card-title">
                            <span class="card-icon">üèÜ</span>
                            Top Performers
                        </h3>
                        <div class="performers-list">
                            ${topPerformers.map((player, index) => `
                                <div class="performer-item">
                                    <span class="rank">${index + 1}.</span>
                                    <span class="name">${player.name}</span>
                                    <span class="tricks">${player.total_tricks} tricks</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div class="analytics-card">
                        <h3 class="card-title">
                            <span class="card-icon">üìà</span>
                            Performance Distribution
                        </h3>
                        <div class="distribution-stats">
                            <div class="dist-item">
                                <span class="label">High Performers (>avg):</span>
                                <span class="value">${players.filter(p => p.total_tricks / p.tournaments_played > averageTricks).length}</span>
                            </div>
                            <div class="dist-item">
                                <span class="label">Average Performers:</span>
                                <span class="value">${players.filter(p => {
                                    const avg = p.total_tricks / p.tournaments_played;
                                    return avg <= averageTricks && avg >= averageTricks * 0.8;
                                }).length}</span>
                            </div>
                            <div class="dist-item">
                                <span class="label">Developing Players:</span>
                                <span class="value">${players.filter(p => p.total_tricks / p.tournaments_played < averageTricks * 0.8).length}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="analytics-card">
                        <h3 class="card-title">
                            <span class="card-icon">üéØ</span>
                            Tournament Competition
                        </h3>
                        <div class="competition-stats">
                            <div class="comp-item">
                                <span class="label">Average Players per Tournament:</span>
                                <span class="value">${averagePlayersPerTournament.toFixed(1)}</span>
                            </div>
                            <div class="comp-item">
                                <span class="label">Championship Repeats:</span>
                                <span class="value">${tournaments.length - uniqueChampions}</span>
                            </div>
                            <div class="comp-item">
                                <span class="label">Most Championships:</span>
                                <span class="value">${championships} (${topPlayer.name})</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="analytics-card">
                        <h3 class="card-title">
                            <span class="card-icon">üìÖ</span>
                            Historical Timeline
                        </h3>
                        <div class="timeline-stats">
                            <div class="time-item">
                                <span class="label">Tournament Era:</span>
                                <span class="value">${lastYear - firstYear + 1} years</span>
                            </div>
                            <div class="time-item">
                                <span class="label">Most Recent Champion:</span>
                                <span class="value">${tournaments[0].winner}</span>
                            </div>
                            <div class="time-item">
                                <span class="label">Longest Active Player:</span>
                                <span class="value">${topPlayer.tournaments_played} tournaments</span>
                            </div>
                        </div>
                    </div>
                `;
                
                document.getElementById('analytics-grid').innerHTML = analyticsHTML;
                
                // Generate advanced metrics
                const trumpSuitAnalysis = calculateTrumpSuitAnalysis(tournaments);
                const partnershipAnalysis = calculatePartnershipAnalysis(tournaments);
                
                const metricsHTML = `
                    <div class="metric-category">
                        <h3>Strategic Analysis</h3>
                        <div class="metric-list">
                            <div class="metric-item">
                                <div class="metric-name">Trump Suit Performance</div>
                                <div class="metric-leaders">
                                    ${trumpSuitAnalysis.map(suit => `
                                        <div class="leader">${suit.suit}: ${suit.averageTricks.toFixed(1)} avg tricks</div>
                                    `).join('')}
                                </div>
                            </div>
                            
                            <div class="metric-item">
                                <div class="metric-name">Top Consistent Performers</div>
                                <div class="metric-leaders">
                                    ${players.slice(0, 3).map((player, index) => `
                                        <div class="leader">${index + 1}. ${player.name}: ${(player.total_tricks / player.tournaments_played).toFixed(1)} avg per tournament</div>
                                    `).join('')}
                                </div>
                            </div>
                            
                            <div class="metric-item">
                                <div class="metric-name">Tournament Participation</div>
                                <div class="metric-leaders">
                                    ${players
                                        .sort((a, b) => b.tournaments_played - a.tournaments_played)
                                        .slice(0, 3)
                                        .map((player, index) => `
                                            <div class="leader">${index + 1}. ${player.name}: ${player.tournaments_played} tournaments</div>
                                        `).join('')}
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="metric-category">
                        <h3>Championship Analysis</h3>
                        <div class="metric-list">
                            <div class="metric-item">
                                <div class="metric-name">Multiple Champions</div>
                                <div class="metric-leaders">
                                    ${getMultipleChampions(tournaments, players).map(champion => `
                                        <div class="leader">${champion.name}: ${champion.championships} championships</div>
                                    `).join('')}
                                </div>
                            </div>
                            
                            <div class="metric-item">
                                <div class="metric-name">Recent Champions (Last 5 Tournaments)</div>
                                <div class="metric-leaders">
                                    ${tournaments.slice(0, 5).map(tournament => `
                                        <div class="leader">${tournament.year}: ${tournament.winner}</div>
                                    `).join('')}
                                </div>
                            </div>
                            
                            <div class="metric-item">
                                <div class="metric-name">Championship Win Rates</div>
                                <div class="metric-leaders">
                                    ${getMultipleChampions(tournaments, players).map(champion => {
                                        const winRate = (champion.championships / champion.tournaments_played * 100).toFixed(1);
                                        return `<div class="leader">${champion.name}: ${winRate}% win rate</div>`;
                                    }).join('')}
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="metric-category">
                        <h3>Performance Trends</h3>
                        <div class="metric-list">
                            <div class="metric-item">
                                <div class="metric-name">Tournament Size Evolution</div>
                                <div class="metric-leaders">
                                    <div class="leader">Smallest Tournament: ${Math.min(...tournaments.map(t => t.total_players))} players</div>
                                    <div class="leader">Largest Tournament: ${Math.max(...tournaments.map(t => t.total_players))} players</div>
                                    <div class="leader">Average Size: ${averagePlayersPerTournament.toFixed(1)} players</div>
                                </div>
                            </div>
                            
                            <div class="metric-item">
                                <div class="metric-name">Round Distribution</div>
                                <div class="metric-leaders">
                                    <div class="leader">Total Rounds Played: ${totalRounds}</div>
                                    <div class="leader">Average per Tournament: ${(totalRounds / totalTournaments).toFixed(1)}</div>
                                    <div class="leader">Most Rounds: ${Math.max(...tournaments.map(t => t.total_rounds))}</div>
                                </div>
                            </div>
                            
                            <div class="metric-item">
                                <div class="metric-name">Player Engagement</div>
                                <div class="metric-leaders">
                                    <div class="leader">Active in All Tournaments: ${players.filter(p => p.tournaments_played === totalTournaments).length}</div>
                                    <div class="leader">Single Tournament: ${players.filter(p => p.tournaments_played === 1).length}</div>
                                    <div class="leader">Average Participation: ${(totalPlayers / totalTournaments * totalTournaments / totalPlayers).toFixed(1)} tournaments</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                document.getElementById('metrics-grid').innerHTML = metricsHTML;
                
                // Generate records showcase
                const recordsHTML = `
                    <div class="record-highlight featured">
                        <div class="record-icon">üëë</div>
                        <div class="record-stat">${championships}</div>
                        <div class="record-content">
                            <h3>Most Championships</h3>
                            <div class="record-details">
                                <p><strong>${topPlayer.name}</strong> holds the record</p>
                                <p>Total tricks: ${topPlayer.total_tricks}</p>
                                <p>Tournaments played: ${topPlayer.tournaments_played}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="record-highlight">
                        <div class="record-icon">üéØ</div>
                        <div class="record-stat">${topPlayer.total_tricks}</div>
                        <div class="record-content">
                            <h3>Most Career Tricks</h3>
                            <div class="record-details">
                                <p><strong>${topPlayer.name}</strong></p>
                                <p>Average per tournament: ${(topPlayer.total_tricks / topPlayer.tournaments_played).toFixed(1)}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="record-highlight">
                        <div class="record-icon">üèÜ</div>
                        <div class="record-stat">${totalTournaments}</div>
                        <div class="record-content">
                            <h3>Tournaments Held</h3>
                            <div class="record-details">
                                <p>Spanning <strong>${lastYear - firstYear + 1} years</strong></p>
                                <p>From ${firstYear} to ${lastYear}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="record-highlight">
                        <div class="record-icon">‚ö°</div>
                        <div class="record-stat">${Math.max(...players.map(p => p.tournaments_played))}</div>
                        <div class="record-content">
                            <h3>Most Tournaments</h3>
                            <div class="record-details">
                                <p><strong>${players.find(p => p.tournaments_played === Math.max(...players.map(p => p.tournaments_played))).name}</strong></p>
                                <p>Ultimate competitor</p>
                            </div>
                        </div>
                    </div>
                `;
                
                document.getElementById('records-showcase').innerHTML = recordsHTML;
                
                // Load partnership performance rankings
                loadPartnershipRankings();
                
                // Load family statistics
                loadFamilyStatistics();
                
                // Update footer
                document.getElementById('total-scorecards').textContent = `${totalRounds} Rounds Analyzed`;
                document.getElementById('data-timespan').textContent = `${lastYear - firstYear + 1} Years of Data`;
                
                console.log('‚úÖ Statistics loaded successfully!');
                
            } catch (error) {
                console.error('‚ùå Error loading statistics:', error);
                const fallback = '<p style="text-align: center; color: #666; padding: 2rem;">Error loading statistics. Please try refreshing the page.</p>';
                const p = document.getElementById('partnership-rankings');
                const f = document.getElementById('family-stats');
                if (p) p.innerHTML = fallback;
                if (f) f.innerHTML = fallback;
            }
        });
        
        // Helper functions for advanced calculations
        function calculateTrumpSuitAnalysis(tournaments) {
            const suitStats = {};
            
            tournaments.forEach(tournament => {
                tournament.rounds.forEach(round => {
                    const suit = round.trump_suit;
                    if (!suitStats[suit]) {
                        suitStats[suit] = { totalTricks: 0, roundCount: 0 };
                    }
                    
                    round.tables.forEach(table => {
                        table.partnerships.forEach(partnership => {
                            suitStats[suit].totalTricks += partnership.tricks;
                            suitStats[suit].roundCount++;
                        });
                    });
                });
            });
            
            return Object.entries(suitStats).map(([suit, stats]) => ({
                suit,
                averageTricks: stats.totalTricks / stats.roundCount
            })).sort((a, b) => b.averageTricks - a.averageTricks);
        }
        
        function calculatePartnershipAnalysis(tournaments) {
            // This would implement partnership combination analysis
            // For now, return empty array as it requires more complex data processing
            return [];
        }
        
        function getMultipleChampions(tournaments, players) {
            const championshipCounts = {};
            
            tournaments.forEach(tournament => {
                championshipCounts[tournament.winner] = (championshipCounts[tournament.winner] || 0) + 1;
            });
            
            return Object.entries(championshipCounts)
                .filter(([name, count]) => count > 1)
                .map(([name, championships]) => {
                    const player = players.find(p => p.name === name);
                    return {
                        name,
                        championships,
                        tournaments_played: player ? player.tournaments_played : championships
                    };
                })
                .sort((a, b) => b.championships - a.championships);
        }

        function escapeHtml(str) {
            return String(str ?? '')
                .replaceAll('&', '&amp;')
                .replaceAll('<', '&lt;')
                .replaceAll('>', '&gt;')
                .replaceAll('"', '&quot;')
                .replaceAll("'", '&#39;');
        }

        function loadPartnershipRankings() {
            const engine = window.tournamentEngine;
            const container = document.getElementById('partnership-rankings');
            const insights = document.getElementById('partnership-insights');
            if (!engine || !container || !insights) return;

            const MIN_PAIRINGS = 4;
            const allRankings = (engine.getPartnershipPerformanceRankings() || []).slice();
            let rankings = allRankings.filter(p => (Number(p.partnerships_count) || 0) >= MIN_PAIRINGS);
            if (!rankings.length) {
                insights.innerHTML = `<div class="loading-message">No partnership data available.</div>`;
                container.innerHTML = `<div class="loading-message">No partnerships found with ${MIN_PAIRINGS}+ rounds together.</div>`;
                return;
            }

            const allowedKeys = new Set(rankings.map(p => p.partnership));
            const rankingByKey = new Map(rankings.map(p => [p.partnership, p]));

            // Win rate per partnership (wins = 7+ tricks; shared hands excluded)
            const winAggByKey = new Map(); // key -> {wins, played, games:[{year,round,table,isWin}]}
            const tournamentsList = (typeof engine.getAllTournamentsUnique === 'function')
                ? engine.getAllTournamentsUnique('desc')
                : Array.from(engine.tournaments.values());
            for (const t of tournamentsList) {
                if (!t || !Array.isArray(t.rounds)) continue;
                const year = Number.isFinite(t.year) ? t.year : (Number.isFinite(t.Year) ? t.Year : parseInt(t.year || t.Year || '0'));
                for (const r of t.rounds) {
                    if (!r || !Array.isArray(r.tables)) continue;
                    const roundNum = Number.isFinite(r.round) ? r.round : (Number.isFinite(r.Round) ? r.Round : parseInt(r.round || r.Round || '0'));
                    for (const table of r.tables) {
                        if (!table || !Array.isArray(table.partnerships)) continue;
                        const tableNum = Number.isFinite(table.table) ? table.table : parseInt(table.table || table.Table || '0');
                        for (const p of table.partnerships) {
                            const pos1IsShared = p.position1 && p.position1.length > 1;
                            const pos2IsShared = p.position2 && p.position2.length > 1;
                            if (pos1IsShared || pos2IsShared) continue;
                            const a = p.position1 && p.position1[0];
                            const b = p.position2 && p.position2[0];
                            if (!a || !b) continue;
                            const key = [a, b].sort().join(' & ');
                            if (!allowedKeys.has(key)) continue;
                            const tricks = Number.isFinite(p.tricks) ? p.tricks : parseFloat(p.tricks);
                            if (!Number.isFinite(tricks)) continue;
                            if (!winAggByKey.has(key)) winAggByKey.set(key, { wins: 0, played: 0, games: [] });
                            const rec = winAggByKey.get(key);
                            rec.played += 1;
                            const isWin = tricks >= 7;
                            if (isWin) rec.wins += 1;
                            rec.games.push({
                                year: Number.isFinite(year) ? year : 0,
                                round: Number.isFinite(roundNum) ? roundNum : 0,
                                table: Number.isFinite(tableNum) ? tableNum : 0,
                                isWin
                            });
                        }
                    }
                }
            }

            // Sort partnerships: avg tricks/round, then times paired, then win rate (tie breakers).
            const winPctFor = (key) => {
                const rec = winAggByKey.get(key);
                const played = rec && Number.isFinite(rec.played) ? rec.played : 0;
                const wins = rec && Number.isFinite(rec.wins) ? rec.wins : 0;
                return played > 0 ? (wins / played) : 0;
            };
            rankings = rankings.slice().sort((a, b) => {
                const aAvg = Number(a.average_tricks) || 0;
                const bAvg = Number(b.average_tricks) || 0;
                if (bAvg !== aAvg) return bAvg - aAvg;
                const aTimes = Number(a.partnerships_count) || 0;
                const bTimes = Number(b.partnerships_count) || 0;
                if (bTimes !== aTimes) return bTimes - aTimes;
                const aWr = winPctFor(a.partnership);
                const bWr = winPctFor(b.partnership);
                if (bWr !== aWr) return bWr - aWr;
                return String(a.partnership || '').localeCompare(String(b.partnership || ''));
            });

            const bestAvg = rankings[0];
            const mostRounds = rankings.reduce((best, cur) => (cur.total_rounds > best.total_rounds ? cur : best), rankings[0]);
            // (Dropped: most tricks together, most frequent pairing)

            const fmtPair = (p) => {
                const p0 = escapeHtml(p.players[0]);
                const p1 = escapeHtml(p.players[1]);
                return `
                    <a href="../players/profile.html?player=${encodeURIComponent(p.players[0])}" class="player-name-link">${p0}</a>
                    <span class="partnership-separator">&</span>
                    <a href="../players/profile.html?player=${encodeURIComponent(p.players[1])}" class="player-name-link">${p1}</a>
                `;
            };

            // Insight cards (above the table): make the entire partnership clickable to "all games together"
            const fmtPairInsight = (p) => {
                const a = p.players[0];
                const b = p.players[1];
                const aLabel = escapeHtml(a);
                const bLabel = escapeHtml(b);
                // IMPORTANT: use &amp; inside HTML so the browser doesn't treat "&par..." as an entity and drop the partner param.
                const href = `../players/partnership-games?player=${encodeURIComponent(a)}&amp;partner=${encodeURIComponent(b)}`;
                return `<a href="${href}" class="partnership-link">${aLabel} <span class="partnership-separator">&</span> ${bLabel}</a>`;
            };

            // Streak metrics per partnership (shared hands excluded)
            const metricsByKey = new Map(); // key -> {wins, played, winPct, longestWinStreak, longestLoseStreak, currentWinStreak, currentLoseStreak}
            for (const key of allowedKeys.values()) {
                const rec = winAggByKey.get(key) || { wins: 0, played: 0, games: [] };
                const played = Number.isFinite(rec.played) ? rec.played : 0;
                const wins = Number.isFinite(rec.wins) ? rec.wins : 0;
                const winPct = played > 0 ? (wins / played) : null;
                const games = Array.isArray(rec.games) ? rec.games.slice() : [];
                games.sort((a, b) => (a.year - b.year) || (a.round - b.round) || (a.table - b.table));

                let longestWinStreak = 0;
                let longestLoseStreak = 0;
                let w = 0;
                let l = 0;
                for (const g of games) {
                    if (g && g.isWin) {
                        w += 1;
                        if (w > longestWinStreak) longestWinStreak = w;
                        l = 0;
                    } else {
                        w = 0;
                        l += 1;
                        if (l > longestLoseStreak) longestLoseStreak = l;
                    }
                }

                let currentWinStreak = 0;
                let currentLoseStreak = 0;
                if (games.length) {
                    const lastIsWin = !!games[games.length - 1].isWin;
                    for (let i = games.length - 1; i >= 0; i--) {
                        const isWin = !!games[i].isWin;
                        if (isWin !== lastIsWin) break;
                        if (lastIsWin) currentWinStreak += 1;
                        else currentLoseStreak += 1;
                    }
                }

                metricsByKey.set(key, {
                    wins,
                    played,
                    winPct,
                    longestWinStreak,
                    longestLoseStreak,
                    currentWinStreak,
                    currentLoseStreak
                });
            }

            const renderTies = (keys, cap = 6) => {
                const list = (keys || []).map(k => rankingByKey.get(k)).filter(Boolean);
                if (!list.length) return '‚Äî';
                const shown = list.slice(0, cap);
                const more = list.length - shown.length;
                return `${shown.map(p => fmtPairInsight(p)).join(', ')}${more > 0 ? ` <span class="muted-inline">(+${more} more)</span>` : ''}`;
            };

            const invinciblesKeys = Array.from(metricsByKey.entries())
                .filter(([, m]) => (m.played || 0) >= MIN_PAIRINGS && (m.winPct === 1))
                .sort((a, b) => (b[1].played - a[1].played));
            const invincibleMax = invinciblesKeys.length ? invinciblesKeys[0][1].played : 0;
            const invincibleTies = invincibleMax > 0 ? invinciblesKeys.filter(([, m]) => m.played === invincibleMax).map(([k]) => k) : [];

            const bestLongestWin = Math.max(0, ...Array.from(metricsByKey.values()).map(m => (m.played >= MIN_PAIRINGS ? (m.longestWinStreak || 0) : 0)));
            const bestLongestLose = Math.max(0, ...Array.from(metricsByKey.values()).map(m => (m.played >= MIN_PAIRINGS ? (m.longestLoseStreak || 0) : 0)));

            // Current streaks: exclude partnerships where either player is deceased (they can no longer extend the streak).
            const isDeceased = (id) => (engine && typeof engine.isPlayerDeceased === 'function') ? engine.isPlayerDeceased(id) : false;
            const eligibleCurrent = Array.from(metricsByKey.entries()).filter(([key, m]) => {
                if (!m || (m.played || 0) < MIN_PAIRINGS) return false;
                const r = rankingByKey.get(key);
                if (!r || !Array.isArray(r.players) || r.players.length < 2) return false;
                return !isDeceased(r.players[0]) && !isDeceased(r.players[1]);
            });
            const bestCurrentWin = Math.max(0, ...eligibleCurrent.map(([, m]) => (m.currentWinStreak || 0)));
            const bestCurrentLose = Math.max(0, ...eligibleCurrent.map(([, m]) => (m.currentLoseStreak || 0)));

            const longestWinKeys = bestLongestWin > 0
                ? Array.from(metricsByKey.entries()).filter(([k, m]) => m.played >= MIN_PAIRINGS && (m.longestWinStreak || 0) === bestLongestWin).map(([k]) => k)
                : [];
            const longestLoseKeys = bestLongestLose > 0
                ? Array.from(metricsByKey.entries()).filter(([k, m]) => m.played >= MIN_PAIRINGS && (m.longestLoseStreak || 0) === bestLongestLose).map(([k]) => k)
                : [];
            const currentWinKeys = bestCurrentWin > 0
                ? eligibleCurrent.filter(([, m]) => (m.currentWinStreak || 0) === bestCurrentWin).map(([k]) => k)
                : [];
            const currentLoseKeys = bestCurrentLose > 0
                ? eligibleCurrent.filter(([, m]) => (m.currentLoseStreak || 0) === bestCurrentLose).map(([k]) => k)
                : [];

            insights.innerHTML = `
                <div class="insight-card">
                    <div class="insight-kicker">Best partnership</div>
                    <div class="insight-value">${bestAvg.average_tricks.toFixed(2)} <span class="insight-unit">avg/round</span></div>
                    <div class="insight-detail">${fmtPairInsight(bestAvg)} ‚Ä¢ ${bestAvg.total_rounds} rounds</div>
                </div>
                <div class="insight-card">
                    <div class="insight-kicker">Most rounds together</div>
                    <div class="insight-value">${mostRounds.total_rounds.toLocaleString()}</div>
                    <div class="insight-detail">${fmtPairInsight(mostRounds)}</div>
                </div>
                <div class="insight-card">
                    <div class="insight-kicker">The Invincibles</div>
                    <div class="insight-value">${invincibleMax ? invincibleMax.toLocaleString() : '‚Äî'} <span class="insight-unit">wins</span></div>
                    <div class="insight-detail">${invincibleMax ? `${renderTies(invincibleTies)} ‚Ä¢ 100% win record` : `No partnerships with 100% win record (min ${MIN_PAIRINGS})`}</div>
                </div>
                <div class="insight-card">
                    <div class="insight-kicker">Longest win streak</div>
                    <div class="insight-value">${bestLongestWin ? bestLongestWin : '‚Äî'}</div>
                    <div class="insight-detail">${bestLongestWin ? renderTies(longestWinKeys) : `‚Äî`}</div>
                </div>
                <div class="insight-card">
                    <div class="insight-kicker">Longest losing streak</div>
                    <div class="insight-value">${bestLongestLose ? bestLongestLose : '‚Äî'}</div>
                    <div class="insight-detail">${bestLongestLose ? renderTies(longestLoseKeys) : `‚Äî`}</div>
                </div>
                <div class="insight-card">
                    <div class="insight-kicker">Current longest win streak</div>
                    <div class="insight-value">${bestCurrentWin ? bestCurrentWin : '‚Äî'}</div>
                    <div class="insight-detail">${bestCurrentWin ? renderTies(currentWinKeys) : `‚Äî`}</div>
                </div>
                <div class="insight-card">
                    <div class="insight-kicker">Current longest losing streak</div>
                    <div class="insight-value">${bestCurrentLose ? bestCurrentLose : '‚Äî'}</div>
                    <div class="insight-detail">${bestCurrentLose ? renderTies(currentLoseKeys) : `‚Äî`}</div>
                </div>
            `;

            const INITIAL_VISIBLE = 10;
            const PAGE_SIZE = 10;
            let visibleCount = Math.min(INITIAL_VISIBLE, rankings.length);

            container.innerHTML = `
                <div class="partnership-table-container">
                    <table class="partnership-table">
                        <thead>
                            <tr>
                                <th class="rank-column">Rank</th>
                                <th class="partnership-column">Partnership</th>
                                <th class="avg-tricks-column">Avg tricks/round</th>
                                <th class="win-rate-column">Win rate</th>
                                <th class="count-column">Times paired</th>
                                <th class="cta-column"></th>
                            </tr>
                        </thead>
                        <tbody id="partnership-table-body"></tbody>
                    </table>
                </div>

                <div class="see-more-wrap" id="partnership-see-more-wrap" style="display:none;">
                    <div class="see-more-meta" id="partnership-see-more-meta"></div>
                    <button type="button" class="see-more-btn" id="partnership-see-more-btn">See more</button>
                </div>
            `;
            
            const tbody = document.getElementById('partnership-table-body');
            const moreWrap = document.getElementById('partnership-see-more-wrap');
            const moreMeta = document.getElementById('partnership-see-more-meta');
            const moreBtn = document.getElementById('partnership-see-more-btn');

            const renderRows = () => {
                if (!tbody) return;
                const rows = rankings.slice(0, visibleCount).map((p, idx) => {
                    const winAgg = winAggByKey.get(p.partnership) || { wins: 0, played: Number(p.partnerships_count) || 0 };
                    const played = Number.isFinite(winAgg.played) ? winAgg.played : 0;
                    const wins = Number.isFinite(winAgg.wins) ? winAgg.wins : 0;
                    const winRateText = played > 0 ? `${Math.round((wins / played) * 100)}%` : '‚Äî';
                    // IMPORTANT: use &amp; inside HTML so the browser doesn't treat "&par..." as an entity and drop the partner param.
                    const gamesHref = `../players/partnership-games?player=${encodeURIComponent(p.players[0])}&amp;partner=${encodeURIComponent(p.players[1])}`;
                    return `
                        <tr>
                            <td class="rank-column">${idx + 1}</td>
                            <td class="partnership-column"><div class="partnership-names">${fmtPair(p)}</div></td>
                            <td class="avg-tricks-column">${p.average_tricks.toFixed(2)}</td>
                            <td class="win-rate-column">${winRateText} <span class="muted-inline">(${wins}/${played})</span></td>
                            <td class="count-column">${p.partnerships_count.toLocaleString()}</td>
                            <td class="cta-column"><a class="cta-link" href="${gamesHref}">See all games</a></td>
                        </tr>
                    `;
                }).join('');
                tbody.innerHTML = rows;

                const remaining = Math.max(0, rankings.length - visibleCount);
                if (moreWrap && moreBtn && moreMeta && remaining > 0) {
                    moreWrap.style.display = 'flex';
                    const next = Math.min(PAGE_SIZE, remaining);
                    moreMeta.textContent = `Showing ${visibleCount} of ${rankings.length} ‚Ä¢ ${remaining} more`;
                    moreBtn.textContent = `See ${next} more`;
                } else if (moreWrap) {
                    moreWrap.style.display = 'none';
                }
            };

            if (moreBtn) {
                moreBtn.addEventListener('click', () => {
                    visibleCount = Math.min(rankings.length, visibleCount + PAGE_SIZE);
                    renderRows();
                });
            }

            renderRows();
        }

        function loadFamilyStatistics() {
            const engine = window.tournamentEngine;
            const container = document.getElementById('family-stats');
            const insights = document.getElementById('family-insights');
            if (!engine || !container || !insights) return;

            // Hide the old summary strip; the family panels include the stats
            insights.innerHTML = '';

            const INCLUDE_HONORARY_IN_STATS = false;

            const roster = (engine.getPlayersRoster && typeof engine.getPlayersRoster === 'function')
                ? engine.getPlayersRoster()
                : [];
            const byId = new Map(roster.map(p => [p.id, p]));

            const findRoot = (firstNameLower, lastNameLower) => {
                const f = String(firstNameLower || '').toLowerCase();
                const l = String(lastNameLower || '').toLowerCase();
                const exact = roster.find(p =>
                    String(p.firstName || '').toLowerCase() === f &&
                    String(p.lastName || '').toLowerCase() === l
                );
                if (exact) return exact.id;
                const loose = roster.find(p =>
                    String(p.lastName || '').toLowerCase() === l &&
                    (String(p.displayName || '').toLowerCase().includes(f) || String(p.fullName || '').toLowerCase().includes(f))
                );
                if (loose) return loose.id;
                return null;
            };

            const georgeId = findRoot('george', 'ruston') || (byId.has('George') ? 'George' : null) || (byId.has('GeorgeRuston') ? 'GeorgeRuston' : null);
            const dorisId = findRoot('doris', 'ruston') || (byId.has('Doris') ? 'Doris' : null) || (byId.has('DorisRuston') ? 'DorisRuston' : null);

            // Build parent -> children edges from Players sheet
            const childrenByParent = new Map(); // id -> Set<childId>
            roster.forEach(p => {
                const childId = p.id;
                const parents = Array.isArray(p.familyTreeParents) ? p.familyTreeParents : [];
                parents.forEach(parentId => {
                    if (!childrenByParent.has(parentId)) childrenByParent.set(parentId, new Set());
                    childrenByParent.get(parentId).add(childId);
                });
            });

            // Descendants (including roots)
            const descendants = new Set();
            const queue = [];
            [georgeId, dorisId].filter(Boolean).forEach(rootId => {
                descendants.add(rootId);
                queue.push(rootId);
            });
            while (queue.length) {
                const cur = queue.shift();
                const kids = childrenByParent.get(cur);
                if (!kids) continue;
                for (const kid of kids.values()) {
                    if (descendants.has(kid)) continue;
                    descendants.add(kid);
                    queue.push(kid);
                }
            }

            // Strong adjacency (partners / had children with): treat as membership, not honorary
            const strongAdj = new Map(); // id -> Set<id>
            const addStrongEdge = (a, b) => {
                if (!a || !b) return;
                if (!strongAdj.has(a)) strongAdj.set(a, new Set());
                if (!strongAdj.has(b)) strongAdj.set(b, new Set());
                strongAdj.get(a).add(b);
                strongAdj.get(b).add(a);
            };
            roster.forEach(p => {
                const fromId = p.id;
                const hadKids = Array.isArray(p.familyTreeHadChildrenWith) ? p.familyTreeHadChildrenWith : [];
                const partnered = Array.isArray(p.familyTreeIsPartneredWith) ? p.familyTreeIsPartneredWith : [];
                hadKids.forEach(toId => addStrongEdge(fromId, toId));
                partnered.forEach(toId => addStrongEdge(fromId, toId));
            });

            // LinkedTo adjacency (undirected) for honorary membership
            const linkedAdj = new Map(); // id -> Set<id>
            roster.forEach(p => {
                const fromId = p.id;
                const links = Array.isArray(p.familyTreeLinkedTo) ? p.familyTreeLinkedTo : [];
                links.forEach(toId => {
                    if (!toId) return;
                    if (!linkedAdj.has(fromId)) linkedAdj.set(fromId, new Set());
                    if (!linkedAdj.has(toId)) linkedAdj.set(toId, new Set());
                    linkedAdj.get(fromId).add(toId);
                    linkedAdj.get(toId).add(fromId);
                });
            });

            // Stats map for family members (from tournament data)
            const individuals = (engine.getAllIndividualPlayers && typeof engine.getAllIndividualPlayers === 'function')
                ? engine.getAllIndividualPlayers('total_tricks')
                : [];
            const statsById = new Map(individuals.map(p => [p.name, p]));

            const getDisplay = (id) => {
                if (engine && typeof engine.getDisplayName === 'function') return engine.getDisplayName(id);
                const r = byId.get(id);
                return r?.displayName || id;
            };

            const getLastName = (id) => {
                const rosterRow = byId.get(id);
                if (rosterRow && rosterRow.lastName) return rosterRow.lastName;
                if (engine && typeof engine.getPlayerNameParts === 'function') {
                    const parts = engine.getPlayerNameParts(id);
                    if (parts && parts.lastName) return parts.lastName;
                }
                return '';
            };

            // Legitimate families are discovered dynamically using the Players-sheet family tree:
            //
            // Rule: you only branch out into a new family surname if you've had children.
            // Otherwise (e.g., surname changed via marriage but no children), you inherit your
            // parents' family surname for membership purposes.
            //
            // This prevents single-member families like "West" when Eloise has no children.
            const hasChildren = (id) => {
                if (!id) return false;
                const kids = childrenByParent.get(id);
                if (kids && kids.size > 0) return true;
                const row = byId.get(id);
                const hadKids = Array.isArray(row?.familyTreeHadChildrenWith) ? row.familyTreeHadChildrenWith : [];
                return hadKids.length > 0;
            };

            const familyOf = new Map(); // descendantId -> family surname
            const famQueue = [];
            const seedRootFamily = (rootId) => {
                if (!rootId) return;
                const ln = String(getLastName(rootId) || '').trim();
                const fam = ln || 'Unknown';
                if (!familyOf.has(rootId)) {
                    familyOf.set(rootId, fam);
                    famQueue.push(rootId);
                }
            };
            seedRootFamily(georgeId);
            seedRootFamily(dorisId);

            while (famQueue.length) {
                const parentId = famQueue.shift();
                const parentFam = String(familyOf.get(parentId) || '').trim();
                const kids = childrenByParent.get(parentId);
                if (!kids) continue;
                for (const kidId of kids.values()) {
                    if (!descendants.has(kidId)) continue;
                    const kidRow = byId.get(kidId);
                    const kidLast = String(kidRow?.lastName || getLastName(kidId) || '').trim();
                    const kidBranches = hasChildren(kidId) && kidLast && parentFam && (kidLast.toLowerCase() !== parentFam.toLowerCase());
                    const kidFam = kidBranches ? kidLast : parentFam;

                    if (!familyOf.has(kidId)) {
                        familyOf.set(kidId, kidFam);
                        famQueue.push(kidId);
                    } else {
                        // If discovered via both parents, prefer a branching surname when applicable.
                        const existing = String(familyOf.get(kidId) || '').trim();
                        if (kidBranches && existing.toLowerCase() !== kidFam.toLowerCase()) {
                            familyOf.set(kidId, kidFam);
                        }
                    }
                }
            }

            const legitFamilies = Array.from(new Set(Array.from(familyOf.values()).filter(Boolean)))
                .sort((a, b) => a.localeCompare(b));

            const families = legitFamilies.map(famName => {
                // Core members = descendants whose *family membership surname* is this family.
                // (Not necessarily their current roster lastName if they never had children.)
                const famKey = String(famName).trim().toLowerCase();
                const baseMembers = roster
                    .filter(p => descendants.has(p.id) && String(familyOf.get(p.id) || '').trim().toLowerCase() === famKey)
                    .map(p => p.id);

                // Include partners / co-parents of any member as MEMBERS (even if their surname differs)
                const membersSet = new Set(baseMembers);
                baseMembers.forEach(id => {
                    const neigh = strongAdj.get(id);
                    if (!neigh) return;
                    neigh.forEach(otherId => membersSet.add(otherId));
                });

                const members = Array.from(membersSet).sort((a, b) => getDisplay(a).localeCompare(getDisplay(b)));

                // Honorary members: transitive closure over LinkedTo + strong links
                // Example: Caroline (partner of Clive) -> Clive (LinkedTo Steve) -> Steve (family member)
                const honorary = new Set();
                const seen = new Set();
                const q = [];
                members.forEach(id => {
                    seen.add(id);
                    q.push(id);
                });

                const combinedNeighbors = (id) => {
                    const out = new Set();
                    const a = linkedAdj.get(id);
                    const b = strongAdj.get(id);
                    if (a) a.forEach(x => out.add(x));
                    if (b) b.forEach(x => out.add(x));
                    return out;
                };

                while (q.length) {
                    const cur = q.shift();
                    const neigh = combinedNeighbors(cur);
                    neigh.forEach(n => {
                        if (!n || seen.has(n)) return;
                        seen.add(n);
                        q.push(n);
                        if (!membersSet.has(n)) {
                            honorary.add(n);
                        }
                    });
                }

                const honoraryList = Array.from(honorary)
                    .sort((a, b) => getDisplay(a).localeCompare(getDisplay(b)));

                // Aggregate tournament stats (optionally include honorary)
                const statIds = INCLUDE_HONORARY_IN_STATS
                    ? Array.from(new Set([...members, ...honoraryList]))
                    : members;
                let totalTournaments = 0;
                let totalTricks = 0;
                let totalRounds = 0;
                let champsTotal = 0;
                let medals = 0;
                const championPeople = new Set();

                statIds.forEach(id => {
                    const s = statsById.get(id);
                    if (!s) return;
                    totalTournaments += (Number.isFinite(s.tournaments_played) ? s.tournaments_played : 0);
                    totalTricks += (Number.isFinite(s.total_tricks) ? s.total_tricks : 0);
                    totalRounds += (Number.isFinite(s.total_rounds) ? s.total_rounds : 0);
                    const wins = (Number.isFinite(s.tournament_wins) ? s.tournament_wins : 0);
                    champsTotal += wins;
                    if (wins > 0) championPeople.add(id);
                    medals += (Number.isFinite(s.top_three_finishes) ? s.top_three_finishes : 0);
                });

                const avg = totalRounds > 0 ? (totalTricks / totalRounds) : 0;
                const champs = championPeople.size;

                return {
                    family_name: famName,
                    members,
                    honorary: honoraryList,
                    stats: {
                        membersCount: members.length,
                        honoraryCount: honoraryList.length,
                        champs,
                        medals,
                        totalTournaments,
                        avgTricksPerRound: avg,
                        champsTotal
                    }
                };
            });

            // Sanity: if we failed to identify roots, descendants may be empty; fall back to include all roster members for these families.
            const descendantsEmpty = descendants.size === 0;
            if (descendantsEmpty) {
                console.warn('‚ö†Ô∏è Could not identify George/Doris roots; falling back to last-name grouping only for legitimate families.');
                const fallbackSurnames = new Set();
                roster.forEach(p => {
                    const ln = String(p.lastName || '').trim();
                    if (ln) fallbackSurnames.add(ln);
                });
                const fallbackFamilies = Array.from(fallbackSurnames).sort((a, b) => a.localeCompare(b));
                // Rebuild families in fallback mode (surname grouping + partners + honorary)
                const rebuilt = fallbackFamilies.map(famName => {
                    const baseMembers = roster
                        .filter(p => String(p.lastName || '').trim().toLowerCase() === String(famName).trim().toLowerCase())
                        .map(p => p.id);
                    const membersSet = new Set(baseMembers);
                    baseMembers.forEach(id => {
                        const neigh = strongAdj.get(id);
                        if (!neigh) return;
                        neigh.forEach(otherId => membersSet.add(otherId));
                    });
                    const members = Array.from(membersSet).sort((a, b) => getDisplay(a).localeCompare(getDisplay(b)));
                    // Honorary members: transitive closure over LinkedTo + strong links
                    const honorary = new Set();
                    const seen = new Set();
                    const q = [];
                    members.forEach(id => {
                        seen.add(id);
                        q.push(id);
                    });
                    while (q.length) {
                        const cur = q.shift();
                        const neigh = new Set();
                        const a = linkedAdj.get(cur);
                        const b = strongAdj.get(cur);
                        if (a) a.forEach(x => neigh.add(x));
                        if (b) b.forEach(x => neigh.add(x));
                        neigh.forEach(n => {
                            if (!n || seen.has(n)) return;
                            seen.add(n);
                            q.push(n);
                            if (!membersSet.has(n)) honorary.add(n);
                        });
                    }
                    const honoraryList = Array.from(honorary).sort((a, b) => getDisplay(a).localeCompare(getDisplay(b)));

                    const statIds = INCLUDE_HONORARY_IN_STATS
                        ? Array.from(new Set([...members, ...honoraryList]))
                        : members;
                    let totalTournaments = 0;
                    let totalTricks = 0;
                    let totalRounds = 0;
                    let champsTotal = 0;
                    let medals = 0;
                    const championPeople = new Set();
                    statIds.forEach(id => {
                        const s = statsById.get(id);
                        if (!s) return;
                        totalTournaments += (Number.isFinite(s.tournaments_played) ? s.tournaments_played : 0);
                        totalTricks += (Number.isFinite(s.total_tricks) ? s.total_tricks : 0);
                        totalRounds += (Number.isFinite(s.total_rounds) ? s.total_rounds : 0);
                        const wins = (Number.isFinite(s.tournament_wins) ? s.tournament_wins : 0);
                        champsTotal += wins;
                        if (wins > 0) championPeople.add(id);
                        medals += (Number.isFinite(s.top_three_finishes) ? s.top_three_finishes : 0);
                    });
                    const avg = totalRounds > 0 ? (totalTricks / totalRounds) : 0;
                    const champs = championPeople.size;

                    return {
                        family_name: famName,
                        members,
                        honorary: honoraryList,
                        stats: {
                            membersCount: members.length,
                            honoraryCount: honoraryList.length,
                            champs,
                            medals,
                            totalTournaments,
                            avgTricksPerRound: avg,
                            champsTotal
                        }
                    };
                });
                // Replace
                families.splice(0, families.length, ...rebuilt);
            }

            const chipList = (ids) => {
                if (!ids || !ids.length) return `<div class="muted-inline">None</div>`;
                return ids.map(id => `
                    <a class="member-chip" href="../players/profile.html?player=${encodeURIComponent(id)}">${escapeHtml(getDisplay(id))}</a>
                `).join('');
            };

            const familyCards = families.map(f => {
                const s = f.stats;
                return `
                    <div class="family-panel">
                        <div class="family-panel-header">
                            <div class="family-panel-title">${escapeHtml(f.family_name)} Family</div>
                            <div class="family-panel-subtitle">${s.membersCount} members ‚Ä¢ ${s.honoraryCount} honorary</div>
                            </div>
                        <div class="family-panel-stats">
                            <div class="family-panel-stat">
                                <div class="k">Avg tricks/round</div>
                                <div class="v">${s.avgTricksPerRound.toFixed(2)}</div>
                                </div>
                            <div class="family-panel-stat">
                                <div class="k">Champs</div>
                                <div class="v">${s.champs}</div>
                            </div>
                            <div class="family-panel-stat">
                                <div class="k">Tournaments</div>
                                <div class="v">${s.totalTournaments.toLocaleString()}</div>
                                </div>
                            <div class="family-panel-stat">
                                <div class="k">Medals</div>
                                <div class="v">${s.medals.toLocaleString()}</div>
                                </div>
                                </div>

                        <div class="family-panel-list">
                            <div class="family-panel-list-title">Members</div>
                            <div class="family-chip-row">${chipList(f.members)}</div>
                                </div>

                        <div class="family-panel-list">
                            <div class="family-panel-list-title">Honorary members</div>
                            <div class="family-chip-row">${chipList(f.honorary)}</div>
                            </div>
                </div>
            `;
            }).join('');

            container.innerHTML = `
                <div class="family-panels-grid">
                    ${familyCards}
                </div>
            `;
        }
    </script>
    
    <style>
        /* Statistics Page Specific Styles */
        .stats-hero {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: var(--spacing-3xl) 0;
            position: relative;
            overflow: hidden;
        }

        .stats-hero::before {
            content: 'üìä';
            position: absolute;
            top: 50%;
            right: 5%;
            transform: translateY(-50%);
            font-size: 15rem;
            opacity: 0.1;
            z-index: 1;
        }

        .hero-content {
            position: relative;
            z-index: 2;
            text-align: center;
        }

        .analytics-badge {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            padding: var(--spacing-sm) var(--spacing-xl);
            border-radius: var(--border-radius-lg);
            font-size: 0.875rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            margin-bottom: var(--spacing-lg);
            display: inline-block;
        }

        .hero-title {
            font-size: 3.5rem;
            font-weight: 900;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-primary);
        }

        .hero-subtitle {
            font-size: 1.25rem;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
        }

        .section-subtitle {
            margin-top: -0.75rem;
            margin-bottom: var(--spacing-xl);
            color: var(--text-secondary-dark);
            font-size: 1rem;
            text-align: center;
        }

        .partnership-performance-section .section-subtitle {
            color: var(--text-secondary);
        }

        .family-statistics-section .section-title {
            color: var(--text-primary-dark);
        }

        .insight-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: var(--spacing-xl);
            margin-bottom: var(--spacing-xl);
        }

        /* Classier (non-neon) borders for Stats panels */
        :root {
            --stats-panel-border: rgba(15, 23, 42, 0.10);
            --stats-panel-border-strong: rgba(15, 23, 42, 0.14);
            --stats-panel-border-on-dark: rgba(255, 255, 255, 0.14);
        }

        .insight-card {
            background: white;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--stats-panel-border);
        }

        .insight-kicker {
            font-size: 0.8rem;
            color: var(--text-secondary-dark);
            text-transform: uppercase;
            letter-spacing: 0.06em;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .insight-value {
            font-size: 2rem;
            font-weight: 900;
            font-family: var(--font-primary);
            color: var(--primary);
            line-height: 1.05;
            margin-bottom: 0.35rem;
        }

        .insight-unit {
            font-size: 0.9rem;
            font-weight: 800;
            color: var(--text-secondary-dark);
            font-family: var(--font-secondary);
        }

        .insight-detail {
            color: var(--text-secondary-dark);
            font-size: 0.95rem;
        }

        .loading-message {
            text-align: center;
            color: var(--text-secondary-dark);
            padding: var(--spacing-xl);
            font-style: italic;
        }

        .partnership-performance-section .loading-message {
            color: var(--text-secondary);
        }

        .tournament-summary-section {
            padding: var(--spacing-3xl) 0;
            background: var(--bg-primary);
        }

        .overview-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--spacing-xl);
        }

        .overview-stat-card {
            background: white;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-lg);
            text-align: center;
            border: 1px solid var(--stats-panel-border);
            transition: all 0.2s ease;
        }

        .overview-stat-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-xl);
            border-color: var(--primary);
        }

        .overview-stat-card .stat-icon {
            font-size: 3rem;
            margin-bottom: var(--spacing-md);
        }

        .overview-stat-card .stat-number {
            font-size: 2.5rem;
            font-weight: 900;
            color: var(--primary);
            margin-bottom: var(--spacing-sm);
            display: block;
        }

        .overview-stat-card .stat-label {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .overview-stat-card .stat-detail {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .analytics-grid-section {
            padding: var(--spacing-3xl) 0;
            background: var(--bg-secondary);
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--spacing-2xl);
        }

        .analytics-card {
            background: white;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--stats-panel-border);
            transition: all 0.2s ease;
        }

        .analytics-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-xl);
            border-color: var(--primary);
        }

        .card-title {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            font-size: 1.125rem;
            color: var(--text-primary);
            font-weight: 600;
        }

        .card-icon {
            font-size: 1.5rem;
        }

        .performers-list, .distribution-stats, .competition-stats, .timeline-stats {
            display: grid;
            gap: var(--spacing-md);
        }

        .performer-item, .dist-item, .comp-item, .time-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm);
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
        }

        .performer-item .rank {
            font-weight: 600;
            color: var(--primary);
            min-width: 20px;
        }

        .performer-item .name {
            flex: 1;
            margin-left: var(--spacing-sm);
        }

        .performer-item .tricks {
            font-weight: 500;
            color: var(--text-secondary);
        }

        .label {
            font-weight: 500;
            color: var(--text-primary);
        }

        .value {
            font-weight: 600;
            color: var(--primary);
        }

        .advanced-metrics-section {
            padding: var(--spacing-3xl) 0;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: var(--spacing-2xl);
        }

        .metric-category {
            background: white;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-lg);
        }

        .metric-category h3 {
            color: var(--primary);
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-sm);
            border-bottom: 2px solid var(--primary);
            font-size: 1.25rem;
        }

        .metric-list {
            display: grid;
            gap: var(--spacing-lg);
        }

        .metric-item {
            padding: var(--spacing-md);
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
        }

        .metric-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--spacing-sm);
        }

        .metric-leaders {
            display: grid;
            gap: var(--spacing-xs);
        }

        .leader {
            font-size: 0.875rem;
            color: var(--text-secondary);
            padding: var(--spacing-xs) 0;
        }

        .statistical-records-section {
            padding: var(--spacing-3xl) 0;
            background: var(--bg-secondary);
        }

        .records-showcase {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--spacing-xl);
        }

        .record-highlight {
            background: white;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-2xl);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--stats-panel-border);
            text-align: center;
            transition: all 0.2s ease;
        }

        .record-highlight:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-xl);
        }

        .record-highlight.featured {
            border-color: var(--gold);
            background: linear-gradient(135deg, white 0%, #fef3c7 100%);
        }

        .record-icon {
            font-size: 4rem;
            margin-bottom: var(--spacing-lg);
        }

        .record-stat {
            font-size: 2.5rem;
            font-weight: 900;
            font-family: var(--font-primary);
            color: var(--primary);
            margin-bottom: var(--spacing-md);
        }

        .record-content h3 {
            color: var(--text-primary);
            margin-bottom: var(--spacing-md);
            font-size: 1.25rem;
        }

        .record-details p {
            margin-bottom: var(--spacing-sm);
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .record-details strong {
            color: var(--primary);
        }

        /* Partnership Performance Styles */
        .partnership-performance-section {
            padding: var(--spacing-3xl) 0;
            background: var(--bg-primary);
        }

        .partnership-table-container {
            background: white;
            border-radius: var(--border-radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow-card);
            border: 1px solid rgba(15, 23, 42, 0.08);
        }

        .partnership-table {
            width: 100%;
            border-collapse: collapse;
        }

        .partnership-table th,
        .partnership-table td {
            padding: 0.85rem 0.95rem;
        }

        .partnership-table th {
            background: linear-gradient(135deg, #f8f9fa 0%, #eef2f7 100%);
            color: var(--text-primary-dark);
            border-bottom: 1px solid rgba(15, 23, 42, 0.10);
            text-align: left;
            font-weight: 700;
            font-size: 0.9rem;
            text-transform: none;
            letter-spacing: normal;
        }

        .partnership-table td {
            border-bottom: 1px solid rgba(15, 23, 42, 0.06);
            color: var(--text-primary-dark);
        }

        .partnership-table tbody tr:nth-child(even) {
            background: #f8fafc;
        }

        .partnership-table tbody tr:hover {
            background: rgba(34, 197, 94, 0.08);
        }

        .partnership-names {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .partnership-separator {
            color: var(--text-secondary-dark);
            font-weight: 600;
        }

        .player-name-link {
            color: var(--primary-dark);
            text-decoration: none;
            font-weight: 800;
            transition: all 0.2s ease;
        }

        .player-name-link:hover {
            color: var(--primary-dark);
            text-decoration: underline;
        }

        /* Insight cards: whole partnership is a single link */
        .partnership-link {
            color: var(--primary-dark);
            text-decoration: none;
            font-weight: 800;
        }

        .partnership-link:hover {
            text-decoration: underline;
        }

        .rank-column {
            text-align: center;
            font-weight: 800;
            color: var(--text-primary-dark);
            width: 60px;
        }

        .avg-tricks-column, .total-tricks-column, .rounds-column, .count-column {
            text-align: center;
            font-weight: 500;
        }

        .win-rate-column {
            text-align: center;
            font-weight: 700;
            width: 140px;
        }

        .cta-column {
            text-align: right;
            width: 160px;
        }

        .cta-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.45rem 0.85rem;
            border-radius: 999px;
            border: 1px solid rgba(15, 23, 42, 0.14);
            background: rgba(15, 23, 42, 0.04);
            color: var(--primary-dark);
            font-weight: 800;
            text-decoration: none;
            white-space: nowrap;
        }

        .cta-link:hover {
            text-decoration: underline;
        }

        .see-more-wrap {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin-top: var(--spacing-lg);
        }

        .see-more-meta {
            color: var(--text-secondary-dark);
            font-weight: 650;
            font-size: 0.95rem;
        }

        .see-more-btn {
            appearance: none;
            border: 1px solid rgba(0, 0, 0, 0.10);
            background: var(--primary);
            color: var(--primary-dark);
            border-radius: 999px;
            padding: 0.7rem 1.15rem;
            font-weight: 850;
            cursor: pointer;
            white-space: nowrap;
            box-shadow: 0 10px 18px rgba(212, 175, 55, 0.22), 0 2px 6px rgba(15, 23, 42, 0.10);
            letter-spacing: 0.01em;
        }

        .see-more-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 14px 24px rgba(212, 175, 55, 0.26), 0 4px 10px rgba(15, 23, 42, 0.12);
            text-decoration: none;
        }

        .see-more-btn:active {
            transform: translateY(0);
            box-shadow: 0 8px 14px rgba(212, 175, 55, 0.20), 0 2px 6px rgba(15, 23, 42, 0.10);
        }

        /* Family Statistics Styles */
        .family-statistics-section {
            padding: var(--spacing-3xl) 0;
            background: white;
        }

        /* Hide empty insight strip for families (we render per-family panels instead) */
        #family-insights:empty {
            display: none;
        }

        .family-panels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: var(--spacing-xl);
        }

        .family-panel {
            background: var(--bg-primary);
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--stats-panel-border-on-dark);
        }

        .family-panel-title {
            font-size: 1.35rem;
            font-weight: 900;
            color: var(--text-primary);
            margin-bottom: 0.15rem;
        }

        .family-panel-subtitle {
            color: var(--text-secondary);
            font-weight: 700;
            font-size: 0.95rem;
            margin-bottom: var(--spacing-lg);
        }

        .family-panel-stats {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: var(--spacing-md);
            padding-bottom: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            border-bottom: 1px solid rgba(255, 255, 255, 0.14);
        }

        .family-panel-stat .k {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: var(--text-secondary);
            font-weight: 800;
            margin-bottom: 0.25rem;
        }

        .family-panel-stat .v {
            font-size: 1.25rem;
            font-weight: 900;
            color: var(--text-primary);
        }

        .family-panel-list {
            margin-bottom: var(--spacing-lg);
        }

        .family-panel-list:last-child {
            margin-bottom: 0;
        }

        .family-panel-list-title {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            font-weight: 900;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .family-chip-row .member-chip {
            background: rgba(255, 255, 255, 0.10);
            border-color: rgba(255, 255, 255, 0.18);
            color: var(--text-primary);
        }

        .family-chip-row .member-chip:hover {
            background: rgba(255, 255, 255, 0.16);
            text-decoration: underline;
        }

        .muted-inline {
            color: var(--text-secondary);
            font-style: italic;
            padding: 0.25rem 0;
        }

        .family-table-container {
            background: white;
            border-radius: var(--border-radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--stats-panel-border);
        }

        .family-table {
            width: 100%;
            border-collapse: collapse;
        }

        .family-table th {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            text-align: left;
            font-weight: 700;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-primary-dark);
            border-bottom: 1px solid var(--stats-panel-border-strong);
        }

        .family-table td {
            padding: var(--spacing-lg);
            border-bottom: 1px solid var(--border-light);
            color: var(--text-primary-dark);
            vertical-align: top;
        }

        .family-table tbody tr:hover {
            background: var(--bg-secondary);
        }

        .family-column {
            min-width: 160px;
        }

        .num-column {
            text-align: center;
            font-weight: 600;
            min-width: 90px;
        }

        .members-column {
            min-width: 260px;
        }

        .member-chip {
            display: inline-flex;
            padding: 0.25rem 0.55rem;
            border-radius: var(--border-radius-full);
            background: rgba(34, 197, 94, 0.10);
            border: 1px solid rgba(34, 197, 94, 0.18);
            color: var(--primary-dark);
            text-decoration: none;
            font-weight: 700;
            font-size: 0.85rem;
            margin: 0 0.35rem 0.35rem 0;
        }

        .member-chip:hover {
            background: rgba(34, 197, 94, 0.16);
            text-decoration: underline;
        }

        .member-chip--more {
            background: rgba(0,0,0,0.04);
            border-color: rgba(0,0,0,0.08);
            color: var(--text-secondary-dark);
            cursor: default;
            text-decoration: none;
        }

        .member-chip--more:hover {
            text-decoration: none;
        }

        .family-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: var(--spacing-xl);
        }

        .family-stat-card {
            background: var(--bg-primary);
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--stats-panel-border-on-dark);
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .family-stat-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-xl);
            border-color: var(--primary);
        }

        .family-rank {
            position: absolute;
            top: var(--spacing-lg);
            right: var(--spacing-lg);
            background: var(--primary);
            color: white;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--border-radius-full);
            font-weight: 600;
            font-size: 0.875rem;
        }

        .family-header {
            margin-bottom: var(--spacing-lg);
        }

        .family-name {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: var(--spacing-sm);
        }

        .family-average {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--primary);
        }

        .family-members {
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-lg);
            border-bottom: 1px solid rgba(255, 255, 255, 0.14);
        }

        .member-count {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: var(--spacing-sm);
            font-weight: 500;
        }

        .member-list {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-sm);
        }

        .member-link {
            background: white;
            color: var(--primary);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--border-radius);
            text-decoration: none;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s ease;
            border: 1px solid rgba(15, 23, 42, 0.12);
        }

        .member-link:hover {
            background: var(--primary);
            color: white;
        }

        .family-stats-grid-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--spacing-md);
        }

        .family-stat-item {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .family-stat-item .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }

        .family-stat-item .stat-value {
            font-size: 1.125rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        @media (max-width: 768px) {
            .hero-title {
                font-size: 2.5rem;
            }
            
            .overview-stats-grid {
                grid-template-columns: 1fr;
            }
            
            .analytics-grid {
                grid-template-columns: 1fr;
            }
            
            .family-stats-grid {
                grid-template-columns: 1fr;
            }
            
            .partnership-table-container {
                overflow-x: auto;
            }
            
            .partnership-table {
                min-width: 560px;
            }

            .family-table-container {
                overflow-x: auto;
            }

            .family-table {
                min-width: 900px;
            }

            .family-panels-grid {
                grid-template-columns: 1fr;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
            }
            
            .records-showcase {
                grid-template-columns: 1fr;
            }
        }
    </style>
</body>
</html>
