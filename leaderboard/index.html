<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hall of Fame - Player Rankings | Ruston Family Whist Drive</title>
    <meta name="description" content="Official rankings and leaderboards for the world's most prestigious family tournament - 40 years of championship excellence">
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo-section">
                    <div class="card-suits"><span class="heart">‚ô•</span> <span class="club">‚ô£</span> <span class="diamond">‚ô¶</span> <span class="spade">‚ô†</span></div>
                    <h1 class="site-title">Ruston Family Whist Drive</h1>
                    <p class="site-subtitle">Est. 1984 ‚Ä¢ The World's Most Elite Family Tournament</p>
                </div>
                <nav class="main-nav">
                    <a href="../" class="nav-link">Home</a>
                    <a href="../tournaments/" class="nav-link">Tournaments</a>
                    <a href="../players/" class="nav-link">Players</a>
                    <a href="#" class="nav-link active">Hall of Fame</a>
                    <a href="../stats/" class="nav-link">Statistics</a>
                </nav>
            </div>
        </div>
    </header>

    <div id="data-issues-banner" class="data-issues-banner" style="display: none;"></div>

    <main class="main-content">
        <section class="leaderboard-hero">
            <div class="container">
                <div class="hero-content">
                    <div class="hall-of-fame-badge">üèõÔ∏è HALL OF FAME</div>
                    <h1 class="hero-title">Championship Rankings</h1>
                    <p class="hero-subtitle">The Official Leaderboards of the World's Most Prestigious Family Tournament</p>
                </div>
            </div>
        </section>

        <section class="current-rankings">
            <div class="container">
                <div class="ranking-filters">
                    <button class="filter-btn active" data-ranking="overall">Official Seed Ranking</button>
                    <button class="filter-btn" data-ranking="championships">Tournament Wins</button>
                    <button class="filter-btn" data-ranking="booby">Booby Leaderboard</button>
                    <button class="filter-btn" data-ranking="career_stats">Career Wins</button>
                    <button class="filter-btn" data-ranking="recent_form">Recent Form</button>
                    <button class="filter-btn" data-ranking="performance">Performance</button>
                </div>

                <div class="rankings-header">
                    <h2 class="rankings-title" id="current-ranking-title">Official Seed Rankings</h2>
                    <p class="rankings-subtitle" id="current-ranking-description">Comprehensive ranking based on tournament victories, career performance, and recent form</p>
                </div>

                <div class="full-rankings-tools">
                    <button type="button" class="year-scrubber-btn" id="year-scrubber-btn" aria-haspopup="dialog" aria-expanded="false">
                        <span class="year-scrubber-btn__label" id="year-scrubber-btn-label">Year: Latest</span>
                        <span class="year-scrubber-btn__caret">‚ñæ</span>
                    </button>
                    <label class="sample-filter-toggle sample-filter-toggle--dark" for="toggle-sample-filter">
                        <input type="checkbox" id="toggle-sample-filter" checked>
                        <span class="sample-filter-toggle__text">Exclude players with low sample size</span>
                        <span class="sample-filter-toggle__hint">(2+ tournaments)</span>
                    </label>
                </div>

                <div class="year-scrubber-overlay" id="year-scrubber-overlay" style="display:none;">
                    <div class="year-scrubber-backdrop" id="year-scrubber-backdrop" aria-hidden="true"></div>
                    <div class="year-scrubber-panel" role="dialog" aria-modal="true" aria-label="Year scrubber">
                        <div class="year-scrubber-panel__header">
                            <div class="year-scrubber-panel__title" id="year-scrubber-title">Year: ‚Äî</div>
                            <button type="button" class="year-scrubber-panel__close" id="year-scrubber-close" aria-label="Close year scrubber">Close</button>
                        </div>
                        <div class="year-scrubber-panel__body">
                            <input type="range" id="year-scrubber-range" class="year-scrubber-range" min="0" max="0" step="1" value="0">
                            <div class="year-scrubber-ticks" id="year-scrubber-ticks" aria-hidden="true"></div>
                        </div>
                    </div>
                </div>

                <div class="full-rankings">
                    <div class="rankings-table">
                        <div class="rankings-table-header">
                            <div class="rank-col">Rank</div>
                            <div class="player-col">Player</div>
                            <div class="score-col">Score</div>
                            <div class="tournaments-col">Tournaments</div>
                            <div class="wins-col">Wins</div>
                            <div class="percentage-col">Win %</div>
                            <div class="trend-col">Trend</div>
                        </div>
                        <div class="rankings-table-body" id="rankings-table-body">
                            <!-- Rankings will be populated here -->
                        </div>
                    </div>
                    
                    <div class="table-controls">
                        <button id="toggle-view-btn" class="toggle-view-btn">
                            <span class="btn-text">See All Players</span>
                            <span class="btn-icon">üëÅÔ∏è</span>
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <section class="ranking-insights">
            <div class="container">
                <h2 class="section-title">
                    <span class="title-icon">üìä</span>
                    Championship Insights & Analysis
                </h2>
                
                <div class="insights-grid">
                    <div class="insight-card featured">
                        <div class="insight-icon">üëë</div>
                        <h3>Current Dynasty</h3>
                        <div class="insight-content">
                            <p id="insight-current-dynasty-text">Loading latest champion‚Ä¶</p>
                            <div class="insight-stat insight-stat--stacked">
                                <span class="stat-number" id="insight-current-dynasty-number">‚Äî</span>
                                <div class="insight-stat-meta">
                                    <span class="stat-label" id="insight-current-dynasty-label">Most recent winner</span>
                                    <div class="insight-stat-footnotes">
                                        <div class="hof-record-footnotes" id="insight-current-dynasty-footnotes"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="insight-card">
                        <div class="insight-icon">üèÜ</div>
                        <h3>All-Time Champion</h3>
                        <div class="insight-content">
                            <p id="insight-all-time-champ-text">Loading all-time champion‚Ä¶</p>
                            <div class="insight-stat insight-stat--stacked">
                                <span class="stat-number" id="insight-all-time-champ-number">‚Äî</span>
                                <div class="insight-stat-meta">
                                    <span class="stat-label" id="insight-all-time-champ-label">Total championships</span>
                                    <div class="insight-stat-footnotes">
                                        <div class="hof-record-footnotes" id="insight-all-time-champ-footnotes"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="insight-card">
                        <div class="insight-icon">ü•â</div>
                        <h3>Podium magnet</h3>
                        <div class="insight-content">
                            <p id="insight-consistency-text">Loading top-3 leader‚Ä¶</p>
                            <div class="insight-stat insight-stat--stacked">
                                <span class="stat-number" id="insight-consistency-number">‚Äî</span>
                                <div class="insight-stat-meta">
                                    <span class="stat-label" id="insight-consistency-label">Top-3 finishes</span>
                                    <div class="insight-stat-footnotes">
                                        <div class="hof-record-footnotes" id="insight-consistency-footnotes"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Record insights (all categories together) -->
                <div class="insights-subsection">
                    <div class="insights-grid" id="hof-record-insights-grid">
                        <div class="insight-card">
                            <div class="insight-icon">‚è≥</div>
                            <h3>Loading</h3>
                            <div class="insight-content">
                                <p class="muted">Loading insights‚Ä¶</p>
                                <div class="insight-stat">
                                    <span class="stat-number">‚Äî</span>
                                    <span class="stat-label">Please wait</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="historical-champions">
            <div class="container">
                <h2 class="section-title">
                    <span class="title-icon">üìú</span>
                    Championship History
                </h2>
                
                <div class="analytics-card" style="margin-bottom: var(--spacing-xl);">
                    <div style="display:flex; gap: 0.5rem; flex-wrap: wrap; align-items:center; justify-content: space-between;">
                        <div class="muted">One row per tournament. Sort by year or champion avg tricks.</div>
                        <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
                            <button class="btn btn-secondary" type="button" id="btn-sort-history-year">Sort: Year</button>
                            <button class="btn btn-secondary" type="button" id="btn-sort-history-avg">Sort: Champ Avg</button>
                        </div>
                    </div>
                    <div style="overflow:auto; margin-top: 0.75rem;">
                        <table class="report-table" style="min-width: 760px;">
                            <thead>
                                <tr>
                                    <th>Year</th>
                                    <th>Tournament</th>
                                    <th>1st</th>
                                    <th>2nd</th>
                                    <th>3rd</th>
                                    <th>1st Avg/round</th>
                                </tr>
                            </thead>
                            <tbody id="championship-history-body">
                                <tr>
                                    <td colspan="6" class="muted">Loading‚Ä¶</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <div class="championship-stats">
                    <div class="stat-card">
                        <div class="stat-icon">üèÜ</div>
                        <div class="stat-content">
                            <h4>Total Championships</h4>
                            <div class="stat-number" id="hof-total-championships">‚Äî</div>
                            <div class="stat-detail">Four Decades of Excellence</div>
                        </div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-icon">üë•</div>
                        <div class="stat-content">
                            <h4>Total Champions</h4>
                            <div class="stat-number" id="hof-total-champions">‚Äî</div>
                            <div class="stat-detail">Different Winners</div>
                        </div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-icon">üîÑ</div>
                        <div class="stat-content">
                            <h4>Most Consecutive</h4>
                            <div class="stat-number" id="hof-most-consecutive">‚Äî</div>
                            <div class="stat-detail" id="hof-most-consecutive-detail">Loading‚Ä¶</div>
                        </div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-icon">üìà</div>
                        <div class="stat-content">
                            <h4>Avg Entrants</h4>
                            <div class="stat-number" id="hof-avg-entrants">‚Äî</div>
                            <div class="stat-detail">Average tournament size</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="records-section">
            <div class="container">
                <h2 class="section-title">
                    <span class="title-icon">üî•</span>
                    Big Rounds Hall of Fame
                </h2>

                <div class="records-grid">
                    <div class="record-category">
                        <h3>12-trick rounds (chronological)</h3>
                        <div class="record-list" id="hof-12plus-list">
                            <div class="record-item">
                                <span class="record-title">Loading‚Ä¶</span>
                                <span class="record-holder">‚Äî</span>
                            </div>
                        </div>
                    </div>

                    <div class="record-category">
                        <h3>13-trick rounds</h3>
                        <div class="record-list" id="hof-13-list">
                            <div class="record-item">
                                <span class="record-title">None yet</span>
                                <span class="record-holder">When it happens, it will appear here.</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4>Hall of Fame</h4>
                    <p><a href="../players/">All Players</a></p>
                    <p><a href="../tournaments/">All Tournaments</a></p>
                    <p><a href="./">Rankings</a></p>
                </div>
                <div class="footer-section">
                    <h4>Statistics</h4>
                    <p><a href="../stats/">Advanced Analytics</a></p>
                    <p>Head-to-Head Records</p>
                    <p>Partnership Analysis</p>
                </div>
                <div class="footer-section">
                    <h4>Tournament History</h4>
                    <p><a href="../tournaments/">All Tournaments</a></p>
                    <p>Championship Timeline</p>
                    <p>Record Performances</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2024 Ruston Family Whist Drive. Hall of Fame excellence since 1984.</p>
            </div>
        </div>
    </footer>

            <script src="../assets/js/tournament-engine.js?v=cache1"></script>
    
    <script>
        // Leaderboard specific JavaScript
        let currentRankingType = 'overall';
        let allPlayers = [];
        let tournamentEngine = null;
        let showingAllPlayers = false;
        let currentSortedPlayers = [];
        let recentFormScoresAllTime = new Map();
        let performanceScoresAllTime = new Map();
        let currentRecentFormScores = new Map();
        let currentPerformanceScores = new Map();
        let excludeLowSampleSize = true;
        const MIN_TOURNAMENT_SAMPLE_SIZE = 2;
        const YEAR_SCRUBBER_RECENT_COUNT = 5;
        let availableYears = [];
        let latestYear = null;
        let selectedYear = null;
        let yearSnapshots = new Map(); // Map<year, { players, seedRankings, recentFormScores, performanceScores }>

        const rankingTypes = ['overall', 'championships', 'booby', 'career_stats', 'recent_form', 'performance'];
        const validRankingTypes = new Set(rankingTypes);
        const urlParams = new URLSearchParams(window.location.search);
        const initialRankingParam = urlParams.get('tab') || urlParams.get('ranking');
        if (initialRankingParam && validRankingTypes.has(initialRankingParam)) {
            currentRankingType = initialRankingParam;
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            initializeLeaderboard();
        });

        async function initializeLeaderboard() {
            try {
                // Initialize engine and load real data
                tournamentEngine = new TournamentEngine();
                const sheetId = '1HGfdlDOfGHOL6Q4MP_TnF8UNE6YihBW-5gQs6Ykl78k';

                console.log('üèÜ Loading real tournament data for Hall of Fame...');
                await tournamentEngine.loadFromGoogleSheets(sheetId);
                renderDataIssuesBanner(tournamentEngine.getDataIssues());

                // Get all players with comprehensive stats from real data
                allPlayers = tournamentEngine.getAllPlayers('overall');
                
                // Pre-calculate recent form and performance scores from actual tournament results
                recentFormScoresAllTime = typeof tournamentEngine.calculateRecentFormScores === 'function'
                    ? tournamentEngine.calculateRecentFormScores(YEAR_SCRUBBER_RECENT_COUNT)
                    : new Map();
                performanceScoresAllTime = typeof tournamentEngine.calculatePerformanceScores === 'function'
                    ? tournamentEngine.calculatePerformanceScores()
                    : new Map();

                // Build all year snapshots up-front (fast scrubbing)
                buildYearSnapshots();
                // Default to latest year (button still says "Latest")
                selectedYear = latestYear;
                setCurrentYearSnapshot(selectedYear);
                
                // Initialize rankings display
                updateRankingsDisplay(currentRankingType);
                
                // Generate championship history from real data
                generateChampionshipHistory();

                // Fill Hall of Fame panels (insights, records, big rounds) from real data
                renderHallOfFamePanels();
                
                // Add filter event listeners
                setupFilterListeners();
                
                // Add toggle view event listener
                setupToggleViewListener();

                // Sample size filter toggle
                setupSampleSizeToggle();
                
                // Year scrubber UI + handlers
                setupYearScrubber();

                console.log('üèÜ Hall of Fame loaded successfully with real data');

            } catch (error) {
                console.error('Error loading leaderboard:', error);
                loadFallbackData();
                if (tournamentEngine && typeof tournamentEngine.getDataIssues === 'function') {
                    renderDataIssuesBanner(tournamentEngine.getDataIssues());
                } else {
                    renderDataIssuesBanner(null);
                }
            }
        }

        function setText(id, text) {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = (text === null || typeof text === 'undefined') ? '‚Äî' : String(text);
        }

        function renderHallOfFamePanels() {
            try {
                if (!tournamentEngine) {
                    return;
                }

                const tournaments = typeof tournamentEngine.getAllTournamentsUnique === 'function'
                    ? tournamentEngine.getAllTournamentsUnique('asc')
                    : [];

                const champions = typeof tournamentEngine.getTournamentChampionsChronological === 'function'
                    ? tournamentEngine.getTournamentChampionsChronological()
                    : [];

                const totalTournaments = champions.length;
                const uniqueChampionSet = new Set(champions.map(c => c.winner).filter(Boolean));

                // --- Insights
                const setFootnotesHtml = (id, html) => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    el.innerHTML = html || '';
                };

                const joinHtmlList = (items) => {
                    const arr = (items || []).filter(Boolean);
                    if (arr.length === 0) return '';
                    if (arr.length === 1) return arr[0];
                    if (arr.length === 2) return `${arr[0]} & ${arr[1]}`;
                    return `${arr.slice(0, -1).join(', ')} & ${arr[arr.length - 1]}`;
                };

                const formatNamesInlineHtml = (names) => {
                    const parts = (names || []).filter(Boolean).map(n => `<span class="hof-name">${tournamentEngine.getDisplayName(n)}</span>`);
                    return joinHtmlList(parts);
                };

                const renderPlacementFootnotesHtml = (secondNames, thirdNames, options = {}) => {
                    const pos2 = (secondNames || []).filter(Boolean);
                    const pos3 = (thirdNames || []).filter(Boolean);
                    const tie2 = pos2.length > 1;
                    const showThird = !tie2 && pos3.length > 0;

                    const lines = [];

                    if (pos2.length) {
                        const label2 = tie2 ? 'TIED FOR 2ND' : '2ND';
                        const metric2 = options.secondMetricText ? ` with <span class="hof-lead-metric">${options.secondMetricText}</span>` : '';
                        lines.push(
                            `<div class="hof-record-footnote"><span class="hof-record-footnote-rank">${label2}:</span> <span class="hof-record-footnote-text">${formatNamesInlineHtml(pos2)}${metric2}.</span></div>`
                        );
                    }

                    if (showThird) {
                        const tie3 = pos3.length > 1;
                        const label3 = tie3 ? 'TIED FOR 3RD' : '3RD';
                        const metric3 = options.thirdMetricText ? ` with <span class="hof-lead-metric">${options.thirdMetricText}</span>` : '';
                        lines.push(
                            `<div class="hof-record-footnote"><span class="hof-record-footnote-rank">${label3}:</span> <span class="hof-record-footnote-text">${formatNamesInlineHtml(pos3)}${metric3}.</span></div>`
                        );
                    }

                    return lines.join('');
                };

                const latest = champions.length > 0 ? champions[champions.length - 1] : null;
                if (latest && latest.winner) {
                    const champName = tournamentEngine.getDisplayName(latest.winner);
                    const title = latest.title ? `‚Äú${latest.title}‚Äù` : 'the tournament';
                    const p = document.getElementById('insight-current-dynasty-text');
                    if (p) {
                        p.innerHTML = `<strong>${champName}</strong> won ${latest.year} ${title}.`;
                    }
                    setText('insight-current-dynasty-number', latest.year);
                    setText('insight-current-dynasty-label', 'Most recent champion');

                    // 2nd/3rd from the latest tournament standings (mirrors Championship History table logic).
                    const latestTournament = (tournaments || []).find(t => t && Number.isFinite(t.year) && t.year === latest.year) || ((tournaments || []).length ? (tournaments || [])[tournaments.length - 1] : null);
                    const st = latestTournament && Array.isArray(latestTournament.final_standings) ? latestTournament.final_standings : [];
                    const secondRows = st.filter(s => (Number(s?.position) === 2) && s?.player);
                    const thirdRows = st.filter(s => (Number(s?.position) === 3) && s?.player);
                    const secondNames = (secondRows.length ? secondRows : (st[1] ? [st[1]] : [])).map(s => s.player).filter(Boolean);
                    const thirdNames = (thirdRows.length ? thirdRows : (st[2] ? [st[2]] : [])).map(s => s.player).filter(Boolean);
                    setFootnotesHtml('insight-current-dynasty-footnotes', renderPlacementFootnotesHtml(secondNames, thirdNames));
                } else {
                    setText('insight-current-dynasty-text', 'No champion data available yet.');
                    setFootnotesHtml('insight-current-dynasty-footnotes', '');
                }

                const playersByWins = tournamentEngine.getAllPlayers('tournament_wins');
                const allTime = playersByWins && playersByWins.length > 0 ? playersByWins[0] : null;
                if (allTime) {
                    const p = document.getElementById('insight-all-time-champ-text');
                    if (p) {
                        p.innerHTML = `<strong>${tournamentEngine.getDisplayName(allTime.name)}</strong> leads with the most championships.`;
                    }
                    setText('insight-all-time-champ-number', allTime.tournament_wins || 0);
                    setText('insight-all-time-champ-label', 'Total championships');

                    // 2nd/3rd by championship wins (ties supported; if 2nd is tied we hide 3rd).
                    const eligible = (playersByWins || []).filter(pp => pp && (pp.tournament_wins || 0) > 0);
                    const winsToPlayers = new Map(); // wins -> [{id}]
                    for (const pp of eligible) {
                        const w = Number(pp.tournament_wins) || 0;
                        if (!winsToPlayers.has(w)) winsToPlayers.set(w, []);
                        winsToPlayers.get(w).push(pp.name);
                    }
                    const winsSorted = Array.from(winsToPlayers.keys()).sort((a, b) => b - a);
                    const secondWins = winsSorted.length > 1 ? winsSorted[1] : null;
                    const thirdWins = winsSorted.length > 2 ? winsSorted[2] : null;
                    const secondNames = (secondWins !== null) ? (winsToPlayers.get(secondWins) || []) : [];
                    const thirdNames = (thirdWins !== null) ? (winsToPlayers.get(thirdWins) || []) : [];
                    const fmtWins = (n) => (n === 1) ? '1 win' : `${n} wins`;
                    setFootnotesHtml('insight-all-time-champ-footnotes', renderPlacementFootnotesHtml(secondNames, thirdNames, {
                        secondMetricText: (secondWins !== null) ? fmtWins(secondWins) : '',
                        thirdMetricText: (thirdWins !== null) ? fmtWins(thirdWins) : ''
                    }));
                }

                // Consistency (top-3 finishes)
                const top3Leader = (allPlayers || []).slice().sort((a, b) => (b.top_three_finishes || 0) - (a.top_three_finishes || 0))[0];
                if (top3Leader) {
                    const p = document.getElementById('insight-consistency-text');
                    if (p) {
                        p.innerHTML = `<strong>${tournamentEngine.getDisplayName(top3Leader.name)}</strong> has the most top-3 finishes.`;
                    }
                    setText('insight-consistency-number', top3Leader.top_three_finishes || 0);
                    setText('insight-consistency-label', 'Top-3 finishes');

                    const eligible = (allPlayers || []).filter(pp => pp && (pp.top_three_finishes || 0) > 0);
                    const countToPlayers = new Map(); // count -> [id]
                    for (const pp of eligible) {
                        const c = Number(pp.top_three_finishes) || 0;
                        if (!countToPlayers.has(c)) countToPlayers.set(c, []);
                        countToPlayers.get(c).push(pp.name);
                    }
                    const countsSorted = Array.from(countToPlayers.keys()).sort((a, b) => b - a);
                    const secondCount = countsSorted.length > 1 ? countsSorted[1] : null;
                    const thirdCount = countsSorted.length > 2 ? countsSorted[2] : null;
                    const secondNames = (secondCount !== null) ? (countToPlayers.get(secondCount) || []) : [];
                    const thirdNames = (thirdCount !== null) ? (countToPlayers.get(thirdCount) || []) : [];
                    const fmtCount = (n) => (n === 1) ? '1 finish' : `${n} finishes`;
                    setFootnotesHtml('insight-consistency-footnotes', renderPlacementFootnotesHtml(secondNames, thirdNames, {
                        secondMetricText: (secondCount !== null) ? fmtCount(secondCount) : '',
                        thirdMetricText: (thirdCount !== null) ? fmtCount(thirdCount) : ''
                    }));
                }

                // --- Championship history stats
                setText('hof-total-championships', totalTournaments);
                setText('hof-total-champions', uniqueChampionSet.size);

                const streak = typeof tournamentEngine.getLongestChampionStreak === 'function'
                    ? tournamentEngine.getLongestChampionStreak()
                    : { winner: null, streak: 0, fromYear: null, toYear: null };
                setText('hof-most-consecutive', streak && streak.streak ? streak.streak : 0);
                const streakDetail = document.getElementById('hof-most-consecutive-detail');
                if (streakDetail) {
                    if (streak && streak.winner && streak.streak > 0) {
                        streakDetail.textContent = `${tournamentEngine.getDisplayName(streak.winner)} (${streak.fromYear}‚Äì${streak.toYear})`;
                    } else {
                        streakDetail.textContent = '‚Äî';
                    }
                }

                const avgEntrants = tournaments.length > 0
                    ? (tournaments.reduce((sum, t) => sum + (t.total_players || 0), 0) / tournaments.length)
                    : 0;
                setText('hof-avg-entrants', tournaments.length > 0 ? avgEntrants.toFixed(1) : '‚Äî');

                // --- Championship history table (1st/2nd/3rd + champ avg tricks)
                const historyBody = document.getElementById('championship-history-body');
                const sortYearBtn = document.getElementById('btn-sort-history-year');
                const sortAvgBtn = document.getElementById('btn-sort-history-avg');

                if (historyBody) {
                    const rows = tournaments
                        .filter(t => t && Number.isFinite(t.year) && Array.isArray(t.final_standings))
                        .map(t => {
                            const standings = t.final_standings || [];
                            const first = standings.find(s => s.position === 1) || standings[0] || null;
                            const second = standings.find(s => s.position === 2) || standings[1] || null;
                            const third = standings.find(s => s.position === 3) || standings[2] || null;

                            const firstName = first ? tournamentEngine.getDisplayName(first.player) : '‚Äî';
                            const secondName = second ? tournamentEngine.getDisplayName(second.player) : '‚Äî';
                            const thirdName = third ? tournamentEngine.getDisplayName(third.player) : '‚Äî';

                            const firstAvg = first && (first.average_tricks !== null && typeof first.average_tricks !== 'undefined')
                                ? parseFloat(first.average_tricks)
                                : null;

                            return {
                                year: t.year,
                                title: t.title || t.name || t.id,
                                firstName,
                                secondName,
                                thirdName,
                                firstAvg: Number.isFinite(firstAvg) ? firstAvg : null
                            };
                        });

                    let sortMode = 'year_desc';
                    const renderHistory = () => {
                        const sorted = rows.slice().sort((a, b) => {
                            if (sortMode === 'avg_desc') {
                                const av = a.firstAvg === null ? -Infinity : a.firstAvg;
                                const bv = b.firstAvg === null ? -Infinity : b.firstAvg;
                                if (bv !== av) return bv - av;
                                return b.year - a.year;
                            }
                            // year_desc
                            return b.year - a.year;
                        });

                        const nameCell = (name) => (name && name !== '‚Äî')
                            ? `<span class="hof-name">${name}</span>`
                            : '‚Äî';
                        historyBody.innerHTML = sorted.map(r => {
                            const avg = r.firstAvg === null ? '‚Äî' : r.firstAvg.toFixed(2);
                            return `
                                <tr>
                                    <td>${r.year}</td>
                                    <td>${r.title}</td>
                                    <td>${nameCell(r.firstName)}</td>
                                    <td>${nameCell(r.secondName)}</td>
                                    <td>${nameCell(r.thirdName)}</td>
                                    <td><span class="hof-value">${avg}</span></td>
                                </tr>
                            `;
                        }).join('') || `<tr><td colspan="6" class="muted">No tournaments found.</td></tr>`;
                    };

                    renderHistory();

                    if (sortYearBtn) {
                        sortYearBtn.addEventListener('click', () => {
                            sortMode = 'year_desc';
                            renderHistory();
                        });
                    }
                    if (sortAvgBtn) {
                        sortAvgBtn.addEventListener('click', () => {
                            sortMode = 'avg_desc';
                            renderHistory();
                        });
                    }
                }

                // --- Records (render Top 3 for each record into a single table)
                const recordsPanels = document.getElementById('hof-records-panels');
                const fmtPlayer = (playerId) => playerId ? tournamentEngine.getDisplayName(playerId) : '‚Äî';
                const fmt = (text) => (text === null || typeof text === 'undefined' || text === '') ? '‚Äî' : String(text);
                const makeEntry = (name, valueText, labelText, extraText) => ({
                    name: name || '‚Äî',
                    valueText: (valueText === null || typeof valueText === 'undefined') ? '' : String(valueText),
                    labelText: (labelText === null || typeof labelText === 'undefined') ? '' : String(labelText),
                    extraText: (extraText === null || typeof extraText === 'undefined') ? '' : String(extraText)
                });

                const ordinal = (n) => {
                    if (n === 1) return '1st';
                    if (n === 2) return '2nd';
                    if (n === 3) return '3rd';
                    return `${n}th`;
                };

                const buildRankGroups = (entries) => {
                    const groups = new Map();
                    for (const entry of (entries || [])) {
                        if (!entry || typeof entry !== 'object') continue;
                        const key = entry.key;
                        const sortValue = entry.sortValue;
                        const item = entry.item;
                        if (key === null || typeof key === 'undefined') continue;
                        if (!item) continue;
                        if (!groups.has(key)) {
                            groups.set(key, { key, sortValue: Number.isFinite(sortValue) ? sortValue : 0, items: [] });
                        }
                        groups.get(key).items.push(item);
                    }
                    return Array.from(groups.values()).sort((a, b) => (b.sortValue - a.sortValue));
                };

                const isTieGroup = (g) => !!(g && Array.isArray(g.items) && g.items.length > 1);
                const rankLabel = (rank, tied) => tied ? `Tied for ${ordinal(rank)}` : ordinal(rank);

                const formatExtraPhrase = (extraText) => {
                    const t = (extraText || '').trim();
                    if (!t) return '';
                    if (t.startsWith('Year ')) return `in ${t}`;
                    if (t.startsWith('Years ')) return `during ${t}`;
                    if (t.startsWith('from ') || t.startsWith('over ')) return t;
                    return t;
                };

                const joinList = (items) => {
                    const arr = (items || []).filter(Boolean);
                    if (arr.length === 0) return '';
                    if (arr.length === 1) return arr[0];
                    if (arr.length === 2) return `${arr[0]} & ${arr[1]}`;
                    return `${arr.slice(0, -1).join(', ')} & ${arr[arr.length - 1]}`;
                };

                const formatNamesHtml = (items, max = 3, includeExtra = false) => {
                    const arr = (items || []).filter(Boolean);
                    if (!arr.length) return '<span class="muted">No data</span>';
                    const isTie = arr.length > 1;
                    const head = isTie ? arr : arr.slice(0, max);
                    const more = isTie ? 0 : (arr.length - head.length);
                    const parts = head.map(i => {
                        const base = `<span class="hof-name">${i.name}</span>`;
                        if (!includeExtra || !i.extraText) return base;
                        return `${base} <span class="hof-detail">(${i.extraText})</span>`;
                    });
                    const joined = joinList(parts);
                    const moreHtml = more > 0 ? ` <span class="hof-detail">+${more} more</span>` : '';
                    return `${joined}${moreHtml}`;
                };

                const formatMetricText = (item) => {
                    if (!item) return '';
                    const v = (item.valueText || '').trim();
                    const l = (item.labelText || '').trim();
                    if (!v && !l) return '';
                    if (!l) return v;
                    if (!v) return l;
                    return `${v} ${l}`;
                };

                const renderRecordCard = (recordLabel, entries, options = {}) => {
                    const groups = buildRankGroups(entries);
                    const first = groups[0] || null;
                    const second = groups[1] || null;
                    const third = groups[2] || null;

                    const secondTied = isTieGroup(second);
                    const showThird = !secondTied && !!third;

                    const firstItem = first && first.items && first.items.length ? first.items[0] : null;
                    const tieForFirst = isTieGroup(first);
                    const winnerNamesHtml = first ? formatNamesHtml(first.items, 3, false) : '<span class="muted">No record yet</span>';
                    const verb = tieForFirst ? 'lead with' : 'leads with';

                    const metricText = firstItem ? formatMetricText(firstItem) : '';
                    const extraPhrase = firstItem ? formatExtraPhrase(firstItem.extraText) : '';

                    const firstExtraSet = new Set((first?.items || []).map(i => (i.extraText || '').trim()).filter(Boolean));
                    const tieExtrasDiffer = tieForFirst && firstExtraSet.size > 1;
                    const tieExtraLine = tieExtrasDiffer
                        ? `<div class="hof-record-lead-extras">${formatNamesHtml(first.items, 4, true)}</div>`
                        : '';

                    const mainLine = metricText
                        ? `<div class="hof-record-lead-sentence">${winnerNamesHtml} <span class="hof-lead-verb">${verb}</span> <span class="hof-lead-metric">${metricText}</span>${extraPhrase ? ` <span class="hof-lead-extra">${extraPhrase}</span>` : ''}.</div>`
                        : `<div class="hof-record-lead-sentence"><span class="muted">${options.noDataText || 'No data available yet.'}</span></div>`;

                    const renderFootnoteGroup = (rank, group) => {
                        if (!group || !Array.isArray(group.items) || group.items.length === 0) return '';
                        const tied = isTieGroup(group);
                        const label = rankLabel(rank, tied);
                        const item0 = group.items[0];
                        const metric = formatMetricText(item0);
                        const extraSet = new Set(group.items.map(i => (i.extraText || '').trim()).filter(Boolean));
                        const includeExtra = tied && extraSet.size > 1;
                        const names = formatNamesHtml(group.items, 3, includeExtra);
                        const extra = (!includeExtra && item0 && item0.extraText) ? formatExtraPhrase(item0.extraText) : '';
                        const withMetric = metric ? ` with <span class="hof-lead-metric">${metric}</span>` : '';
                        const withExtra = extra ? ` <span class="hof-lead-extra">${extra}</span>` : '';
                        return `<div class="hof-record-footnote"><span class="hof-record-footnote-rank">${label}:</span> <span class="hof-record-footnote-text">${names}${withMetric}${withExtra}.</span></div>`;
                    };

                    const footnotes = [
                        renderFootnoteGroup(2, second),
                        showThird ? renderFootnoteGroup(3, third) : ''
                    ].filter(Boolean).join('');

                    return `
                        <div class="hof-record-card insight-card">
                            <div class="hof-record-header">
                                <div class="hof-record-icon">üèÜ</div>
                                <div class="hof-record-title">${recordLabel}</div>
                            </div>
                            <div class="hof-record-main">
                                ${tieForFirst ? `<div class="hof-record-winner-rank">${rankLabel(1, true)}</div>` : ''}
                                ${mainLine}
                                ${tieExtraLine}
                            </div>
                            ${footnotes ? `
                                <div class="hof-record-divider"></div>
                                <div class="hof-record-footnotes">${footnotes}</div>
                            ` : ''}
                        </div>
                    `;
                };

                const renderInsightFromRecord = (headline, icon, recordLabel, entries, options = {}) => {
                    const groups = buildRankGroups(entries);
                    const first = groups[0] || null;
                    const second = groups[1] || null;
                    const third = groups[2] || null;

                    const secondTied = isTieGroup(second);
                    const showThird = !secondTied && !!third;

                    const firstItem = first && first.items && first.items.length ? first.items[0] : null;
                    const tieForFirst = isTieGroup(first);
                    const winnerNamesHtml = first ? formatNamesHtml(first.items, 3, false) : '<span class="muted">No record yet</span>';
                    const verb = tieForFirst ? 'lead with' : 'leads with';

                    const metricText = firstItem ? formatMetricText(firstItem) : '';
                    const extraPhrase = firstItem ? formatExtraPhrase(firstItem.extraText) : '';

                    const firstExtraSet = new Set((first?.items || []).map(i => (i.extraText || '').trim()).filter(Boolean));
                    const tieExtrasDiffer = tieForFirst && firstExtraSet.size > 1;
                    const tieExtraLine = tieExtrasDiffer
                        ? `<div class="hof-record-lead-extras">${formatNamesHtml(first.items, 4, true)}</div>`
                        : '';

                    const mainSentence = metricText
                        ? `<div class="hof-record-lead-sentence">${winnerNamesHtml} <span class="hof-lead-verb">${verb}</span> <span class="hof-lead-metric">${metricText}</span>${extraPhrase ? ` <span class="hof-lead-extra">${extraPhrase}</span>` : ''}.</div>`
                        : `<div class="hof-record-lead-sentence"><span class="muted">${options.noDataText || 'No data available yet.'}</span></div>`;

                    const renderInlineFootnote = (rank, group) => {
                        if (!group || !Array.isArray(group.items) || group.items.length === 0) return '';
                        const tied = isTieGroup(group);
                        const label = rankLabel(rank, tied);
                        const item0 = group.items[0];
                        const metric = formatMetricText(item0);
                        const extraSet = new Set(group.items.map(i => (i.extraText || '').trim()).filter(Boolean));
                        const includeExtra = tied && extraSet.size > 1;
                        const names = formatNamesHtml(group.items, 3, includeExtra);
                        const extra = (!includeExtra && item0 && item0.extraText) ? formatExtraPhrase(item0.extraText) : '';
                        const withMetric = metric ? ` with <span class="hof-lead-metric">${metric}</span>` : '';
                        const withExtra = extra ? ` <span class="hof-lead-extra">${extra}</span>` : '';
                        return `<div class="hof-record-footnote"><span class="hof-record-footnote-rank">${label}:</span> <span class="hof-record-footnote-text">${names}${withMetric}${withExtra}.</span></div>`;
                    };

                    const footnotes = [
                        renderInlineFootnote(2, second),
                        showThird ? renderInlineFootnote(3, third) : ''
                    ].filter(Boolean).join('');

                    const extractStatNumber = (item) => {
                        if (!item) return '‚Äî';
                        const raw = (typeof item.valueText === 'number') ? String(item.valueText) : String(item.valueText || '').trim();
                        if (!raw) return '‚Äî';
                        if (raw.endsWith('%')) return raw;
                        const m = raw.match(/-?\d+(\.\d+)?/);
                        return m ? m[0] : raw;
                    };

                    const statNumber = (firstItem && metricText) ? extractStatNumber(firstItem) : '‚Äî';
                    const statLabel = recordLabel;

                    return `
                        <div class="insight-card">
                            <div class="insight-icon">${icon}</div>
                            <h3>${headline}</h3>
                            <div class="insight-content">
                                <p>
                                    <span class="muted"><strong>${recordLabel}</strong></span><br>
                                    ${tieForFirst ? `<span class="hof-record-winner-rank">${rankLabel(1, true)}</span>` : ''}
                                    ${mainSentence}
                                    ${tieExtraLine}
                                    ${footnotes ? `<div class="hof-record-footnotes">${footnotes}</div>` : ''}
                                </p>
                                <div class="insight-stat">
                                    <span class="stat-number">${statNumber}</span>
                                    <span class="stat-label">${statLabel}</span>
                                </div>
                            </div>
                        </div>
                    `;
                };

                // Variant card style (used for "Deadliest closer" experiment):
                // - remove duplicated record label at top
                // - avoid repeating the numeric value in the main sentence
                // - move 2nd/3rd lines under the bottom stat label
                const renderInsightFromRecordCompact = (headline, icon, recordLabel, entries, options = {}) => {
                    const groups = buildRankGroups(entries);
                    const first = groups[0] || null;
                    const second = groups[1] || null;
                    const third = groups[2] || null;

                    const secondTied = isTieGroup(second);
                    const showThird = !secondTied && !!third;

                    const firstItem = first && first.items && first.items.length ? first.items[0] : null;
                    const tieForFirst = isTieGroup(first);
                    const winnerNamesHtml = first ? formatNamesHtml(first.items, 3, false) : '<span class="muted">No record yet</span>';

                    const firstExtraSet = new Set((first?.items || []).map(i => (i.extraText || '').trim()).filter(Boolean));
                    const tieExtrasDiffer = tieForFirst && firstExtraSet.size > 1;
                    const tieExtraLine = tieExtrasDiffer
                        ? `<div class="hof-record-lead-extras">${formatNamesHtml(first.items, 4, true)}</div>`
                        : '';

                    const renderInlineFootnote = (rank, group) => {
                        if (!group || !Array.isArray(group.items) || group.items.length === 0) return '';
                        const tied = isTieGroup(group);
                        const label = rankLabel(rank, tied);
                        const item0 = group.items[0];
                        const metric = formatMetricText(item0);
                        const extraSet = new Set(group.items.map(i => (i.extraText || '').trim()).filter(Boolean));
                        const includeExtra = tied && extraSet.size > 1;
                        const names = formatNamesHtml(group.items, 3, includeExtra);
                        const extra = (!includeExtra && item0 && item0.extraText) ? formatExtraPhrase(item0.extraText) : '';
                        const withMetric = metric ? ` with <span class="hof-lead-metric">${metric}</span>` : '';
                        const withExtra = extra ? ` <span class="hof-lead-extra">${extra}</span>` : '';
                        return `<div class="hof-record-footnote"><span class="hof-record-footnote-rank">${label}:</span> <span class="hof-record-footnote-text">${names}${withMetric}${withExtra}.</span></div>`;
                    };

                    const footnotes = [
                        renderInlineFootnote(2, second),
                        showThird ? renderInlineFootnote(3, third) : ''
                    ].filter(Boolean).join('');

                    const extractStatNumber = (item) => {
                        if (!item) return '‚Äî';
                        const raw = (typeof item.valueText === 'number') ? String(item.valueText) : String(item.valueText || '').trim();
                        if (!raw) return '‚Äî';
                        if (raw.endsWith('%')) return raw;
                        const m = raw.match(/-?\d+(\.\d+)?/);
                        return m ? m[0] : raw;
                    };

                    const statNumber = firstItem ? extractStatNumber(firstItem) : '‚Äî';
                    const leaderVerb = tieForFirst ? 'share' : 'has';

                    // Let each card provide a "meaning" sentence that avoids repeating the numeric value.
                    // Example: "the highest tournament score", "the most 12+ trick rounds", etc.
                    const primarySentence = (options && typeof options.primarySentence === 'string')
                        ? options.primarySentence.trim()
                        : '';
                    const fallbackSentence = `the record for ${String(recordLabel || '').toLowerCase()}`;
                    const sentence = primarySentence || fallbackSentence;

                    const leaderSentence = firstItem
                        ? `<p>${winnerNamesHtml} ${leaderVerb} ${sentence}.</p>`
                        : `<p class="muted">${options.noDataText || 'No data available yet.'}</p>`;

                    return `
                        <div class="insight-card">
                            <div class="insight-icon">${icon}</div>
                            <h3>${headline}</h3>
                            <div class="insight-content">
                                ${tieForFirst ? `<div class="hof-record-winner-rank">${rankLabel(1, true)}</div>` : ''}
                                ${leaderSentence}
                                ${tieExtraLine}
                                <div class="insight-stat insight-stat--stacked">
                                    <span class="stat-number">${statNumber}</span>
                                    <div class="insight-stat-meta">
                                        <span class="stat-label">${recordLabel}</span>
                                        ${footnotes ? `<div class="insight-stat-footnotes"><div class="hof-record-footnotes">${footnotes}</div></div>` : ''}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                };

                const renderSection = (emoji, sectionTitle, recordCardsHtml) => `
                    <div class="hof-records-section">
                        <h3 class="hof-records-section-title"><span class="hof-records-section-emoji">${emoji}</span> ${sectionTitle}</h3>
                        <div class="hof-records-grid">
                            ${recordCardsHtml}
                        </div>
                    </div>
                `;

                {
                    const championshipCards = [];
                    const performanceCards = [];
                    const participationCards = [];
                    const partnershipCards = [];
                    const performanceInsightCards = [];
                    const championshipInsightCards = [];
                    const participationInsightCards = [];
                    const partnershipInsightCards = [];

                    // Championship Records
                    {
                        const entries = (allPlayers || [])
                            .slice()
                            .filter(p => p && (p.tournament_wins || 0) > 0)
                            .map(p => {
                                const wins = p.tournament_wins || 0;
                                return { key: String(wins), sortValue: wins, item: makeEntry(fmtPlayer(p.name), wins, 'wins', '') };
                            });
                        championshipCards.push(renderRecordCard('Most Championships', entries));
                    }

                    // Most consecutive tournament championships (top 3)
                    {
                        championshipCards.push(renderRecordCard('Youngest Winner', [], { noDataText: 'Requires birth dates.' }));
                        championshipCards.push(renderRecordCard('Oldest Winner', [], { noDataText: 'Requires birth dates.' }));
                        championshipInsightCards.push(renderInsightFromRecordCompact('Young gun', 'üßí', 'Youngest Winner', [], { noDataText: 'Requires birth dates.' }));
                        championshipInsightCards.push(renderInsightFromRecordCompact('Late bloomer', 'üßì', 'Oldest Winner', [], { noDataText: 'Requires birth dates.' }));
                    }

                    // Performance Records
                    {
                        const tournamentScores = [];
                        for (const t of tournaments) {
                            const standings = Array.isArray(t.final_standings) ? t.final_standings : [];
                            for (const entry of standings) {
                                const tricks = Number.isFinite(entry.total_tricks) ? entry.total_tricks : parseFloat(entry.total_tricks);
                                if (!Number.isFinite(tricks)) continue;
                                tournamentScores.push({ player: entry.player, tricks, year: t.year });
                            }
                        }
                        tournamentScores.sort((a, b) => (b.tricks - a.tricks) || ((b.year || 0) - (a.year || 0)));

                        const entries = (tournamentScores || [])
                            .filter(x => x && Number.isFinite(x.tricks))
                            .map(x => ({ key: String(x.tricks), sortValue: x.tricks, item: makeEntry(fmtPlayer(x.player), x.tricks, 'tricks', `Year ${x.year}`) }));
                        performanceCards.push(renderRecordCard('Highest Tournament Score', entries));
                        performanceInsightCards.push(renderInsightFromRecordCompact('Single-tournament explosion', 'üí•', 'Highest Tournament Score', entries, {
                            primarySentence: 'the highest tournament score'
                        }));
                    }

                    const minRoundsForPct = 20;
                    const winPctLeaders = (allPlayers || [])
                        .filter(p => (p.total_rounds || 0) >= minRoundsForPct && (p.tournaments_played || 0) >= 2)
                        .map(p => ({ playerId: p.name, pct: (p.total_rounds || 0) > 0 ? ((p.rounds_won || 0) / p.total_rounds) * 100 : 0, rounds: p.total_rounds || 0 }))
                        .sort((a, b) => (b.pct - a.pct) || (b.rounds - a.rounds));
                    {
                        const entries = (winPctLeaders || [])
                            .filter(x => x && typeof x.pct === 'number')
                            .map(x => {
                                const pctText = x.pct.toFixed(1);
                                return { key: pctText, sortValue: x.pct, item: makeEntry(fmtPlayer(x.playerId), `${pctText}%`, 'win rate', '') };
                            });
                        performanceCards.push(renderRecordCard(`Best Win Percentage (7+ tricks, min ${minRoundsForPct} rounds)`, entries));
                        performanceInsightCards.push(renderInsightFromRecordCompact('Deadliest closer', 'üéØ', `Best Win Percentage (7+ tricks, min ${minRoundsForPct} rounds)`, entries, {
                            primarySentence: 'the best win rate percentage'
                        }));
                    }

                    {
                        const entries = (allPlayers || [])
                            .slice()
                            .sort((a, b) => (b.rounds_won || 0) - (a.rounds_won || 0))
                            .filter(p => p && (p.rounds_won || 0) > 0)
                            .map(p => {
                                const wins = Math.floor(parseFloat(p.rounds_won ?? 0) || 0);
                                return { key: String(wins), sortValue: wins, item: makeEntry(fmtPlayer(p.name), wins, 'round wins', '') };
                            });
                        performanceCards.push(renderRecordCard('Most Career Round Wins (7+ tricks)', entries));
                        performanceInsightCards.push(renderInsightFromRecordCompact('Relentless winner', 'üß±', 'Most Career Round Wins (7+ tricks)', entries, {
                            primarySentence: 'the most career round wins'
                        }));
                    }

                    if (typeof tournamentEngine.getPlayerHighTrickRoundCounts === 'function') {
                        {
                            const entries = (tournamentEngine.getPlayerHighTrickRoundCounts(11) || [])
                                .filter(x => x && (x.count || 0) > 0)
                                .map(x => {
                                    const value = (x.count === 1) ? '1 round' : `${x.count} rounds`;
                                    return { key: String(x.count), sortValue: x.count, item: makeEntry(x.playerName, value, '', 'where they scored 11 tricks or more') };
                                });
                            performanceCards.push(renderRecordCard('Most 11+ Trick Rounds', entries));
                            performanceInsightCards.push(renderInsightFromRecordCompact('Big-round specialist', 'üî•', 'Most 11+ Trick Rounds', entries, {
                                primarySentence: 'the most 11+ trick rounds'
                            }));
                        }

                        {
                            const entries = (tournamentEngine.getPlayerHighTrickRoundCounts(12) || [])
                                .filter(x => x && (x.count || 0) > 0)
                                .map(x => {
                                    const value = (x.count === 1) ? '1 round' : `${x.count} rounds`;
                                    return { key: String(x.count), sortValue: x.count, item: makeEntry(x.playerName, value, '', 'where they scored 12 tricks or more') };
                                });
                            performanceCards.push(renderRecordCard('Most 12+ Trick Rounds', entries));
                            performanceInsightCards.push(renderInsightFromRecordCompact('Monster rounds', 'üêâ', 'Most 12+ Trick Rounds', entries, {
                                primarySentence: 'the most 12+ trick rounds'
                            }));
                        }
                    } else {
                        performanceCards.push(renderRecordCard('Most 11+ Trick Rounds', []));
                        performanceCards.push(renderRecordCard('Most 12+ Trick Rounds', []));
                        performanceInsightCards.push(renderInsightFromRecordCompact('Big-round specialist', 'üî•', 'Most 11+ Trick Rounds', [], {
                            primarySentence: 'the most 11+ trick rounds'
                        }));
                        performanceInsightCards.push(renderInsightFromRecordCompact('Monster rounds', 'üêâ', 'Most 12+ Trick Rounds', [], {
                            primarySentence: 'the most 12+ trick rounds'
                        }));
                    }

                    if (typeof tournamentEngine.getPlayerMajorityWinStreaks === 'function') {
                        const entries = (tournamentEngine.getPlayerMajorityWinStreaks(7) || [])
                            .filter(s => s && (s.streak || 0) > 0)
                            .map(s => {
                                const from = s.from ? `Year ${s.from.year} R${s.from.round}` : '‚Äî';
                                const to = s.to ? `Year ${s.to.year} R${s.to.round}` : '‚Äî';
                                const streak = Math.floor(parseFloat(s.streak ?? 0) || 0);
                                return { key: String(streak), sortValue: streak, item: makeEntry(s.playerName, streak, 'rounds', `from ${from} to ${to}`) };
                            });
                        performanceCards.push(renderRecordCard('Longest Majority-Win Streak (7+ tricks)', entries));
                        performanceInsightCards.push(renderInsightFromRecordCompact('On a heater', 'üöÄ', 'Longest Majority-Win Streak (7+ tricks)', entries, {
                            primarySentence: 'the longest majority-win streak'
                        }));
                    } else {
                        performanceCards.push(renderRecordCard('Longest Majority-Win Streak (7+ tricks)', []));
                        performanceInsightCards.push(renderInsightFromRecordCompact('On a heater', 'üöÄ', 'Longest Majority-Win Streak (7+ tricks)', [], {
                            primarySentence: 'the longest majority-win streak'
                        }));
                    }

                    // Best tournament averages (top 3)
                    const perTournamentAverages = [];
                    for (const t of tournaments) {
                        if (!t || !Number.isFinite(t.year) || !Array.isArray(t.rounds)) continue;
                        const year = t.year;
                        const perPlayer = new Map();
                        const add = (playerId, tricks, margin) => {
                            if (!perPlayer.has(playerId)) perPlayer.set(playerId, { tricksSum: 0, marginSum: 0, rounds: 0 });
                            const agg = perPlayer.get(playerId);
                            agg.tricksSum += tricks;
                            agg.marginSum += margin;
                            agg.rounds += 1;
                        };
                        for (const round of (t.rounds || [])) {
                            for (const table of (round.tables || [])) {
                                const ps = Array.isArray(table.partnerships) ? table.partnerships : [];
                                for (let i = 0; i < ps.length; i++) {
                                    const p = ps[i];
                                    const tricks = Number.isFinite(p?.tricks) ? p.tricks : parseInt(p?.tricks, 10);
                                    if (!Number.isFinite(tricks)) continue;
                                    const opponent = ps.length === 2 ? ps[1 - i] : null;
                                    const opp = opponent && Number.isFinite(opponent.tricks) ? opponent.tricks : (13 - tricks);
                                    const margin = Number.isFinite(opp) ? (tricks - opp) : 0;
                                    const playerIds = []
                                        .concat(Array.isArray(p.position1) ? p.position1 : [])
                                        .concat(Array.isArray(p.position2) ? p.position2 : []);
                                    playerIds.forEach(id => add(id, tricks, margin));
                                }
                            }
                        }
                        for (const [playerId, agg] of perPlayer.entries()) {
                            if (!agg.rounds) continue;
                            perTournamentAverages.push({ playerId, year, avgTricks: agg.tricksSum / agg.rounds, avgMargin: agg.marginSum / agg.rounds });
                        }
                    }
                    perTournamentAverages.sort((a, b) => (b.avgTricks - a.avgTricks) || (b.year - a.year));
                    {
                        const entries = (perTournamentAverages || [])
                            .filter(x => x && typeof x.avgTricks === 'number' && Number.isFinite(x.avgTricks))
                            .map(x => {
                                const key = x.avgTricks.toFixed(2);
                                return { key, sortValue: x.avgTricks, item: makeEntry(fmtPlayer(x.playerId), key, 'avg tricks', `Year ${x.year}`) };
                            });
                        performanceCards.push(renderRecordCard('Best Avg Tricks (single tournament)', entries));
                        performanceInsightCards.push(renderInsightFromRecordCompact('Peak performance', 'üìà', 'Best Avg Tricks (single tournament)', entries, {
                            primarySentence: 'the best single-tournament average'
                        }));
                    }

                    // Participation Records
                    {
                        const entries = (allPlayers || [])
                            .slice()
                            .filter(p => p && (p.tournaments_played || 0) > 0)
                            .map(p => {
                                const played = p.tournaments_played || 0;
                                return { key: String(played), sortValue: played, item: makeEntry(fmtPlayer(p.name), played, 'tournaments', '') };
                            });
                        participationCards.push(renderRecordCard('Most Tournaments Played', entries));
                        participationInsightCards.push(renderInsightFromRecordCompact('The ironman', 'üß≥', 'Most Tournaments Played', entries, {
                            primarySentence: 'the most tournaments played'
                        }));
                    }
                    {
                        const entries = (allPlayers || [])
                            .slice()
                            .filter(p => p && (p.top_three_finishes || 0) > 0)
                            .map(p => {
                                const top3 = p.top_three_finishes || 0;
                                return { key: String(top3), sortValue: top3, item: makeEntry(fmtPlayer(p.name), top3, 'top-3 finishes', '') };
                            });
                        participationCards.push(renderRecordCard('Most Top-3 Finishes', entries));
                    }
                    {
                        const entries = (allPlayers || [])
                            .filter(p => (p.tournaments_played || 0) >= 10 && (p.booby_prizes || 0) === 0)
                            .map(p => {
                                const played = p.tournaments_played || 0;
                                return { key: String(played), sortValue: played, item: makeEntry(fmtPlayer(p.name), played, 'tournaments', 'and 0 last-place finishes') };
                            });
                        participationCards.push(renderRecordCard('Never Last Place (min 10 tournaments)', entries));
                        participationInsightCards.push(renderInsightFromRecordCompact('Never the booby', 'üõ°Ô∏è', 'Never Last Place (min 10 tournaments)', entries, {
                            primarySentence: 'the most tournaments without ever finishing last'
                        }));
                    }

                    // Partnership Records
                    if (typeof tournamentEngine.getPartnershipAnalysis === 'function') {
                        const partnerships = tournamentEngine.getPartnershipAnalysis() || [];
                        const partnershipAvgs = partnerships
                            .filter(p => p && Array.isArray(p.players) && p.players.length === 2 && (p.rounds_played || 0) >= 4)
                            .map(p => {
                                const avg = (p.total_tricks / p.rounds_played);
                                const names = p.players.map(id => tournamentEngine.getDisplayName(id)).join(' & ');
                                return { names, avg, rounds: p.rounds_played };
                            })
                        {
                            const entries = (partnershipAvgs || [])
                                .filter(x => x && typeof x.avg === 'number' && Number.isFinite(x.avg))
                                .sort((a, b) => (b.avg - a.avg) || (b.rounds - a.rounds))
                                .map(x => {
                                    const rounds = Math.floor(parseFloat(x.rounds ?? 0) || 0);
                                    return { key: x.avg.toFixed(2), sortValue: x.avg, item: makeEntry(x.names, x.avg.toFixed(2), 'avg tricks', `over ${rounds} rounds`) };
                                });
                            partnershipCards.push(renderRecordCard('Best Partnership (avg tricks)', entries));
                            partnershipInsightCards.push(renderInsightFromRecordCompact('Dream team', 'ü§ù', 'Best Partnership (avg tricks)', entries, {
                                primarySentence: 'the best partnership average'
                            }));
                        }

                        const partnerSets = new Map();
                        for (const pair of partnerships) {
                            if (!pair || !Array.isArray(pair.players) || pair.players.length !== 2) continue;
                            const a = pair.players[0];
                            const b = pair.players[1];
                            if (!partnerSets.has(a)) partnerSets.set(a, new Set());
                            if (!partnerSets.has(b)) partnerSets.set(b, new Set());
                            partnerSets.get(a).add(b);
                            partnerSets.get(b).add(a);
                        }
                        const mostPartnersAll = Array.from(partnerSets.entries())
                            .map(([playerId, set]) => ({ playerId, count: set.size }))
                        {
                            const entries = (mostPartnersAll || [])
                                .filter(x => x && (x.count || 0) > 0)
                                .sort((a, b) => (b.count - a.count) || fmtPlayer(a.playerId).localeCompare(fmtPlayer(b.playerId)))
                                .map(x => ({ key: String(x.count), sortValue: x.count, item: makeEntry(fmtPlayer(x.playerId), x.count, 'partners', '') }));
                            partnershipCards.push(renderRecordCard('Most Different Partners', entries));
                            partnershipInsightCards.push(renderInsightFromRecordCompact('Social connector', 'üï∏Ô∏è', 'Most Different Partners', entries, {
                                primarySentence: 'the most different partners'
                            }));
                        }
                    } else {
                        partnershipCards.push(renderRecordCard('Best Partnership (avg tricks)', []));
                        partnershipCards.push(renderRecordCard('Most Different Partners', []));
                        partnershipInsightCards.push(renderInsightFromRecordCompact('Dream team', 'ü§ù', 'Best Partnership (avg tricks)', [], {
                            primarySentence: 'the best partnership average'
                        }));
                        partnershipInsightCards.push(renderInsightFromRecordCompact('Social connector', 'üï∏Ô∏è', 'Most Different Partners', [], {
                            primarySentence: 'the most different partners'
                        }));
                    }

                    const sectionsHtml = [];
                    if (championshipCards.length) sectionsHtml.push(renderSection('üëë', 'Championship Records', championshipCards.join('')));
                    if (performanceCards.length) sectionsHtml.push(renderSection('üéØ', 'Performance Records', performanceCards.join('')));
                    if (participationCards.length) sectionsHtml.push(renderSection('üë•', 'Participation Records', participationCards.join('')));
                    if (partnershipCards.length) sectionsHtml.push(renderSection('ü§ù', 'Partnership Records', partnershipCards.join('')));

                    if (recordsPanels) {
                        recordsPanels.innerHTML = sectionsHtml.join('');
                    }

                    // Record insights: all categories together (no section sub-headings).
                    const insightsGrid = document.getElementById('hof-record-insights-grid');
                    if (insightsGrid) {
                        const cards = []
                            .concat(performanceInsightCards)
                            .concat(participationInsightCards)
                            .concat(partnershipInsightCards)
                            .concat(championshipInsightCards);
                        insightsGrid.innerHTML = cards.length
                            ? cards.join('')
                            : `<div class="muted">No insights available yet.</div>`;
                    }
                }

                // --- Big rounds lists (12 exactly, and 13)
                const list12 = document.getElementById('hof-12plus-list');
                if (list12 && typeof tournamentEngine.getHighTrickRoundEvents === 'function') {
                    const events12 = (tournamentEngine.getHighTrickRoundEvents(12) || []).filter(e => e && e.tricks === 12);
                    if (!events12.length) {
                        list12.innerHTML = `
                            <div class="record-item">
                                <span class="record-title">None yet</span>
                                <span class="record-holder">No 12-trick rounds found.</span>
                            </div>
                        `;
                    } else {
                        const maxRows = 60;
                        const rows = events12.slice(0, maxRows).map(e => {
                            const suit = e.trumpSuit ? ` ‚Ä¢ ${e.trumpSuit}` : '';
                            return `
                                <div class="record-item">
                                    <span class="record-title">${e.year} ‚Ä¢ Round ${e.round} ‚Ä¢ Table ${e.table}${suit}</span>
                                    <span class="record-holder">${e.partnership}</span>
                                </div>
                            `;
                        }).join('');
                        const more = events12.length > maxRows
                            ? `<div class="record-item"><span class="record-title">‚Ä¶and more</span><span class="record-holder">${events12.length - maxRows} more events</span></div>`
                            : '';
                        list12.innerHTML = rows + more;
                    }
                }

                const list13 = document.getElementById('hof-13-list');
                if (list13 && typeof tournamentEngine.getHighTrickRoundEvents === 'function') {
                    const events13 = tournamentEngine.getHighTrickRoundEvents(13);
                    if (events13 && events13.length > 0) {
                        list13.innerHTML = events13.map(e => {
                            const suit = e.trumpSuit ? ` ‚Ä¢ ${e.trumpSuit}` : '';
                            return `
                                <div class="record-item">
                                    <span class="record-title">${e.year} ‚Ä¢ Round ${e.round} ‚Ä¢ Table ${e.table}${suit}</span>
                                    <span class="record-holder">${e.partnership}</span>
                                </div>
                            `;
                        }).join('');
                    }
                }
            } catch (error) {
                console.warn('Unable to render Hall of Fame panels:', error);
            }
        }

        function setupFilterListeners() {
            const filterButtons = document.querySelectorAll('.filter-btn');
            
            filterButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const rankingType = this.dataset.ranking;
                    if (rankingType === currentRankingType) return;
                    updateRankingsDisplay(rankingType);
                });
            });
        }

        function setActiveFilterButton(rankingType) {
            const filterButtons = document.querySelectorAll('.filter-btn');
            filterButtons.forEach(button => {
                button.classList.toggle('active', button.dataset.ranking === rankingType);
            });
        }

        function updateURLWithRanking(rankingType) {
            const params = new URLSearchParams(window.location.search);
            if (rankingType === 'overall') {
                params.delete('tab');
                params.delete('ranking');
            } else {
                params.set('tab', rankingType);
            }
            const newQuery = params.toString();
            const newUrl = newQuery ? `${window.location.pathname}?${newQuery}` : window.location.pathname;
            window.history.replaceState(null, '', newUrl);
        }

        function setupToggleViewListener() {
            const toggleBtn = document.getElementById('toggle-view-btn');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', function() {
                    const wasShowingAll = showingAllPlayers;
                    showingAllPlayers = !showingAllPlayers;
                    updateToggleButton();
                    refreshRankingsTable();
                    
                    // If we just switched from showing all to showing top 10, scroll to top of table
                    if (wasShowingAll && !showingAllPlayers) {
                        const rankingsTitle = document.getElementById('current-ranking-title');
                        if (rankingsTitle) {
                            rankingsTitle.scrollIntoView({ 
                                behavior: 'smooth', 
                                block: 'start' 
                            });
                        }
                    }
                });
            }
        }

        function getTournamentsPlayedCount(player) {
            if (!player) return 0;
            const raw = player.tournaments_played ?? player.tournaments ?? player.total_tournaments ?? player.tournamentsPlayed;
            const n = Number.isFinite(raw) ? raw : parseFloat(raw);
            if (!Number.isFinite(n)) return 0;
            return Math.floor(n);
        }

        function applySampleSizeFilter(players) {
            const arr = Array.isArray(players) ? players : [];
            if (!excludeLowSampleSize) return arr;
            return arr.filter(p => getTournamentsPlayedCount(p) >= MIN_TOURNAMENT_SAMPLE_SIZE);
        }

        function refreshRankingsTable() {
            const filtered = applySampleSizeFilter(currentSortedPlayers);
            updateRankingsTable(filtered, showingAllPlayers ? filtered.length : 10);
        }

        let rankingsFlipToken = 0;

        function prefersReducedMotion() {
            try {
                return window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            } catch (e) {
                return false;
            }
        }

        function captureRankRowRects(container) {
            const map = new Map();
            if (!container) return map;
            const rows = container.querySelectorAll('.ranking-row[data-player-id]');
            rows.forEach(row => {
                const id = row.getAttribute('data-player-id');
                if (!id) return;
                map.set(id, row.getBoundingClientRect());
            });
            return map;
        }

        function animateRankingsFLIP(container, prevRects, hadRowsBefore) {
            if (!container) return;
            if (!hadRowsBefore) return; // avoid animating initial load from "nothing"
            if (prefersReducedMotion()) return;

            const token = ++rankingsFlipToken;
            const rows = Array.from(container.querySelectorAll('.ranking-row[data-player-id]'));
            if (!rows.length) return;

            rows.forEach(row => {
                row.style.transition = 'none';
                row.style.transform = '';
                row.style.opacity = '';
            });

            // Invert: set transform to keep old position
            rows.forEach(row => {
                const id = row.getAttribute('data-player-id');
                if (!id) return;
                const prev = prevRects.get(id);
                const next = row.getBoundingClientRect();

                if (prev) {
                    const dx = prev.left - next.left;
                    const dy = prev.top - next.top;
                    if (dx || dy) {
                        row.style.transform = `translate(${dx}px, ${dy}px)`;
                        row.dataset.flip = '1';
                    }
                } else {
                    // New entry fades/slides in slightly
                    row.style.opacity = '0';
                    row.style.transform = 'translate(0px, 10px)';
                    row.dataset.flip = '1';
                }
            });

            // Play: animate back to natural position
            requestAnimationFrame(() => {
                if (token !== rankingsFlipToken) return;
                rows.forEach(row => {
                    if (row.dataset.flip !== '1') return;
                    row.style.transition = 'transform 520ms cubic-bezier(0.2, 0.8, 0.2, 1), opacity 420ms ease';
                    row.style.transform = 'translate(0px, 0px)';
                    row.style.opacity = '1';
                });

                window.setTimeout(() => {
                    if (token !== rankingsFlipToken) return;
                    rows.forEach(row => {
                        delete row.dataset.flip;
                        row.style.transition = '';
                        row.style.transform = '';
                        row.style.opacity = '';
                    });
                }, 560);
            });
        }

        function setupSampleSizeToggle() {
            const toggle = document.getElementById('toggle-sample-filter');
            if (!toggle) return;
            excludeLowSampleSize = toggle.checked;
            toggle.addEventListener('change', () => {
                excludeLowSampleSize = toggle.checked;
                refreshRankingsTable();
            });
        }

        function getYearSnapshot(year) {
            const y = Number.isFinite(year) ? year : latestYear;
            return yearSnapshots && yearSnapshots.get(y);
        }

        function getPlayersForSelectedYear() {
            const snap = getYearSnapshot(selectedYear);
            return snap && Array.isArray(snap.players) ? snap.players : allPlayers;
        }

        function setCurrentYearSnapshot(year) {
            const snap = getYearSnapshot(year);
            if (!snap) {
                currentRecentFormScores = recentFormScoresAllTime;
                currentPerformanceScores = performanceScoresAllTime;
                return;
            }
            currentRecentFormScores = snap.recentFormScores || new Map();
            currentPerformanceScores = snap.performanceScores || new Map();
        }

        function buildYearSnapshots() {
            if (!tournamentEngine || typeof tournamentEngine.getAllTournamentsUnique !== 'function') {
                return;
            }

            const tournamentsAsc = tournamentEngine.getAllTournamentsUnique('asc')
                .filter(t => t && Number.isFinite(t.year) && Array.isArray(t.final_standings));
            const years = Array.from(new Set(tournamentsAsc.map(t => t.year))).sort((a, b) => a - b);
            availableYears = years;
            latestYear = years.length ? years[years.length - 1] : null;

            const tournamentsUpToYear = new Map();
            const running = [];
            years.forEach(y => {
                tournamentsAsc.filter(t => t.year === y).forEach(t => running.push(t));
                tournamentsUpToYear.set(y, running.slice());
            });

            const computePerformanceScoresForTournaments = (tournaments) => {
                const totals = new Map();
                (tournaments || []).forEach(t => {
                    const standings = Array.isArray(t.final_standings) ? t.final_standings : [];
                    if (!standings.length) return;
                    const totalPlayers = standings.length;
                    standings.forEach(standing => {
                        const percentile = (standing.position / totalPlayers) * 100;
                        const players = standing.is_partnership && standing.partnership_players
                            ? standing.partnership_players
                            : [standing.player];
                        players.forEach(playerId => {
                            if (!totals.has(playerId)) totals.set(playerId, { sum: 0, count: 0 });
                            const agg = totals.get(playerId);
                            agg.sum += percentile;
                            agg.count += 1;
                        });
                    });
                });
                const averages = new Map();
                for (const [playerId, stats] of totals.entries()) {
                    if (stats.count > 0) averages.set(playerId, stats.sum / stats.count);
                }
                return averages;
            };

            const computeRecentFormScoresForTournaments = (tournaments, recentCount = 5) => {
                const scores = new Map();
                const list = (tournaments || []).slice().sort((a, b) => (b.year || 0) - (a.year || 0)).slice(0, recentCount);
                if (!list.length) return scores;
                list.forEach((tournament, index) => {
                    const weight = recentCount - index;
                    const standings = Array.isArray(tournament.final_standings) ? tournament.final_standings : [];
                    const participantCount = standings.length;
                    if (!participantCount) return;
                    standings.forEach((standing, positionIndex) => {
                        const baseScore = participantCount - positionIndex;
                        const score = baseScore * weight;
                        const players = standing.is_partnership && standing.partnership_players
                            ? standing.partnership_players
                            : [standing.player];
                        players.forEach(playerId => {
                            scores.set(playerId, (scores.get(playerId) || 0) + score);
                        });
                    });
                });
                return scores;
            };

            const computeRoundWinsForTournament = (tournament) => {
                const wins = new Map();
                const rounds = Array.isArray(tournament.rounds) ? tournament.rounds : [];
                rounds.forEach(round => {
                    const tables = Array.isArray(round.tables) ? round.tables : [];
                    tables.forEach(table => {
                        const ps = Array.isArray(table.partnerships) ? table.partnerships : [];
                        ps.forEach(partnership => {
                            const tricks = Number.isFinite(partnership?.tricks) ? partnership.tricks : parseInt(partnership?.tricks, 10);
                            if (!Number.isFinite(tricks) || tricks < 7) return;
                            const pos1 = Array.isArray(partnership.position1) ? partnership.position1 : [];
                            const pos2 = Array.isArray(partnership.position2) ? partnership.position2 : [];
                            const creditPos1 = pos1.length ? (1 / pos1.length) : 0;
                            const creditPos2 = pos2.length ? (1 / pos2.length) : 0;
                            pos1.forEach(id => wins.set(id, (wins.get(id) || 0) + creditPos1));
                            pos2.forEach(id => wins.set(id, (wins.get(id) || 0) + creditPos2));
                        });
                    });
                });
                return wins;
            };

            // Build cumulative player stats year-by-year (to keep consistent with the main engine approach)
            const cumulative = new Map();
            const ensure = (playerId) => {
                if (!cumulative.has(playerId)) {
                    cumulative.set(playerId, {
                        name: playerId,
                        tournaments_played: 0,
                        total_tricks: 0,
                        total_rounds: 0,
                        rounds_won: 0,
                        tournament_wins: 0,
                        top_three_finishes: 0,
                        booby_prizes: 0,
                        booby_percentage: 0,
                        average_tricks: '0.00',
                        win_percentage: '0.0'
                    });
                }
                return cumulative.get(playerId);
            };

            const applyTournamentToCumulative = (tournament) => {
                const standings = Array.isArray(tournament.final_standings) ? tournament.final_standings : [];
                if (!standings.length) return;
                const totalEntrants = standings.length;
                const fallbackPosition = totalEntrants || 1;
                const worstPosition = standings.reduce((max, entry) => {
                    const entryPos = Number.isFinite(entry.position) ? entry.position : fallbackPosition;
                    return Math.max(max, entryPos);
                }, fallbackPosition);

                standings.forEach(standing => {
                    const entryPosition = Number.isFinite(standing.position) ? standing.position : fallbackPosition;
                    const isBoobyPlacement = totalEntrants > 0 && entryPosition >= worstPosition;
                    const isShared = standing.is_partnership && Array.isArray(standing.partnership_players) && standing.partnership_players.length;

                    if (isShared) {
                        const partners = standing.partnership_players;
                        const numPartners = partners.length || 2;
                        const splitTricks = (Number.isFinite(standing.total_tricks) ? standing.total_tricks : parseFloat(standing.total_tricks)) / numPartners;
                        const splitRounds = (Number.isFinite(standing.rounds_played) ? standing.rounds_played : parseFloat(standing.rounds_played)) / numPartners;
                        partners.forEach(playerId => {
                            const stats = ensure(playerId);
                            stats.tournaments_played += 1;
                            stats.total_tricks += Number.isFinite(splitTricks) ? splitTricks : 0;
                            stats.total_rounds += Number.isFinite(splitRounds) ? splitRounds : 0;
                            if (entryPosition === 1) stats.tournament_wins += 1;
                            if (entryPosition <= 3) stats.top_three_finishes += 1;
                            if (isBoobyPlacement) stats.booby_prizes += 1;
                        });
                    } else {
                        const playerId = standing.player;
                        if (!playerId) return;
                        const stats = ensure(playerId);
                        const tricks = Number.isFinite(standing.total_tricks) ? standing.total_tricks : parseFloat(standing.total_tricks);
                        const rounds = Number.isFinite(standing.rounds_played) ? standing.rounds_played : parseFloat(standing.rounds_played);
                        stats.tournaments_played += 1;
                        stats.total_tricks += Number.isFinite(tricks) ? tricks : 0;
                        stats.total_rounds += Number.isFinite(rounds) ? rounds : 0;
                        if (entryPosition === 1) stats.tournament_wins += 1;
                        if (entryPosition <= 3) stats.top_three_finishes += 1;
                        if (isBoobyPlacement) stats.booby_prizes += 1;
                    }
                });

                // Add rounds_won credits based on per-round results (7+ tricks)
                const winCredits = computeRoundWinsForTournament(tournament);
                for (const [playerId, credit] of winCredits.entries()) {
                    const stats = ensure(playerId);
                    stats.rounds_won += credit;
                }
            };

            const byYear = new Map();
            years.forEach(y => byYear.set(y, tournamentsAsc.filter(t => t.year === y)));

            years.forEach(year => {
                const yearTournaments = byYear.get(year) || [];
                yearTournaments.forEach(t => applyTournamentToCumulative(t));

                const players = Array.from(cumulative.values()).map(p => {
                    const avg = p.total_rounds > 0 ? (p.total_tricks / p.total_rounds) : 0;
                    const winPct = p.tournaments_played > 0 ? (p.tournament_wins / p.tournaments_played) * 100 : 0;
                    const boobyPct = p.tournaments_played > 0 ? (p.booby_prizes / p.tournaments_played) * 100 : 0;
                    return {
                        ...p,
                        average_tricks: avg ? avg.toFixed(2) : '0.00',
                        win_percentage: winPct.toFixed(1),
                        booby_percentage: parseFloat(boobyPct.toFixed(1))
                    };
                });

                const tournaments = tournamentsUpToYear.get(year) || [];
                const recentFormScores = computeRecentFormScoresForTournaments(tournaments, YEAR_SCRUBBER_RECENT_COUNT);
                const performanceScores = computePerformanceScoresForTournaments(tournaments);

                let seedRankings = [];
                if (typeof tournamentEngine.computeOfficialSeedRankingsForTournaments === 'function') {
                    seedRankings = tournamentEngine.computeOfficialSeedRankingsForTournaments(tournaments, true) || [];
                    // Ensure tournaments_played etc reflect the selected year window (for sample-size filter)
                    const mapByName = new Map(players.map(p => [p.name, p]));
                    seedRankings = seedRankings.map(entry => {
                        const stats = mapByName.get(entry.name);
                        return stats ? { ...entry, ...stats } : entry;
                    });
                }

                yearSnapshots.set(year, { players, seedRankings, recentFormScores, performanceScores });
            });
        }

        function updateYearButtonLabel() {
            const label = document.getElementById('year-scrubber-btn-label');
            if (!label) return;
            if (latestYear !== null && selectedYear === latestYear) {
                label.textContent = 'Year: Latest';
            } else if (selectedYear !== null) {
                label.textContent = `Year: ${selectedYear}`;
            } else {
                label.textContent = 'Year: Latest';
            }
        }

        function openYearScrubber() {
            const overlay = document.getElementById('year-scrubber-overlay');
            const btn = document.getElementById('year-scrubber-btn');
            if (!overlay || !btn) return;
            overlay.style.display = 'block';
            btn.setAttribute('aria-expanded', 'true');
            updateYearScrubberTitle();
        }

        function closeYearScrubber() {
            const overlay = document.getElementById('year-scrubber-overlay');
            const btn = document.getElementById('year-scrubber-btn');
            if (!overlay || !btn) return;
            overlay.style.display = 'none';
            btn.setAttribute('aria-expanded', 'false');
        }

        function updateYearScrubberTitle() {
            const title = document.getElementById('year-scrubber-title');
            if (!title) return;
            title.textContent = selectedYear ? `Year: ${selectedYear}` : 'Year: ‚Äî';
        }

        function setupYearScrubber() {
            const btn = document.getElementById('year-scrubber-btn');
            const overlay = document.getElementById('year-scrubber-overlay');
            const backdrop = document.getElementById('year-scrubber-backdrop');
            const closeBtn = document.getElementById('year-scrubber-close');
            const range = document.getElementById('year-scrubber-range');
            const ticks = document.getElementById('year-scrubber-ticks');

            if (!btn || !overlay || !backdrop || !closeBtn || !range || !ticks) return;
            if (!Array.isArray(availableYears) || availableYears.length === 0) {
                btn.disabled = true;
                return;
            }

            range.min = '0';
            range.max = String(Math.max(0, availableYears.length - 1));
            range.step = '1';
            const idx = Math.max(0, availableYears.indexOf(selectedYear));
            range.value = String(idx);

            // Build tick marks
            ticks.innerHTML = availableYears.map((y, i) => {
                const pct = availableYears.length <= 1 ? 0 : (i / (availableYears.length - 1)) * 100;
                return `<div class="year-scrubber-tick" style="left:${pct}%"></div>`;
            }).join('');

            updateYearButtonLabel();
            updateYearScrubberTitle();

            btn.addEventListener('click', () => openYearScrubber());
            closeBtn.addEventListener('click', () => closeYearScrubber());
            backdrop.addEventListener('click', () => closeYearScrubber());
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') closeYearScrubber();
            });

            const onChange = () => {
                const newIdx = parseInt(range.value, 10);
                const y = availableYears[Math.max(0, Math.min(newIdx, availableYears.length - 1))];
                selectedYear = y;
                setCurrentYearSnapshot(selectedYear);
                updateYearButtonLabel();
                updateYearScrubberTitle();
                updateRankingsDisplay(currentRankingType);
            };
            range.addEventListener('input', onChange);
        }

        const TRICK_WARNING_STORAGE_KEY = 'whist_hide_trick_mismatch_warning';

        function shouldDisplayTrickWarnings() {
            if (typeof window !== 'undefined' && window.TournamentUIConfig && window.TournamentUIConfig.showTrickImbalanceWarnings === false) {
                return false;
            }
            if (typeof window === 'undefined' || typeof window.localStorage === 'undefined') {
                return true;
            }
            try {
                return localStorage.getItem(TRICK_WARNING_STORAGE_KEY) !== 'true';
            } catch (error) {
                console.warn('Unable to read trick warning preference from localStorage:', error);
                return true;
            }
        }

        function summarizeTrickMismatchIssues(issues) {
            const tableMap = new Map();
            const roundSet = new Set();

            issues.forEach(issue => {
                const tournamentLabel = issue.tournament || issue.tournamentId || (issue.year ? `Year ${issue.year}` : 'Tournament');
                const roundLabel = typeof issue.round === 'number' ? issue.round : 'Unknown';
                const tableLabel = typeof issue.table === 'number' ? issue.table : 'Unknown';
                const roundKey = `${tournamentLabel}::${roundLabel}`;
                const tableKey = `${roundKey}::${tableLabel}`;

                roundSet.add(roundKey);
                if (!tableMap.has(tableKey)) {
                    tableMap.set(tableKey, {
                        tournament: tournamentLabel,
                        round: roundLabel,
                        table: tableLabel,
                        total: Number.isFinite(issue.actual) ? issue.actual : issue.actual || 'Unknown'
                    });
                }
            });

            return {
                totalRounds: roundSet.size,
                totalTables: tableMap.size,
                samples: Array.from(tableMap.values())
            };
        }

        function attachTrickWarningDismissHandler(banner) {
            const dismissButton = banner.querySelector('[data-dismiss-trick-warning]');
            if (!dismissButton) {
                return;
            }

            dismissButton.addEventListener('click', () => {
                try {
                    localStorage.setItem(TRICK_WARNING_STORAGE_KEY, 'true');
                } catch (error) {
                    console.warn('Unable to persist trick warning preference:', error);
                }

                const warningBlock = banner.querySelector('.data-issues-banner__warning');
                if (warningBlock) {
                    warningBlock.remove();
                }

                const hasErrors = banner.querySelector('.data-issues-banner__errors');
                if (!hasErrors) {
                    banner.style.display = 'none';
                    banner.innerHTML = '';
                }
            }, { once: true });
        }

        function renderDataIssuesBanner(dataIssuesSummary) {
            const banner = document.getElementById('data-issues-banner');
            if (!banner || !dataIssuesSummary || !Array.isArray(dataIssuesSummary.issues)) {
                if (banner) {
                    banner.style.display = 'none';
                    banner.innerHTML = '';
                }
                return;
            }

            const issues = dataIssuesSummary.issues;
            const errorIssues = issues.filter(issue => issue.severity === 'error');
            const trickWarnings = shouldDisplayTrickWarnings()
                ? issues.filter(issue => issue.type === 'trick_count_mismatch')
                : [];

            if (errorIssues.length === 0 && trickWarnings.length === 0) {
                banner.style.display = 'none';
                banner.innerHTML = '';
                return;
            }

            let bannerSections = '';

            if (errorIssues.length > 0) {
                const issueList = errorIssues.map(issue => {
                    const location = issue.sheet ? `${issue.sheet}${issue.row ? ` (Row ${issue.row})` : ''}` : '';
                    const message = issue.message || issue.details || 'An unknown data error occurred.';
                    return `<li>${location ? `<strong>${location}:</strong> ` : ''}${message}</li>`;
                }).join('');

                bannerSections += `
                    <div class="data-issues-banner__errors">
                        <strong>Data Import Errors Detected</strong>
                        <ul>${issueList}</ul>
                    </div>
                `;
            }

            if (trickWarnings.length > 0) {
                const summary = summarizeTrickMismatchIssues(trickWarnings);
                const warningItems = summary.samples.slice(0, 3).map(entry => {
                    return `<li>${entry.tournament} ¬∑ Round ${entry.round}, Table ${entry.table} (reported total: ${entry.total})</li>`;
                }).join('');

                bannerSections += `
                    <div class="data-issues-banner__warning">
                        <div class="data-issues-banner__warning-header">
                            <strong>Trick totals look unbalanced</strong>
                            <span class="data-issues-banner__pill">${summary.totalTables} table${summary.totalTables === 1 ? '' : 's'}</span>
                            <span class="data-issues-banner__pill">${summary.totalRounds} round${summary.totalRounds === 1 ? '' : 's'}</span>
                        </div>
                        <p>Each table should total 13 tricks. Historical data currently shows ${summary.totalTables} table${summary.totalTables === 1 ? '' : 's'} across ${summary.totalRounds} round${summary.totalRounds === 1 ? '' : 's'} where the totals differ.</p>
                        ${warningItems ? `<ul class="data-issues-banner__warning-list">${warningItems}</ul>` : ''}
                        <button type="button" class="data-issues-banner__dismiss" data-dismiss-trick-warning>
                            Hide trick mismatch warning
                        </button>
                    </div>
                `;
            }

            banner.innerHTML = `<div class="data-issues-banner__content">${bannerSections}</div>`;
            banner.style.display = 'block';
            attachTrickWarningDismissHandler(banner);
        }

        function updateToggleButton() {
            const toggleBtn = document.getElementById('toggle-view-btn');
            const btnText = toggleBtn.querySelector('.btn-text');
            const btnIcon = toggleBtn.querySelector('.btn-icon');
            
            if (showingAllPlayers) {
                btnText.textContent = 'Show Top 10 Only';
                btnIcon.textContent = 'üîü';
                toggleBtn.classList.add('showing-all');
            } else {
                btnText.textContent = 'See All Players';
                btnIcon.textContent = 'üëÅÔ∏è';
                toggleBtn.classList.remove('showing-all');
            }
        }

        function updateRankingsDisplay(rankingType) {
            let sortedPlayers;
            currentRankingType = rankingType;

            // Apply year-scoped maps for tab sorting/display
            const snapshot = getYearSnapshot(selectedYear);
            if (snapshot) {
                setCurrentYearSnapshot(selectedYear);
            }
            
            if (rankingType === 'overall') {
                // Use the new Official Seed Ranking system
                if (snapshot && Array.isArray(snapshot.seedRankings)) {
                    sortedPlayers = snapshot.seedRankings;
                } else if (tournamentEngine && typeof tournamentEngine.getOfficialSeedRankings === 'function') {
                    sortedPlayers = tournamentEngine.getOfficialSeedRankings(true);
                } else {
                    console.warn('Official seed rankings not available, falling back to legacy method');
                    sortedPlayers = sortPlayersByRanking(getPlayersForSelectedYear(), rankingType);
                }
            } else {
                sortedPlayers = sortPlayersByRanking(getPlayersForSelectedYear(), rankingType);
            }
            
            // Store sorted players for toggle functionality
            currentSortedPlayers = sortedPlayers;
            
            // Update title and description
            updateRankingInfo(rankingType);
            
            // Preserve the current view state (top 10 or all players)
            updateToggleButton();
            
            // Update rankings table with current view preference
            refreshRankingsTable();
            
            setActiveFilterButton(rankingType);
            updateURLWithRanking(rankingType);
        }

        function sortPlayersByRanking(players, rankingType) {
            if (rankingType === 'booby') {
                return players
                    .map(player => ({ ...player }))
                    .sort((a, b) => {
                        const boobyDiff = (b.booby_prizes || 0) - (a.booby_prizes || 0);
                        if (boobyDiff !== 0) {
                            return boobyDiff;
                        }
                        const pctDiff = (b.booby_percentage || 0) - (a.booby_percentage || 0);
                        if (pctDiff !== 0) {
                            return pctDiff;
                        }
                        return (a.tournaments_played || 0) - (b.tournaments_played || 0);
                    });
            }

            const playersWithScores = players.map(player => ({
                ...player,
                rankingScore: calculateRankingScore(player, rankingType)
            }));

            return playersWithScores.sort((a, b) => {
                if (rankingType === 'recent_form') {
                    // For recent form, higher is better
                    return b.rankingScore - a.rankingScore;
                }
                return b.rankingScore - a.rankingScore;
            });
        }

        function calculateRankingScore(player, rankingType) {
            switch (rankingType) {
                case 'overall':
                    // Legacy weighted combination of multiple factors
                    const tournamentWeight = (player.tournament_wins || 0) * 10;
                    const winPctWeight = parseFloat(player.win_percentage || 0) * 2;
                    const careerWeight = (player.career_wins || 0) * 0.1;
                    const consistencyWeight = (player.top_three_finishes || 0) * 0.5;
                    return tournamentWeight + winPctWeight + careerWeight + consistencyWeight;
                
                case 'championships':
                    return player.tournament_wins || 0;
                
                case 'career_stats':
                    // Sort by win percentage (rounds_won / total_rounds)
                    const winRate = player.total_rounds > 0 ? (player.rounds_won / player.total_rounds) * 100 : 0;
                    return winRate;
                
                case 'recent_form':
                    // Use recent form scores derived from latest tournaments
                    return currentRecentFormScores.get(player.name) || 0;
                
                case 'performance':
                    if (!currentPerformanceScores.size) return 0;
                    const percentile = currentPerformanceScores.get(player.name);
                    if (typeof percentile !== 'number') return 0;
                    // Lower percentile is better, so convert to performance score where higher is better
                    return 100 - percentile;
                case 'booby':
                    return player.booby_prizes || 0;
                
                default:
                    return 0;
            }
        }

        function updateRankingInfo(rankingType) {
            const titleElement = document.getElementById('current-ranking-title');
            const descElement = document.getElementById('current-ranking-description');
            
            const rankingInfo = {
                overall: {
                    title: 'Official Seed Rankings',
                    desc: 'Weighted ranking system prioritizing recent performance, consistency, and tournament achievements'
                },
                championships: {
                    title: 'Tournament Championships',
                    desc: 'Players ranked by total number of tournament victories achieved'
                },
                career_stats: {
                    title: 'Career Wins',
                    desc: 'Players ranked by round win percentage - total rounds won vs rounds played'
                },
                recent_form: {
                    title: 'Recent Form Rankings',
                    desc: 'Current performance and momentum based on last 5 tournaments'
                },
                performance: {
                    title: 'Performance Rankings',
                    desc: 'Average tournament finish position as a top percentile adjusted for tournament size (lower percentile = better ‚Äî e.g., top 10%)'
                },
                booby: {
                    title: 'Booby Leaderboard',
                    desc: 'Number of booby prizes (last-place finishes) earned, plus the share of tournaments where a player finished last'
                }
            };
            
            const info = rankingInfo[rankingType] || rankingInfo.overall;
            titleElement.textContent = info.title;
            descElement.textContent = info.desc;
        }



        function updateRankingsTable(players, limit = players.length) {
            const tableBody = document.getElementById('rankings-table-body');
            const hadRowsBefore = !!(tableBody && tableBody.children && tableBody.children.length);
            const prevRects = captureRankRowRects(tableBody);
            
            // Update table headers based on ranking type
            updateTableHeaders(currentRankingType);
            
            // Limit the number of players shown
            const displayPlayers = players.slice(0, limit);
            
            const tableHTML = displayPlayers.map((player, index) => {
                const trend = generateTrendIndicator(player, index + 1, currentRankingType);
                const medalIcon = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : '';
                
                if (currentRankingType === 'career_stats') {
                    // Special layout for Career Wins
                    const roundsWonDisplay = Math.floor(parseFloat(player.rounds_won ?? 0) || 0).toString();
                    const roundsPlayedDisplay = Math.floor(parseFloat(player.total_rounds ?? 0) || 0).toString();
                    return `
                        <div class="ranking-row ${index < 3 ? 'podium-row' : ''}" data-player-id="${player.name}">
                            <div class="rank-col">
                                <span class="rank-number">${index + 1}</span>
                                <span class="rank-medal">${medalIcon}</span>
                            </div>
                            <div class="player-col">
                                <a href="../players/profile.html?player=${encodeURIComponent(player.name)}" class="player-link">
                                    <span class="player-name">${tournamentEngine.getDisplayName(player.name)}</span>
                                </a>
                            </div>
                            <div class="rounds-won-col">${roundsWonDisplay}</div>
                            <div class="rounds-played-col">${roundsPlayedDisplay}</div>
                            <div class="score-col">${player.total_rounds > 0 ? ((player.rounds_won / player.total_rounds) * 100).toFixed(1) : '0.0'}%</div>
                            <div class="trend-col">${trend}</div>
                        </div>
                    `;
                } else if (currentRankingType === 'performance') {
                    return `
                        <div class="ranking-row ${index < 3 ? 'podium-row' : ''}" data-player-id="${player.name}">
                            <div class="rank-col">
                                <span class="rank-number">${index + 1}</span>
                                <span class="rank-medal">${medalIcon}</span>
                            </div>
                            <div class="player-col">
                                <a href="../players/profile.html?player=${encodeURIComponent(player.name)}" class="player-link">
                                    <span class="player-name">${tournamentEngine.getDisplayName(player.name)}</span>
                                </a>
                            </div>
                            <div class="score-col">${formatScoreDisplay(player, currentRankingType)}</div>
                            <div class="tournaments-col">${player.tournaments_played || 0}</div>
                            <div class="trend-col">${trend}</div>
                        </div>
                    `;
                } else if (currentRankingType === 'championships') {
                    const topThreeDisplay = player.top_three_finishes ?? player.top_three ?? 0;
                    return `
                        <div class="ranking-row ${index < 3 ? 'podium-row' : ''}" data-player-id="${player.name}">
                            <div class="rank-col">
                                <span class="rank-number">${index + 1}</span>
                                <span class="rank-medal">${medalIcon}</span>
                            </div>
                            <div class="player-col">
                                <a href="../players/profile.html?player=${encodeURIComponent(player.name)}" class="player-link">
                                    <span class="player-name">${tournamentEngine.getDisplayName(player.name)}</span>
                                </a>
                            </div>
                            <div class="wins-col">${player.tournament_wins || 0}</div>
                            <div class="podium-col">${topThreeDisplay}</div>
                            <div class="tournaments-col">${player.tournaments_played || 0}</div>
                            <div class="trend-col">${trend}</div>
                        </div>
                    `;
                } else if (currentRankingType === 'booby') {
                    const boobyWins = player.booby_prizes || 0;
                    const totalTournaments = player.tournaments_played || 0;
                    let boobyPctValue = typeof player.booby_percentage === 'number'
                        ? player.booby_percentage
                        : parseFloat(player.booby_percentage);
                    if (Number.isNaN(boobyPctValue)) {
                        boobyPctValue = totalTournaments > 0 ? (boobyWins / totalTournaments) * 100 : 0;
                    }
                    const boobyPctDisplay = boobyPctValue.toFixed(1);
                    return `
                        <div class="ranking-row ${index < 3 ? 'podium-row' : ''}" data-player-id="${player.name}">
                            <div class="rank-col">
                                <span class="rank-number">${index + 1}</span>
                                <span class="rank-medal">${medalIcon}</span>
                            </div>
                            <div class="player-col">
                                <a href="../players/profile.html?player=${encodeURIComponent(player.name)}" class="player-link">
                                    <span class="player-name">${tournamentEngine.getDisplayName(player.name)}</span>
                                </a>
                            </div>
                            <div class="booby-count-col">${boobyWins}</div>
                            <div class="booby-percent-col">${boobyPctDisplay}%</div>
                            <div class="tournaments-col">${totalTournaments}</div>
                            <div class="trend-col">${trend}</div>
                        </div>
                    `;
                } else if (currentRankingType === 'overall') {
                    return `
                        <div class="ranking-row ${index < 3 ? 'podium-row' : ''}" data-player-id="${player.name}">
                            <div class="rank-col">
                                <span class="rank-number">${index + 1}</span>
                                <span class="rank-medal">${medalIcon}</span>
                            </div>
                            <div class="player-col">
                                <a href="../players/profile.html?player=${encodeURIComponent(player.name)}" class="player-link">
                                    <span class="player-name">${tournamentEngine.getDisplayName(player.name)}</span>
                                </a>
                            </div>
                            <div class="score-col">${formatScoreDisplay(player, currentRankingType)}</div>
                            <div class="recent-col">${player.tournaments_in_period ?? 0}</div>
                            <div class="wins-col">${player.championships ?? 0}</div>
                            <div class="podium-col">${player.podium_finishes ?? 0}</div>
                            <div class="avg-finish-col">${player.avg_finish ?? '‚Äî'}</div>
                            <div class="trend-col">${trend}</div>
                        </div>
                    `;
                } else {
                    // Standard layout for other ranking types
                    return `
                        <div class="ranking-row ${index < 3 ? 'podium-row' : ''}" data-player-id="${player.name}">
                            <div class="rank-col">
                                <span class="rank-number">${index + 1}</span>
                                <span class="rank-medal">${medalIcon}</span>
                            </div>
                            <div class="player-col">
                                <a href="../players/profile.html?player=${encodeURIComponent(player.name)}" class="player-link">
                                    <span class="player-name">${tournamentEngine.getDisplayName(player.name)}</span>
                                </a>
                            </div>
                            <div class="score-col">${formatScoreDisplay(player, currentRankingType)}</div>
                            <div class="tournaments-col">${player.tournaments_played || 0}</div>
                            <div class="wins-col">${player.tournament_wins || 0}</div>
                            <div class="percentage-col">${player.win_percentage || '0.0'}%</div>
                            <div class="trend-col">${trend}</div>
                        </div>
                    `;
                }
            }).join('');
            
            tableBody.innerHTML = tableHTML;
            animateRankingsFLIP(tableBody, prevRects, hadRowsBefore);
        }

        function updateTableHeaders(rankingType) {
            const tableHeader = document.querySelector('.rankings-table-header');
            const rankingsTable = document.querySelector('.full-rankings');

            rankingsTable.classList.remove('career-stats', 'performance-stats', 'seed-stats', 'championships-layout', 'booby-stats');
            
            if (rankingType === 'career_stats') {
                // Add career-stats class for special layout
                rankingsTable.classList.add('career-stats');
                
                // Special layout for Career Wins
                tableHeader.innerHTML = `
                    <div class="rank-col">Rank</div>
                    <div class="player-col">Player</div>
                    <div class="rounds-won-col">Rounds Won</div>
                    <div class="rounds-played-col">Rounds Played</div>
                    <div class="score-col">Round Win %</div>
                    <div class="trend-col">Trend</div>
                `;
            } else if (rankingType === 'performance') {
                rankingsTable.classList.add('performance-stats');
                
                tableHeader.innerHTML = `
                    <div class="rank-col">Rank</div>
                    <div class="player-col">Player</div>
                    <div class="score-col">${getScoreHeaderText(rankingType)}</div>
                    <div class="tournaments-col">Tournaments</div>
                    <div class="trend-col">Trend</div>
                `;
            } else if (rankingType === 'booby') {
                rankingsTable.classList.add('booby-stats');
                
                tableHeader.innerHTML = `
                    <div class="rank-col">Rank</div>
                    <div class="player-col">Player</div>
                    <div class="booby-count-col">Booby Wins</div>
                    <div class="booby-percent-col">Booby %</div>
                    <div class="tournaments-col">Tournaments</div>
                    <div class="trend-col">Trend</div>
                `;
            } else if (rankingType === 'championships') {
                rankingsTable.classList.add('championships-layout');

                tableHeader.innerHTML = `
                    <div class="rank-col">Rank</div>
                    <div class="player-col">Player</div>
                    <div class="wins-col">Wins</div>
                    <div class="podium-col">Top 3</div>
                    <div class="tournaments-col">Tournaments</div>
                    <div class="trend-col">Trend</div>
                `;
            } else {
                // Standard layout for other ranking types
                if (rankingType === 'overall') {
                    rankingsTable.classList.add('seed-stats');
                    tableHeader.innerHTML = `
                        <div class="rank-col">Rank</div>
                        <div class="player-col">Player</div>
                        <div class="score-col">${getScoreHeaderText(rankingType)}</div>
                        <div class="recent-col">Recent (6)</div>
                        <div class="wins-col">Championships</div>
                        <div class="podium-col">Podiums</div>
                        <div class="avg-finish-col">Avg Finish</div>
                        <div class="trend-col">Trend</div>
                    `;
                } else {
                    tableHeader.innerHTML = `
                        <div class="rank-col">Rank</div>
                        <div class="player-col">Player</div>
                        <div class="score-col">${getScoreHeaderText(rankingType)}</div>
                        <div class="tournaments-col">Tournaments</div>
                        <div class="wins-col">Wins</div>
                        <div class="percentage-col">Win %</div>
                        <div class="trend-col">Trend</div>
                    `;
                }
            }
        }
        
        function getScoreHeaderText(rankingType) {
            switch (rankingType) {
                case 'overall':
                    return 'Score';
                case 'championships':
                    return 'Championships';
                case 'recent_form':
                    return 'Form Score';
                case 'performance':
                    return 'Top Percentile Finish Position';
                case 'booby':
                    return 'Booby Wins';
                default:
                    return 'Score';
            }
        }

        function formatScoreDisplay(player, rankingType) {
            switch (rankingType) {
                case 'overall':
                    // Display seed points for Official Seed Ranking system
                    return player.seed_points || Math.round(player.rankingScore || 0);
                case 'championships':
                    return player.tournament_wins || 0;
                case 'career_stats':
                    // Display win percentage (the sorting metric) in the score column
                    const winPct = player.total_rounds > 0 ? ((player.rounds_won / player.total_rounds) * 100).toFixed(1) : '0.0';
                    return `${winPct}%`;
                case 'recent_form':
                    return Math.round(player.rankingScore || 0);
                case 'performance':
                    const percentile = currentPerformanceScores.get(player.name);
                    return typeof percentile === 'number' ? `${percentile.toFixed(1)}%` : '‚Äî';
                case 'booby':
                    return player.booby_prizes || 0;
                default:
                    return '0';
            }
        }

        function getInitials(name) {
            return name.split(' ').map(word => word[0]).join('');
        }

        function getPlayerNickname(name) {
            // Nicknames removed from Hall of Fame ranking rows (kept for player profile only).
            return '';
        }

        function generateTrendIndicator(player, currentPosition, rankingType) {
            // Calculate real trend by comparing position before and after most recent tournament
            try {
                if (!tournamentEngine || typeof tournamentEngine.calculatePlayerTrend !== 'function') {
                    // Fallback if trend calculation not available
                    return '‚Äî';
                }
                
                const trend = tournamentEngine.calculatePlayerTrend(player.name, rankingType);
                
                if (trend > 0) {
                    return '<span style="color: #10b981;">‚Üó</span>'; // Green up arrow
                } else if (trend < 0) {
                    return '<span style="color: #ef4444;">‚Üò</span>'; // Red down arrow
                } else {
                    return '<span style="color: #6b7280;">‚Äî</span>'; // Gray dash for no change
                }
            } catch (error) {
                console.warn('Error calculating trend for', player.name, ':', error);
                return '‚Äî';
            }
        }

        function generateChampionshipHistory() {
            // Championship history is now rendered as a table via renderHallOfFamePanels().
            return;
        }

        function loadFallbackData() {
            // No dummy data: show an error state.
            console.log('Leaderboard data unavailable; skipping fallback dummy data.');
            allPlayers = [];
            const tableBody = document.getElementById('rankings-table-body');
            if (tableBody) {
                tableBody.innerHTML = `<div style="padding: 1rem;">Unable to load tournament data.</div>`;
            }
        }
    </script>

    <style>
        /* Leaderboard specific styles */
        .leaderboard-hero {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: var(--spacing-3xl) 0;
            position: relative;
            overflow: hidden;
        }

        .leaderboard-hero::before {
            content: 'üèÜ';
            position: absolute;
            top: 50%;
            right: 5%;
            transform: translateY(-50%);
            font-size: 20rem;
            opacity: 0.05;
            z-index: 1;
        }

        .hero-content {
            position: relative;
            z-index: 2;
            text-align: center;
        }

        .hall-of-fame-badge {
            background: rgba(255, 255, 255, 0.2);
            padding: var(--spacing-sm) var(--spacing-xl);
            border-radius: var(--border-radius-lg);
            font-size: 0.875rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            margin-bottom: var(--spacing-lg);
            display: inline-block;
        }

        .hero-title {
            font-size: 4rem;
            font-weight: 900;
            margin-bottom: var(--spacing-md);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .hero-subtitle {
            font-size: 1.25rem;
            opacity: 0.9;
            margin-bottom: var(--spacing-2xl);
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .ranking-filters {
            display: flex;
            justify-content: center;
            gap: var(--spacing-md);
            flex-wrap: wrap;
            margin-bottom: var(--spacing-xl);
        }

        .filter-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
            padding: var(--spacing-sm) var(--spacing-lg);
            border-radius: var(--border-radius-lg);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .filter-btn:hover,
        .filter-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
            transform: translateY(-2px);
        }

        .current-rankings {
            padding: var(--spacing-3xl) 0;
        }

        .rankings-header {
            text-align: center;
            margin-bottom: var(--spacing-xl);
        }

        .rankings-title {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: var(--spacing-sm);
            color: var(--text-primary);
        }

        .rankings-subtitle {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 0;
        }





        .full-rankings {
            display: flex;
            flex-direction: column;
            background: var(--card-bg);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-card);
            overflow: hidden;
        }

        .rankings-table {
            width: 100%;
        }

        .full-rankings-tools {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

        .year-scrubber-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.22);
            color: var(--text-primary);
            padding: 0.45rem 0.8rem;
            border-radius: 999px;
            font-size: 0.875rem;
            font-weight: 700;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        .year-scrubber-btn:hover {
            background: rgba(255, 255, 255, 0.14);
            transform: translateY(-1px);
        }

        .year-scrubber-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .year-scrubber-btn__caret {
            opacity: 0.9;
        }

        .year-scrubber-overlay {
            position: fixed;
            inset: 0;
            z-index: 1000;
        }

        .year-scrubber-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0);
        }

        .year-scrubber-panel {
            position: absolute;
            left: 50%;
            top: 140px;
            transform: translateX(-50%);
            width: min(1200px, calc(100% - 2rem));
            background: var(--card-bg);
            border: 2px solid rgba(34, 197, 94, 0.25);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-xl);
            padding: var(--spacing-lg);
        }

        .year-scrubber-panel__header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .year-scrubber-panel__title {
            font-weight: 900;
            color: var(--text-primary-dark);
        }

        .year-scrubber-panel__close {
            background: transparent;
            border: 1px solid rgba(26, 26, 26, 0.18);
            border-radius: 999px;
            padding: 0.35rem 0.75rem;
            font-weight: 700;
            color: var(--text-primary-dark);
            cursor: pointer;
        }

        .year-scrubber-panel__body {
            position: relative;
            padding-bottom: 0.25rem;
        }

        .year-scrubber-range {
            width: 100%;
            margin: 0;
            accent-color: var(--primary);
        }

        /* Make the handle feel like a vertical grab bar */
        .year-scrubber-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 42px;
            border-radius: 10px;
            background: var(--primary);
            border: 2px solid rgba(10, 26, 15, 0.25);
            cursor: grab;
        }
        .year-scrubber-range::-moz-range-thumb {
            width: 14px;
            height: 42px;
            border-radius: 10px;
            background: var(--primary);
            border: 2px solid rgba(10, 26, 15, 0.25);
            cursor: grab;
        }

        .year-scrubber-ticks {
            position: relative;
            height: 12px;
            margin-top: 0.35rem;
        }

        .year-scrubber-tick {
            position: absolute;
            top: 0;
            width: 2px;
            height: 10px;
            background: rgba(26, 26, 26, 0.22);
            transform: translateX(-1px);
        }

        .sample-filter-toggle {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary-dark);
            user-select: none;
        }

        .sample-filter-toggle input {
            accent-color: var(--primary);
        }

        .sample-filter-toggle__text {
            font-weight: 600;
            color: var(--text-primary-dark);
        }

        .sample-filter-toggle__hint {
            color: var(--text-secondary-dark);
            opacity: 0.85;
            font-weight: 500;
        }

        /* Dark-background variant (above the table on green bg) */
        .sample-filter-toggle--dark {
            color: var(--text-secondary);
        }

        .sample-filter-toggle--dark .sample-filter-toggle__text {
            color: var(--text-primary);
        }

        .sample-filter-toggle--dark .sample-filter-toggle__hint {
            color: var(--text-secondary);
            opacity: 0.9;
        }

        .rankings-table-body {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            padding: var(--spacing-md);
            background: rgba(15, 36, 25, 0.06);
        }

        .rankings-table-header {
            display: grid;
            grid-template-columns: 80px 1.2fr 120px 120px 100px 120px 80px;
            background: var(--primary);
            color: white;
            padding: var(--spacing-lg) var(--spacing-md);
            font-weight: 600;
            font-size: 0.875rem;
        }
        
        .rankings-table-header > div {
            color: white;
            font-weight: 600;
            font-size: 0.875rem;
        }

        .rankings-table-header .score-col {
            color: white;
            font-weight: 600;
        }

        .ranking-row {
            display: grid;
            grid-template-columns: 80px 1.2fr 120px 120px 100px 120px 80px;
            padding: var(--spacing-md) var(--spacing-lg);
            align-items: center;
            transition: all 0.2s ease;
            color: var(--text-primary-dark);
            background: white;
            border: 1px solid rgba(34, 197, 94, 0.22);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
            will-change: transform, opacity;
        }

        .ranking-row::before {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            width: 6px;
            background: rgba(212, 175, 55, 0.6);
        }

        .ranking-row:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: rgba(212, 175, 55, 0.55);
        }

        @media (prefers-reduced-motion: reduce) {
            .ranking-row {
                transition: none !important;
            }
        }

        .ranking-row.podium-row {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.14) 0%, rgba(255, 255, 255, 1) 70%);
            border-color: rgba(212, 175, 55, 0.55);
        }

        /* Alternating accents so rows feel more distinct */
        .rankings-table-body .ranking-row:nth-child(odd)::before { background: rgba(212, 175, 55, 0.65); }
        .rankings-table-body .ranking-row:nth-child(even)::before { background: rgba(34, 197, 94, 0.55); }

        /* Podium accents (top 3 rows in current view) */
        .rankings-table-body .ranking-row:nth-child(1)::before { background: var(--gold); }
        .rankings-table-body .ranking-row:nth-child(2)::before { background: var(--silver); }
        .rankings-table-body .ranking-row:nth-child(3)::before { background: var(--bronze); }

        .rank-col {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .rank-medal {
            font-size: 1.125rem;
        }

        .player-link {
            text-decoration: none;
            color: inherit;
        }

        .player-link:hover .player-name {
            color: var(--primary);
        }

        .player-name {
            font-weight: 850;
            color: var(--primary-dark);
            transition: color 0.2s ease;
        }

        .player-nickname {
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary-dark);
            font-style: italic;
        }

        .score-col {
            font-weight: 700;
            font-family: var(--font-primary);
            color: var(--primary);
            font-size: 1.125rem;
        }

        /* Value emphasis: color only (no bubbles) */
        .ranking-row .score-col,
        .ranking-row .wins-col,
        .ranking-row .percentage-col,
        .ranking-row .podium-col,
        .ranking-row .avg-finish-col,
        .ranking-row .recent-col,
        .ranking-row .tournaments-col,
        .ranking-row .rounds-won-col,
        .ranking-row .rounds-played-col,
        .ranking-row .booby-count-col,
        .ranking-row .booby-percent-col {
            font-variant-numeric: tabular-nums;
            justify-self: center;
            text-align: center;
        }

        .ranking-row .score-col {
            color: var(--primary);
            font-weight: 900;
            background: transparent;
            border: none;
            padding: 0;
            border-radius: 0;
            width: auto;
        }

        .ranking-row .wins-col,
        .ranking-row .tournaments-col,
        .ranking-row .percentage-col,
        .ranking-row .podium-col,
        .ranking-row .avg-finish-col,
        .ranking-row .recent-col,
        .ranking-row .rounds-won-col,
        .ranking-row .rounds-played-col,
        .ranking-row .booby-count-col,
        .ranking-row .booby-percent-col {
            color: var(--primary-dark);
            font-weight: 750;
            background: transparent;
            border: none;
            padding: 0;
            border-radius: 0;
            width: auto;
        }

        .trend-col {
            font-size: 1.25rem;
        }

        .rounds-won-col, .rounds-played-col {
            font-weight: 500;
            color: var(--text-primary-dark);
            text-align: center;
        }

        /* Career Stats specific grid layout */
        .career-stats .rankings-table-header {
            grid-template-columns: 80px 1.2fr 140px 140px 120px 80px;
        }

        .career-stats .ranking-row {
            grid-template-columns: 80px 1.2fr 140px 140px 120px 80px;
        }

        .performance-stats .rankings-table-header {
            grid-template-columns: 80px 1.5fr 160px 120px 80px;
        }
        .championships-layout .rankings-table-header {
            grid-template-columns: 80px 1.2fr 120px 120px 120px 80px;
        }
        .seed-stats .rankings-table-header {
            grid-template-columns: 80px 1.5fr 120px 120px 120px 120px 120px 80px;
        }

        .seed-stats .ranking-row {
            grid-template-columns: 80px 1.5fr 120px 120px 120px 120px 120px 80px;
        }

        .performance-stats .ranking-row {
            grid-template-columns: 80px 1.5fr 160px 120px 80px;
        }
        .championships-layout .ranking-row {
            grid-template-columns: 80px 1.2fr 120px 120px 120px 80px;
        }
        .booby-stats .rankings-table-header {
            grid-template-columns: 80px 1.5fr 140px 140px 120px 80px;
        }

        .booby-stats .ranking-row {
            grid-template-columns: 80px 1.5fr 140px 140px 120px 80px;
        }

        .booby-count-col,
        .booby-percent-col {
            text-align: center;
            font-weight: 600;
            color: var(--text-primary-dark);
        }

        .booby-percent-col {
            font-variant-numeric: tabular-nums;
        }

        .ranking-insights {
            padding: var(--spacing-3xl) 0;
            background: var(--bg-secondary);
        }

        .insights-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--spacing-xl);
        }

        .insight-card {
            background: var(--card-bg);
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-card);
            border: 2px solid var(--card-border);
            transition: all 0.2s ease;
        }

        .insight-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-xl);
        }

        .insight-card.featured {
            border-color: var(--gold);
            background: linear-gradient(135deg, var(--card-bg) 0%, #fef3c7 100%);
        }

        .insight-icon {
            font-size: 3rem;
            margin-bottom: var(--spacing-lg);
        }

        .insight-content h3,
        .insight-card h3 {
            color: var(--text-primary-dark);
            margin-bottom: var(--spacing-md);
        }

        .insight-content p {
            color: var(--text-primary-dark);
            line-height: 1.6;
        }

        .insight-stat {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-top: var(--spacing-lg);
            padding-top: var(--spacing-lg);
            border-top: 1px solid var(--border);
        }

        /* "Clean" preview cards: ensure the gold number aligns to the title line,
           not the whole block (which may include 2nd/3rd lines). */
        .insight-stat--stacked {
            display: grid;
            grid-template-columns: auto 1fr;
            grid-template-rows: auto auto;
            column-gap: var(--spacing-md);
            row-gap: 0.35rem;
            align-items: start;
        }

        /* Let children become grid items so we can place title + footnotes on separate rows. */
        .insight-stat--stacked .insight-stat-meta {
            display: contents;
        }

        .insight-stat--stacked .stat-number {
            grid-column: 1;
            grid-row: 1;
            align-self: center; /* centers vs the title line */
        }

        .insight-stat--stacked .stat-label {
            grid-column: 2;
            grid-row: 1;
            align-self: center;
        }

        .insight-stat--stacked .insight-stat-footnotes {
            grid-column: 2;
            grid-row: 2;
        }

        .insight-stat-footnotes .hof-record-footnotes {
            margin-top: 0.35rem;
            gap: 0.3rem;
        }

        .insight-stat-footnotes .hof-record-footnote {
            font-size: 0.82rem;
            line-height: 1.25;
        }

        .insights-subsection {
            margin-top: var(--spacing-2xl);
        }

        .insights-subtitle {
            font-family: var(--font-secondary);
            font-size: 0.95rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.92);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 0 0 var(--spacing-lg);
        }

        .insights-subtitle .title-icon {
            font-size: 1.25rem;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 900;
            font-family: var(--font-primary);
            color: var(--primary);
        }

        .stat-label {
            font-size: 0.875rem;
            color: var(--text-secondary-dark);
        }

        .historical-champions {
            padding: var(--spacing-3xl) 0;
        }

        .champions-timeline {
            display: grid;
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-2xl);
        }

        .champion-entry {
            display: grid;
            grid-template-columns: 80px 1fr auto;
            gap: var(--spacing-lg);
            align-items: center;
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            box-shadow: var(--shadow-sm);
        }

        .champion-year {
            font-size: 1.5rem;
            font-weight: 900;
            font-family: var(--font-primary);
            color: var(--primary);
        }

        .champion-name {
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
        }

        .champion-highlight {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0;
        }

        .champion-medal {
            font-size: 2rem;
        }

        .championship-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-xl);
        }

        .records-section {
            padding: var(--spacing-3xl) 0;
            background: var(--bg-secondary);
        }

        .records-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--spacing-2xl);
        }

        .record-category h3 {
            font-family: var(--font-secondary);
            font-size: 0.85rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            font-weight: 900;
            color: var(--primary);
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-sm);
            border-bottom: 2px solid var(--primary);
        }

        .record-list {
            display: grid;
            gap: var(--spacing-md);
        }

        .record-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--card-bg);
            padding: var(--spacing-md) var(--spacing-lg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
            gap: var(--spacing-lg);
        }

        .record-title {
            font-weight: 500;
            color: var(--text-primary-dark);
        }

        .record-holder {
            font-weight: 600;
            color: var(--primary);
        }

        /* Shared "card" styling for Hall of Fame tables on this page */
        .analytics-card {
            background: white;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-xl);
            box-shadow: var(--shadow-lg);
            border: 2px solid rgba(34, 197, 94, 0.25);
        }

        .muted {
            color: var(--text-secondary-dark);
            opacity: 0.85;
        }

        .report-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 0.65rem;
        }

        .report-table thead th {
            text-align: left;
            padding: 0.85rem 0.85rem;
            background: linear-gradient(135deg, var(--primary-dark) 0%, var(--bg-secondary) 100%);
            color: white;
            border: none;
            font-weight: 700;
            white-space: nowrap;
        }

        .report-table tbody td {
            text-align: left;
            padding: 0.85rem 0.85rem;
            background: white;
            color: var(--text-primary-dark);
            border-top: 1px solid rgba(34, 197, 94, 0.22);
            border-bottom: 1px solid rgba(34, 197, 94, 0.22);
            vertical-align: middle;
        }

        /* Card edges for table rows */
        .report-table tbody tr td:first-child {
            border-left: 1px solid rgba(34, 197, 94, 0.22);
            border-top-left-radius: var(--border-radius-lg);
            border-bottom-left-radius: var(--border-radius-lg);
            font-weight: 750;
            background: rgba(15, 36, 25, 0.03);
        }

        .report-table tbody tr td:last-child {
            border-right: 1px solid rgba(34, 197, 94, 0.22);
            border-top-right-radius: var(--border-radius-lg);
            border-bottom-right-radius: var(--border-radius-lg);
        }

        .report-table tbody tr:hover td {
            background: rgba(212, 175, 55, 0.10);
        }

        /* Section label rows inside the records table */
        .report-table tbody tr.hof-section-row td {
            background: transparent;
            border: none;
            padding: 1.15rem 0.25rem 0.25rem;
        }

        .hof-sep {
            color: rgba(10, 26, 15, 0.35);
            font-weight: 700;
        }

        /* Records panels layout (3 per row) */
        .hof-records-panels {
            display: grid;
            gap: var(--spacing-2xl);
        }

        .hof-records-section-title {
            font-family: var(--font-secondary);
            font-size: 0.9rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            font-weight: 900;
            color: var(--primary);
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-sm);
            border-bottom: 2px solid var(--primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .hof-records-section-emoji {
            font-size: 1.35rem;
        }

        .hof-records-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--spacing-xl);
        }

        .hof-record-card {
            border: 2px solid rgba(34, 197, 94, 0.20);
        }

        .hof-record-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: var(--spacing-md);
        }

        .hof-record-icon {
            font-size: 2.25rem;
            line-height: 1;
        }

        .hof-record-title {
            font-family: var(--font-secondary);
            font-size: 0.98rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            font-weight: 900;
            color: rgba(15, 23, 42, 0.90);
            line-height: 1.2;
            margin: 0;
        }

        .hof-record-main {
            color: var(--text-primary-dark);
        }

        .hof-record-winner-rank {
            font-size: 0.8rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            font-weight: 800;
            color: rgba(10, 26, 15, 0.65);
            margin-bottom: 0.35rem;
        }

        .hof-record-lead-sentence {
            line-height: 1.2;
            color: var(--text-primary-dark);
            word-break: break-word;
            font-size: 1.05rem;
        }

        .hof-lead-verb {
            color: rgba(10, 26, 15, 0.62);
            font-weight: 750;
        }

        .hof-lead-metric {
            color: var(--primary);
            font-weight: 950;
        }

        .hof-lead-extra {
            color: var(--text-secondary-dark);
            font-weight: 700;
        }

        .hof-record-lead-extras {
            margin-top: 0.35rem;
            font-size: 0.9rem;
            color: rgba(26, 26, 26, 0.7);
            line-height: 1.25;
        }

        .hof-record-divider {
            margin-top: var(--spacing-lg);
            padding-top: var(--spacing-lg);
            border-top: 1px solid rgba(10, 26, 15, 0.12);
        }

        .hof-record-footnotes {
            display: grid;
            gap: 0.4rem;
            margin-top: 0.65rem;
        }

        .hof-record-footnote {
            font-size: 0.9rem;
            color: rgba(26, 26, 26, 0.75);
            line-height: 1.25;
        }

        .hof-record-footnote-rank {
            font-size: 0.75rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            font-weight: 800;
            color: rgba(10, 26, 15, 0.45);
            white-space: nowrap;
        }

        .hof-record-footnote-text {
            color: rgba(26, 26, 26, 0.72);
        }

        /* Inline name/value styling used by the Records + History tables */
        .hof-name {
            color: var(--primary-dark);
            font-weight: 850;
        }

        .hof-value {
            color: var(--primary);
            font-weight: 900;
            font-variant-numeric: tabular-nums;
            white-space: nowrap;
        }

        .hof-detail {
            color: var(--text-secondary-dark);
            font-weight: 650;
            white-space: nowrap;
        }

        .data-issues-banner {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            border-bottom: 2px solid #ef4444;
            padding: var(--spacing-md) 0;
            box-shadow: 0 4px 20px rgba(239, 68, 68, 0.25);
        }

        .data-issues-banner__content {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 var(--spacing-md);
            color: #991b1b;
        }

        .data-issues-banner__content strong {
            display: inline-block;
            margin-bottom: var(--spacing-sm);
        }

        .data-issues-banner__content ul {
            margin: 0;
            padding-left: 1.25rem;
        }

        .data-issues-banner__content li {
            margin-bottom: 0.35rem;
        }

        .data-issues-banner__errors + .data-issues-banner__warning {
            margin-top: var(--spacing-md);
            padding-top: var(--spacing-md);
            border-top: 1px solid rgba(153, 27, 27, 0.25);
        }

        .data-issues-banner__warning {
            color: #7f1d1d;
        }

        .data-issues-banner__warning-header {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.35rem;
        }

        .data-issues-banner__pill {
            background: rgba(153, 27, 27, 0.1);
            border: 1px solid rgba(153, 27, 27, 0.3);
            border-radius: 999px;
            padding: 0.1rem 0.75rem;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .data-issues-banner__warning-list {
            margin: 0.35rem 0 0.35rem 1.25rem;
            padding-left: 0;
        }

        .data-issues-banner__warning-list li {
            margin-bottom: 0.25rem;
        }

        .data-issues-banner__dismiss {
            background: rgba(185, 28, 28, 0.1);
            border: 1px solid rgba(185, 28, 28, 0.4);
            border-radius: 999px;
            color: inherit;
            padding: 0.35rem 0.9rem;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        .data-issues-banner__dismiss:hover {
            background: rgba(185, 28, 28, 0.2);
            transform: translateY(-1px);
        }

        /* Table Controls Styling */
        .table-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: var(--spacing-xl) 0;
            margin-top: var(--spacing-lg);
            border-top: 1px solid var(--border);
            background: var(--bg-secondary);
        }

        .toggle-view-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-direction: row;
            gap: var(--spacing-sm);
            background: var(--card-bg);
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: var(--spacing-md) var(--spacing-xl);
            border-radius: var(--border-radius-lg);
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
            white-space: nowrap;
            writing-mode: horizontal-tb;
            min-width: 0;
        }

        .toggle-view-btn:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .toggle-view-btn.showing-all {
            background: var(--primary);
            color: white;
        }

        .toggle-view-btn.showing-all:hover {
            background: var(--primary-dark);
        }

        .btn-icon {
            font-size: 1rem;
        }

        @media (max-width: 768px) {
            .hero-title {
                font-size: 2.5rem;
            }
            
            .ranking-filters {
                flex-direction: column;
                align-items: center;
                gap: var(--spacing-sm);
                margin-bottom: var(--spacing-lg);
            }
            
            .rankings-title {
                font-size: 1.75rem;
            }
            
            .rankings-subtitle {
                font-size: 0.9rem;
            }
            
            .rankings-table-header,
            .ranking-row {
                grid-template-columns: 60px 1fr 80px 60px;
            }
            
            .tournaments-col,
            .percentage-col,
            .trend-col {
                display: none;
            }
            
            .records-grid {
                grid-template-columns: 1fr;
            }
            
            .table-controls {
                padding: var(--spacing-lg) 0;
            }
            
            .toggle-view-btn {
                padding: var(--spacing-sm) var(--spacing-lg);
                font-size: 0.8rem;
            }
        }
    </style>
</body>
</html>
